<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéØ</text></svg>">
    <title data-lang="title">Profi Multi-Sport & Kombi AI Betting Analyzer - GPT-4o Vision</title>
    <!-- MathJax for PhD-level mathematical formulas -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                    console.log('MathJax is loaded and ready');
                }
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0d2e 25%, #16213e 50%, #0f3460 75%, #0a0a0a 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
            line-height: 1.6;
            letter-spacing: 0.2px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem 0;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(6, 182, 212, 0.1));
            border-radius: 30px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 3.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #8b5cf6, #06b6d4, #10b981);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
            text-shadow: 0 0 30px rgba(139, 92, 246, 0.5);
            letter-spacing: -1px;
        }

        .language-selector {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
        }

        .lang-btn {
            padding: 0.5rem 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(15, 23, 42, 0.8);
            color: #64748b;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .lang-btn.active {
            background: linear-gradient(135deg, #8b5cf6, #06b6d4);
            color: white;
            border-color: rgba(139, 92, 246, 0.5);
            font-weight: 700;
        }

        .lang-btn:hover:not(.active) {
            background: rgba(139, 92, 246, 0.1);
            color: white;
            border-color: rgba(139, 92, 246, 0.3);
        }

        .nav-tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 3rem;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 20px;
            padding: 12px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            flex-wrap: wrap;
        }

        .nav-tab {
            padding: 15px 25px;
            border: none;
            background: transparent;
            color: #64748b;
            cursor: pointer;
            border-radius: 15px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
            overflow: hidden;
        }

        .nav-tab.active {
            background: linear-gradient(135deg, #8b5cf6, #06b6d4);
            color: white;
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.4);
            transform: translateY(-2px);
            font-weight: 700;
        }

        .nav-tab:hover:not(.active) {
            background: rgba(139, 92, 246, 0.1);
            color: white;
            transform: translateY(-1px);
        }

        .card {
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 25px;
            padding: 2.5rem;
            margin-bottom: 2rem;
            backdrop-filter: blur(20px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 50px rgba(139, 92, 246, 0.2);
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(139, 92, 246, 0.8), transparent);
        }

        .card h2 {
            color: #8b5cf6;
            margin-bottom: 2rem;
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 700;
        }
        
        .card h3 {
            color: #06b6d4;
            margin-bottom: 1.5rem;
            font-size: 1.5rem;
            border-left: 4px solid #06b6d4;
            padding-left: 1rem;
        }

        .upload-area {
            border: 2px dashed #8b5cf6;
            border-radius: 20px;
            padding: 4rem 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.4s ease;
            background: rgba(139, 92, 246, 0.05);
            min-height: 250px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .upload-area:hover {
            border-color: #06b6d4;
            background: rgba(6, 182, 212, 0.05);
            transform: scale(1.02);
        }

        .upload-area.drag-over {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.1);
            transform: scale(1.05);
        }

        .upload-icon {
            font-size: 5rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #8b5cf6, #06b6d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .images-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .image-item {
            position: relative;
            border-radius: 15px;
            overflow: hidden;
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid rgba(139, 92, 246, 0.3);
            transition: all 0.3s ease;
        }

        .image-item:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 30px rgba(139, 92, 246, 0.3);
        }

        .image-item img {
            width: 100%;
            height: 200px;
            object-fit: cover;
        }
        
        .image-overlay-content {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            padding: 15px;
            color: white;
            font-size: 12px;
        }

        .sport-badge {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .sport-football { background: #10b981; color: white; }
        .sport-soccer { background: #10b981; color: white; }
        .sport-tennis { background: #f59e0b; color: white; }
        .sport-basketball { background: #ef4444; color: white; }
        .sport-hockey { background: #06b6d4; color: white; }
        .sport-baseball { background: #3b82f6; color: white; }
        .sport-americanfootball { background: #8b5cf6; color: white; }
        .sport-other { background: #64748b; color: white; }
        .sport-unknown { background: #6b7280; color: white; }

        .analysis-status {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 600;
        }

        .status-pending { background: rgba(245, 158, 11, 0.8); color: white; }
        .status-analyzing { background: rgba(6, 182, 212, 0.8); color: white; }
        .status-completed { background: rgba(16, 185, 129, 0.8); color: white; }
        .status-error { background: rgba(239, 68, 68, 0.8); color: white; }

        .form-group {
            margin-bottom: 2rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.8rem;
            color: #e2e8f0;
            font-weight: 600;
            font-size: 1rem;
        }

        .form-input, .data-input-area {
            width: 100%;
            padding: 15px 20px;
            background: rgba(15, 23, 42, 0.8);
            border: 2px solid rgba(139, 92, 246, 0.2);
            border-radius: 15px;
            color: white;
            font-size: 16px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .form-input:focus, .data-input-area:focus {
            outline: none;
            border-color: #8b5cf6;
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.1);
        }

        .data-input-area {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
            min-height: 200px;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 700;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            text-decoration: none;
            font-size: 16px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #8b5cf6, #06b6d4);
            color: white;
            box-shadow: 0 10px 25px rgba(139, 92, 246, 0.3);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 35px rgba(139, 92, 246, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #b91c1c);
            color: white;
             box-shadow: 0 10px 25px rgba(239, 68, 68, 0.3);
        }
        .btn-danger:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 35px rgba(239, 68, 68, 0.4);
        }

        .btn-secondary {
            background: rgba(100, 116, 139, 0.5);
            color: #e2e8f0;
            border: 1px solid rgba(100, 116, 139, 0.7);
        }
        .btn-secondary:hover {
            background: rgba(100, 116, 139, 0.7);
        }

        .btn-large {
            padding: 20px 40px;
            font-size: 18px;
            width: 100%;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        .alert {
            padding: 1.5rem;
            border-radius: 15px;
            margin: 1.5rem 0;
            display: flex;
            align-items: flex-start;
            gap: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid;
        }

        .alert-success { background: rgba(16, 185, 129, 0.1); border-color: rgba(16, 185, 129, 0.3); color: #10b981; }
        .alert-info { background: rgba(6, 182, 212, 0.1); border-color: rgba(6, 182, 212, 0.3); color: #06b6d4; }
        .alert-warning { background: rgba(245, 158, 11, 0.1); border-color: rgba(245, 158, 11, 0.3); color: #f59e0b; }
        .alert-error { background: rgba(239, 68, 68, 0.1); border-color: rgba(239, 68, 68, 0.3); color: #ef4444; }

        .prompt-box {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(10, 185, 129, 0.4);
            border-radius: 15px;
            padding: 2rem;
            margin: 2rem 0;
            position: relative;
        }

        .prompt-content {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #10b981;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .copy-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid rgba(16, 185, 129, 0.4);
            color: #10b981;
            padding: 8px 16px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .copy-btn:hover { background: rgba(16, 185, 129, 0.3); }

        /* Enhanced Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(15px);
            transition: opacity 0.3s ease;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
            transition: opacity 0.3s ease;
        }

        .loading-content {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            padding: 3rem;
            border-radius: 25px;
            text-align: center;
            border: 2px solid #8b5cf6;
            box-shadow: 0 25px 50px rgba(0,0,0,0.7);
            max-width: 500px;
            width: 90%;
            position: relative;
            overflow: hidden;
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }

        .loading-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(139, 92, 246, 0.1), transparent);
            animation: shimmer 2s infinite;
        }

        .modal-content {
            background: rgba(15, 23, 42, 0.95);
            padding: 3rem;
            border-radius: 25px;
            text-align: center;
            border: 1px solid rgba(139, 92, 246, 0.3);
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }
        
        .modal-overlay:not(.hidden) .modal-content {
            transform: scale(1);
        }

        .loading-overlay:not(.hidden) .loading-content {
            transform: scale(1);
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .spinner {
            width: 80px;
            height: 80px;
            border: 6px solid #334155;
            border-top: 6px solid #8b5cf6;
            border-right: 6px solid #a855f7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 2rem;
            position: relative;
        }

        .spinner::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            border: 3px solid transparent;
            border-top: 3px solid #c084fc;
            border-radius: 50%;
            animation: spin 0.5s linear infinite reverse;
            transform: translate(-50%, -50%);
        }

        /* Progress Bar Container */
        .progress-container {
            width: 100%;
            margin: 2rem 0;
            position: relative;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: #334155;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #8b5cf6, #a855f7, #c084fc);
            border-radius: 10px;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
            width: 0%;
        }

        .progress-fill::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: progress-shimmer 1.5s infinite;
        }

        @keyframes progress-shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .progress-text {
            text-align: center;
            margin-top: 1rem;
            font-size: 1.2rem;
            font-weight: 600;
            color: #8b5cf6;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .progress-percentage {
            font-size: 2.5rem;
            font-weight: 700;
            color: #c084fc;
            margin: 0.5rem 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .loading-details {
            margin-top: 1.5rem;
            padding: 1rem;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 10px;
            border: 1px solid #374151;
            text-align: left;
        }

        .loading-step {
            color: #94a3b8;
            font-size: 0.9rem;
            margin: 0.5rem 0;
            display: flex;
            align-items: center;
            transition: all 0.3s ease;
        }

        .loading-step.active {
            color: #8b5cf6;
            font-weight: 600;
        }

        .loading-step.completed {
            color: #10b981;
        }

        .loading-step::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 0.5rem;
            background: #4b5563;
            flex-shrink: 0;
        }

        .loading-step.active::before {
            background: #8b5cf6;
            animation: pulse-dot 1s infinite;
        }

        .loading-step.completed::before {
            background: #10b981;
            content: '‚úì';
            color: white;
            font-size: 0.6rem;
            text-align: center;
            line-height: 8px;
            font-weight: bold;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulse { 
            0%, 100% { transform: scale(1); opacity: 1; } 
            50% { transform: scale(1.02); opacity: 0.8; } 
        }

        .tab-content { display: none; animation: fadeIn 0.5s ease; }
        .tab-content.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        .hidden { display: none !important; }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .stat-card {
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 2rem;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #8b5cf6, #06b6d4, #10b981);
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #8b5cf6, #06b6d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stat-label { color: #94a3b8; font-size: 1rem; font-weight: 500; }

        .bet-recommendations { display: grid; gap: 1rem; margin-top: 2rem; }
        .bet-card { background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 15px; padding: 1.5rem; position: relative; }
        .parlay-card { border-left: 5px solid #f59e0b; }
        .parlay-leg { background: rgba(0,0,0,0.2); padding: 0.75rem; border-radius: 10px; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;}
        
        .bet-confidence { position: absolute; top: 15px; right: 15px; padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: 600; }
        .confidence-high { background: #10b981; color: white; }
        .confidence-medium { background: #f59e0b; color: white; }
        .confidence-low { background: #ef4444; color: white; }

        .recommendation-section {
            margin-bottom: 3rem;
        }

        .section-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: #e2e8f0;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #8b5cf6;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .recommendation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1.5rem;
        }

        .recommendation-card {
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 1.5rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            border-left: 5px solid;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .recommendation-card.single { 
            border-left-color: #06b6d4; 
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(6, 182, 212, 0.05));
        }
        .recommendation-card.parlay { 
            border-left-color: #f59e0b; 
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(245, 158, 11, 0.05));
        }

        .recommendation-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 50px rgba(0,0,0,0.4);
            border-left-width: 8px;
        }

        .profit-display {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(16, 185, 129, 0.1));
            border: 2px solid rgba(16, 185, 129, 0.5);
            border-radius: 15px;
            padding: 1.5rem;
            margin: 1rem 0;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .profit-display::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(16, 185, 129, 0.1) 0%, transparent 70%);
            animation: pulse 3s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        .profit-amount {
            font-size: 2.5rem;
            font-weight: 900;
            color: #10b981;
            text-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
            position: relative;
        }

        .math-formula {
            background: rgba(99, 102, 241, 0.1);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 10px;
            padding: 0.75rem;
            margin: 0.5rem 0;
            font-family: 'Monaco', 'Menlo', monospace;
            color: #a5b4fc;
            overflow-x: auto;
            line-height: 1.8;
            text-align: center;
        }
        
        .math-formula .MathJax {
            color: #e2e8f0 !important;
        }
        
        .math-formula mjx-container {
            margin: 0.5rem 0 !important;
        }

        .bet-metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            margin: 0.5rem 0;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.2s ease;
        }

        .bet-metric:hover {
            background: rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .bet-metric-label {
            color: #94a3b8;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .bet-metric-value {
            font-weight: 700;
            font-size: 1.1rem;
        }

        .rec-header {
            font-weight: 600;
            color: #e2e8f0;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
        }
        
        .rec-market {
             font-weight: bold;
             color: #06b6d4;
        }
        
        .rec-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            font-size: 0.9rem;
            margin-top: 1rem;
        }
        .rec-details div {
            background: rgba(0,0,0,0.2);
            padding: 0.5rem;
            border-radius: 8px;
        }
        .rec-details strong {
            color: #94a3b8;
            margin-right: 0.5rem;
        }
        .rec-parlay-leg {
            background: rgba(0,0,0,0.3);
            padding: 0.75rem;
            border-radius: 10px;
            margin-bottom: 0.5rem;
            border-left: 3px solid #64748b;
        }

        @media (max-width: 768px) {
            .container { padding: 15px; }
            .header h1 { font-size: 2.5rem; }
            .nav-tabs { flex-wrap: wrap; gap: 8px; }
            .nav-tab { padding: 12px 16px; font-size: 14px; }
            .stats-grid { grid-template-columns: 1fr; }
            .images-container { grid-template-columns: 1fr; }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1 id="app-title" data-lang="title">üéØ Advanced Sports Betting Analyzer</h1>
            <p id="app-subtitle" data-lang="subtitle" style="color: #94a3b8; font-size: 1.2rem;">Professional Multi-Sport AI Analysis</p>
            <div class="language-selector">
                <button class="lang-btn" data-lang="en">EN</button>
                <button class="lang-btn" data-lang="hu">HU</button>
            </div>
        </header>

        <nav class="nav-tabs" role="tablist">
            <button class="nav-tab active" role="tab" aria-selected="true" aria-controls="setup" data-tab="setup" data-lang="navSettings">üîß API Settings</button>
            <button class="nav-tab" role="tab" aria-selected="false" aria-controls="upload" data-tab="upload" data-lang="navTips">üì∏ Image Collection</button>
            <button class="nav-tab" role="tab" aria-selected="false" aria-controls="analysis" data-tab="analysis" data-lang="navCalculator">üîç Analysis & Data Processing</button>
            <button class="nav-tab" role="tab" aria-selected="false" aria-controls="results" data-tab="results" data-lang="navPortfolio">üíé Results</button>
            <button class="nav-tab" role="tab" aria-selected="false" aria-controls="math" data-tab="math" data-lang="navMath">üìê Mathematics</button>
            <button class="nav-tab" role="tab" aria-selected="false" aria-controls="guide" data-tab="guide" data-lang="navGuide">üìò Guide</button>
        </nav>

        <main>
            <!-- API Setup Tab -->
            <div id="setup" role="tabpanel" class="tab-content active">
                <div class="card">
                    <h2 data-lang="apiConfigTitle">üîë OpenAI API Configuration</h2>
                    <div class="form-group">
                        <label class="form-label" for="apiKey" data-lang="apiKeyLabel">OpenAI API Key (GPT-4o Vision)</label>
                        <input type="password" id="apiKey" class="form-input" data-lang-placeholder="apiKeyPlaceholder" onchange="validateApiKey()">
                    </div>
                    <button class="btn btn-primary" onclick="testApiConnection()" id="testApiBtn" disabled data-lang="testApiButton">
                        üîç <span data-lang="testApiButton">Test API Connection</span>
                    </button>
                    <div id="apiStatus" class="alert alert-info hidden" role="status">
                        <span>‚ÑπÔ∏è</span>
                        <span data-lang="apiStatusText">API status...</span>
                    </div>
                </div>

                <div class="card">
                    <h2 data-lang="aiModelTitle">ü§ñ AI Model Selection</h2>
                    <div class="alert alert-info">
                        <span>üí°</span>
                        <div>
                            <strong data-lang="aiModelInfoTitle">Advanced AI Analysis:</strong><br>
                            <span data-lang="aiModelInfoText">Select an AI model for complex text analysis (weather conditions, player injuries, tactical analysis). This is optional and enhances the mathematical calculations.</span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="aiModel" data-lang="aiModelLabel">AI Model for Complex Analysis (Optional)</label>
                        <select id="aiModel" class="form-input">
                            <option value="none" data-lang="aiModelNone">None (Basic Analysis Only)</option>
                            <option value="chatgpt" data-lang="aiModelChatGPT">ChatGPT-4o</option>
                            <option value="deepseek" data-lang="aiModelDeepSeek">DeepSeek</option>
                            <option value="perplexity" data-lang="aiModelPerplexity">Perplexity</option>
                            <option value="gemini" data-lang="aiModelGemini">Google Gemini</option>
                        </select>
                        <small style="color: #94a3b8;" data-lang="aiModelHint">Advanced models can analyze weather, injuries, and tactical factors for more accurate predictions.</small>
                    </div>
                    <div class="form-group" id="aiApiKeyGroup" style="display: none;">
                        <label class="form-label" for="aiApiKey" data-lang="aiApiKeyLabel">AI Model API Key (Optional)</label>
                        <input type="password" id="aiApiKey" class="form-input" data-lang-placeholder="aiApiKeyPlaceholder">
                        <small style="color: #94a3b8;" data-lang="aiApiKeyHint">Required only for automated analysis. Leave empty for manual prompts.</small>
                    </div>
                    <div class="alert alert-info" style="margin-top: 1rem;">
                        <span>ü§ñ</span>
                        <div>
                            <strong data-lang="autoProcessingTitle">Automatikus feldolgoz√°s:</strong><br>
                            <span data-lang="autoProcessingText">Ha megadsz AI modellt √©s API kulcsot, a program automatikusan feldolgozza a prompt v√°lasz√°t √©s bet√∂lti az eredm√©nyeket. Ha nincs AI modell, manu√°lisan kell beillesztened a JSON v√°laszt.</span>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" id="enableAutoDataSearch" style="margin-right: 0.5rem;">
                            <span data-lang="enableAutoDataSearchLabel">üîç Automatikus Adatkeres√©s (Perplexity API)</span>
                        </label>
                        <small style="color: #94a3b8; display: block; margin-top: 0.5rem;" data-lang="autoDataSearchHint">Ha bekapcsolod, a program automatikusan megkeresi az interneten az √∂sszes sz√ºks√©ges adatot minden meccshez. Perplexity API kulcs sz√ºks√©ges.</small>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" id="enablePostAnalysisSearch" style="margin-right: 0.5rem;">
                            <span data-lang="enablePostAnalysisSearchLabel">ü§ñ GPT Elemz√©s Ut√°n Auto-Adatkeres√©s</span>
                        </label>
                        <small style="color: #94a3b8; display: block; margin-top: 0.5rem;" data-lang="postAnalysisSearchHint">Ha bekapcsolod, a GPT k√©pelemz√©s befejez√©se ut√°n automatikusan elindul a teljes adatkeres√©s minden bonyolult adattal. Perplexity API kulcs sz√ºks√©ges.</small>
                    </div>
                </div>

                <div class="card">
                    <h2 data-lang="bankrollTitle">üí∞ Bankroll Management</h2>
                    <div class="form-group">
                        <label class="form-label" for="capital" data-lang="capitalLabel">Available Capital (EUR)</label>
                        <input type="number" id="capital" class="form-input" value="1000" min="100">
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="maxRisk" data-lang="maxRiskLabel">Maximum Portfolio Risk (%)</label>
                        <input type="number" id="maxRisk" class="form-input" value="15" min="5" max="20">
                        <small style="color: #94a3b8;" data-lang="maxRiskHint">Recommended: max 15% for conservative approach</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="kellyModifierSingle" data-lang="kellyModifierSingleLabel">Kelly Modifier (Single)</label>
                        <input type="number" id="kellyModifierSingle" class="form-input" value="0.25" min="0.1" max="0.5" step="0.05">
                        <small style="color: #94a3b8;" data-lang="kellyModifierSingleHint">Conservative Kelly applied to single bets</small>
                    </div>
                     <div class="form-group">
                        <label class="form-label" for="kellyModifierParlay" data-lang="kellyModifierParlayLabel">Kelly Modifier (Parlay)</label>
                        <input type="number" id="kellyModifierParlay" class="form-input" value="0.1" min="0.05" max="0.2" step="0.01">
                        <small style="color: #94a3b8;" data-lang="kellyModifierParlayHint">Extra conservative Kelly applied to parlay bets</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="comboStrategy" data-lang="comboStrategyLabel">Parlay Strategy</label>
                        <select id="comboStrategy" class="form-input">
                            <option value="prob" data-lang="comboStrategyHighProb">High Probability Parlays</option>
                            <option value="ev" data-lang="comboStrategyHighEV">High EV Parlays</option>
                        </select>
                        <small style="color: #94a3b8;" data-lang="comboStrategyHint">Choose whether probability or expected value should be the primary focus when generating parlays.</small>
                    </div>
                </div>
            </div>

            <!-- Image Upload Tab -->
            <div id="upload" role="tabpanel" class="tab-content">
                <div class="card">
                    <h2 data-lang="dataInputTitle">üìä Multi-Sport Data Collection</h2>
                    
                    <!-- Input Method Selection -->
                    <div style="margin-bottom: 2rem;">
                        <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                            <button class="btn btn-secondary" id="imageInputBtn" onclick="switchInputMode('image')" data-lang="imageInputMode">üì∏ Image Upload</button>
                            <button class="btn btn-secondary" id="textInputBtn" onclick="switchInputMode('text')" data-lang="textInputMode">üìù Text Input</button>
                        </div>
                    </div>
                    
                    <!-- Text Input Mode -->
                    <div id="textInputMode" style="display: none;">
                        <div class="alert alert-info">
                            <span>üéØ</span>
                            <div>
                                <strong data-lang="textInputInfoTitle">Paste betting information:</strong><br>
                                <span data-lang="textInputInfoText">‚Ä¢ Copy and paste from betting websites, forums, or tipster messages<br>
                                ‚Ä¢ Include match names, odds, markets, and any additional context<br>
                                ‚Ä¢ AI will extract all relevant information automatically</span>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="bettingTextInput" data-lang="bettingTextLabel">Betting Information (Text)</label>
                            <textarea id="bettingTextInput" class="data-input-area" rows="10" data-lang-placeholder="bettingTextPlaceholder"></textarea>
                        </div>
                        <button class="btn btn-primary" onclick="processBettingText()" id="processTextBtn" data-lang="processTextButton">
                            üîç Process Text Data
                        </button>
                    </div>
                    
                    <!-- Image Input Mode -->
                    <div id="imageInputMode">
                        <h3 data-lang="imageUploadTitle">üì∏ Multi-Sport Image Collection</h3>
                    <div class="alert alert-info">
                        <span>üéØ</span>
                        <div>
                            <strong data-lang="uploadInfoTitle">Upload all relevant screenshots:</strong><br>
                            <span data-lang="uploadInfoList">‚Ä¢ Multiple sports simultaneously (football, tennis, basketball, hockey)<br>
                            ‚Ä¢ Various markets (match results, goals, points, games)<br>
                            ‚Ä¢ Multiple bookmaker images for comparison<br>
                            ‚Ä¢ Statistical page images for detailed analysis (You can also paste with Ctrl+V!)</span>
                        </div>
                    </div>
                    
                    <div class="upload-area" id="uploadArea">
                        <div class="upload-icon">ü§ñ</div>
                        <h3 data-lang="imageUploadAreaTitle">Sports Betting Image Upload</h3>
                        <p style="color: #94a3b8; margin: 1rem 0;" data-lang="imageUploadAreaText">
                            Drag files here, click the button, or paste from clipboard (Ctrl+V)
                        </p>
                        <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()" data-lang="selectImagesButton">
                            üìÅ Select Images
                        </button>
                    </div>

                    <input type="file" id="fileInput" multiple accept="image/*" class="hidden">
                    <div id="imagesContainer" class="images-container"></div>
                    
                    <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                        <button class="btn btn-primary" onclick="startInitialAnalysis()" id="startAnalysisBtn" disabled style="flex-grow: 1;" data-lang="initialAnalysisButton">
                            üöÄ Initial GPT-4o Analysis
                        </button>
                            <button class="btn btn-danger" onclick="confirmDeleteImages()" id="deleteAllBtn" disabled data-lang="deleteImagesButton">
                                üóëÔ∏è Delete Images Only
                            </button>
                            <button class="btn btn-danger" onclick="confirmClearAllData()" id="clearDataBtn" data-lang="clearAllDataButton">
                                üí• Clear All Data
                        </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Analysis & Data Processing Tab -->
            <div id="analysis" role="tabpanel" class="tab-content">
                 <div class="card">
                    <h2 data-lang="analysisTitle">üîç Analysis & Data Processing</h2>
                    <div id="analysisResultsContainer">
                         <div class="alert alert-info">
                            <span>üìä</span>
                            <span data-lang="analysisInfo">Image analysis results and data retrieval prompts will appear here.</span>
                        </div>
                    </div>
                    <div id="dataProcessingContainer" class="hidden">
                        <div class="form-group">
                            <label class="form-label" for="retrievedData" data-lang="retrievedDataLabel">Inserted Data (JSON response from LLM)</label>
                            <textarea id="retrievedData" class="data-input-area" data-lang-placeholder="retrievedDataPlaceholder"></textarea>
                        </div>
                        <div style="display: flex; gap: 1rem; align-items: center;">
                            <button class="btn btn-primary btn-large" onclick="processAllRetrievedData()" id="processDataBtn" disabled data-lang="processDataButton" style="flex: 1;">
                            üîÑ Process All Data and Generate Recommendations
                        </button>
                            <button class="btn btn-secondary" onclick="testEmergencyJsonRepair()" data-lang="testJsonRepair" style="white-space: nowrap;">
                                üîß Test JSON Repair
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Results Tab -->
            <div id="results" role="tabpanel" class="tab-content">
                <div class="card">
                    <h2 data-lang="resultsTitle">üíé Portfolio Results</h2>
                    
                    <div id="portfolioSummary" class="stats-grid hidden" style="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));">
                        <!-- Populated by JS -->
                    </div>

                    <div id="resultsContainer" class="hidden" style="margin-top: 2rem;">
                        <div id="recommendations-container">
                            <!-- Populated by JS -->
                        </div>
                    </div>

                    <div id="noResults" class="alert alert-info">
                        <span>üìà</span>
                        <span data-lang="resultsInfo">Recommendations will appear after all data has been processed.</span>
                    </div>
                </div>
            </div>

            <!-- Math Tab -->
            <div id="math" role="tabpanel" class="tab-content">
                <div class="card">
                    <h2 data-lang="mathTitle">üìê Mathematics Behind the Scenes</h2>
                    <div style="color: #94a3b8; margin-bottom: 2rem;" data-lang="mathInfo">Below you will find all the formulas and their explanations that the program uses to calculate sports betting recommendations.</div>
                    <div style="font-size: 1.1rem; line-height: 1.7;">
                        <h3 data-lang="mathEdgeTitle">1. üìä Professzion√°lis √ârt√©kbecsl√©s √©s El≈ëny (Edge)</h3>
                        <div><b data-lang="mathFormulaLabel">Alapk√©plet:</b></div>
                        <div class="math-formula">$$\text{Edge} = p_{\text{val√≥s}} \times o_{\text{fogad√≥iroda}} - 1$$</div>
                        <div><b>R√©szletes Edge Sz√°m√≠t√°s:</b></div>
                        <div class="math-formula">$$\text{Edge}(\%) = \left(\frac{P_{\text{becs√ºlt}}}{P_{\text{implik√°lt}}} - 1\right) \times 100$$</div>
                        <div style="margin: 0.5rem 0;">ahol $P_{\text{implik√°lt}} = \frac{1}{\text{szorz√≥}}$ √©s $P_{\text{becs√ºlt}}$ = a saj√°t val√≥sz√≠n≈±s√©gi becsl√©s√ºnk</div>
                        
                        <div><b>üî¨ Fejlett EV Sz√°m√≠t√°s Integr√°lt S√∫lyoz√°ssal:</b></div>
                        <div class="math-formula">$$\text{EV}_{fejlett} = \text{t√©t} \times (P_{adj} \times o - 1)$$</div>
                        <div class="math-formula">$$P_{adj} = P_{alap} \times S_{sport} \times W_{id≈ëj√°r√°s} \times J_{j√°t√©kos} \times M_{motiv√°ci√≥}$$</div>
                        
                        <div><b>üå§Ô∏è Id≈ëj√°r√°si Kiigaz√≠t√°s (Szabadt√©ri Sportok):</b></div>
                        <div class="math-formula">$$W_{faktor} = 1 + \alpha \times |T - T_{opt}| + \beta \times v_{sz√©l} + \gamma \times P_{es≈ë} + \delta \times H_{p√°ra} + \epsilon \times \text{J√°t√©kst√≠lus}$$</div>
                        <div style="margin: 0.5rem 0;">‚öΩ Labdar√∫g√°s: $T_{opt} = 19¬∞C$, ‚öæ Baseball: $T_{opt} = 21¬∞C$, üéæ Tenisz: $T_{opt} = 22¬∞C$</div>
                        <div style="margin: 0.5rem 0;">üèÄ Kos√°rlabda, üèí J√©gkorong: $W_{faktor} = 1.0$ (belt√©ri sportok)</div>
                        <div style="margin: 0.5rem 0;">üåßÔ∏è Csapad√©k hat√°s: $\gamma = 0.3$ (prec√≠zi√≥s csapatokn√°l), $\epsilon = -0.4$ (sok kis passz)</div>
                        
                        <div><b>üë§ Hi√°nyz√≥ Kulcsj√°t√©kosok Kritikus Hat√°sa:</b></div>
                        <div class="math-formula">$$J_{faktor} = \prod_{i=1}^{n} (1 - I_i \times K_i \times P_i)$$</div>
                        <div style="margin: 0.5rem 0;">ahol $I_i$ = j√°t√©kos fontoss√°ga (0-1), $K_i$ = kulcsj√°t√©kos s√∫ly (2.5 ha kulcs, 1.0 ha nem), $P_i$ = poz√≠ci√≥ kritikuss√°g</div>
                        <div style="margin: 0.5rem 0;">üéØ Poz√≠ci√≥ s√∫lyok: Kapus/Dob√≥: 3.0, Playmaker: 2.8, Csillagj√°t√©kos: 2.5, Alapember: 1.5</div>
                        
                        <div><b>üéØ Sport-specifikus S√∫lyoz√°s:</b></div>
                        <div class="math-formula">$$S_{sport} = \begin{cases} 
                        0.5 + \frac{G_{impact}}{100} \times 0.8 & \text{üèí J√©gkorong (kapus)} \\
                        0.4 + \frac{P_{impact}}{100} \times 1.0 & \text{‚öæ Baseball (dob√≥)} \\
                        0.6 + \frac{Surf_{adv}}{100} \times 0.6 & \text{üéæ Tenisz (p√°lya)} \\
                        0.7 + \frac{Star_{impact}}{100} \times 0.5 & \text{‚öΩ Labdar√∫g√°s (csillag)} \\
                        1.0 & \text{egy√©b sportok}
                        \end{cases}$$</div>
                        
                        <div><b>üí™ Motiv√°ci√≥s Kiigaz√≠t√°s:</b></div>
                        <div class="math-formula">$$M_{faktor} = 1.0 + \frac{M_{home} - M_{away}}{100} \times 0.1$$</div>
                        <div style="margin: 0.5rem 0;">ahol $M_{home}, M_{away}$ = motiv√°ci√≥s sk√°la (1-100)</div>
                        
                        <div style="margin: 1rem 0;"><b data-lang="mathExplanationLabel">Magyar√°zat:</b> <span data-lang="mathEdgeExplanation">Az el≈ëny a val√≥s val√≥sz√≠n≈±s√©g √©s a fogad√≥iroda √°ltal implik√°lt val√≥sz√≠n≈±s√©g k√∂z√∂tti k√ºl√∂nbs√©g. A fejlett rendszer sport-specifikus faktorokkal korrig√°lja a val√≥sz√≠n≈±s√©geket a pontosabb EV sz√°m√≠t√°s√©rt.</span></div>
                        
                        <h3 data-lang="mathKellyTitle">2. üéØ Fejlett Kelly Krit√©rium (Optim√°lis T√©tar√°ny)</h3>
                        <div><b data-lang="mathFormulaLabel">Klasszikus Kelly K√©plet:</b></div>
                        <div class="math-formula">$$f^* = \frac{bp - q}{b} = \frac{p(o-1) - (1-p)}{o-1}$$</div>
                        
                        <div><b>üî¨ Fejlett Kelly Kiigaz√≠tott Val√≥sz√≠n≈±s√©ggel:</b></div>
                        <div class="math-formula">$$f^*_{adj} = \frac{b \times P_{adj} - (1-P_{adj})}{b}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $P_{adj}$ = a sport-specifikus s√∫lyoz√°ssal kiigaz√≠tott val√≥sz√≠n≈±s√©g</div>
                        
                        <div><b>Konzervat√≠v Kelly M√≥dos√≠t√°s:</b></div>
                        <div class="math-formula">$$f_{\text{biztons√°gos}} = f^*_{adj} \times k_{\text{m√≥dos√≠t√≥}} \times M_{\text{piac}}$$</div>
                        <div class="math-formula">$$M_{\text{piac}} = \begin{cases} 
                        0.8 & \text{sarok/k√°rtya piacok} \\
                        0.9 & \text{handicap piacok} \\
                        1.0 & \text{f≈ë piacok}
                        \end{cases}$$</div>
                        
                        <div><b>üé≤ Multi-Outcome Kelly (Kombik):</b></div>
                        <div class="math-formula">$$f^*_{kombi} = \frac{\sum_{i=1}^{n} p_i \times b_i - \sum_{i=1}^{n} (1-p_i)}{\prod_{i=1}^{n} b_i}$$</div>
                        <div style="margin: 0.5rem 0;">extra konzervat√≠v m√≥dos√≠t√≥val: $k_{kombi} = 0.1$</div>
                        
                        <div style="margin: 0.5rem 0;"><i data-lang="mathWhereLabel">ahol</i> $b = o - 1$ (nett√≥ szorz√≥), $p$ = val√≥sz√≠n≈±s√©g, $q = 1 - p$, $k_{\text{m√≥dos√≠t√≥}} \in [0.1, 0.5]$</div>
                        <div style="margin: 1rem 0;"><b data-lang="mathExplanationLabel">Magyar√°zat:</b> <span data-lang="mathKellyExplanation">A Kelly Krit√©rium matematikailag optim√°lis t√©tm√©retet sz√°mol a hossz√∫ t√°v√∫ t≈ëken√∂veked√©s maximaliz√°l√°s√°hoz. A fejlett verzi√≥ sport-specifikus kiigaz√≠t√°sokat √©s piac-specifikus m√≥dos√≠t√≥kat alkalmaz.</span></div>
                        
                        <h3>3. üìà Professzion√°lis Pontoz√°si Rendszer</h3>
                        <div><b>üèÜ Multi-Faktor Pontoz√°s:</b></div>
                        <div class="math-formula">$$\text{Score}_{total} = 0.4 \times S_{EV} + 0.25 \times S_{Kelly} + 0.2 \times S_{conf} + 0.1 \times S_{sport} + 0.05 \times S_{risk}$$</div>
                        
                        <div><b>üìä EV Pontsz√°m (40% s√∫ly):</b></div>
                        <div class="math-formula">$$S_{EV} = \min\left(\frac{EV_{sz√°zal√©k}}{25}, 4\right)$$</div>
                        <div style="margin: 0.5rem 0;">Maximum 4 pont 25%+ EV-n√©l</div>
                        
                        <div><b>üéØ Kelly Hat√©konys√°g (25% s√∫ly):</b></div>
                        <div class="math-formula">$$S_{Kelly} = \max\left(0, \min\left(\frac{b \times p - q}{b} \times 20, 3\right)\right)$$</div>
                        <div style="margin: 0.5rem 0;">Maximum 3 pont optim√°lis Kelly frakci√≥n√°l</div>
                        
                        <div><b>üî¨ Kock√°zat-Hozam Pontsz√°m (5% s√∫ly):</b></div>
                        <div class="math-formula">$$S_{risk} = \min\left(\frac{EV}{\sigma}, 1\right) \text{ ahol } \sigma = (o-1)\sqrt{p(1-p)}$$</div>
                        <div style="margin: 0.5rem 0;">Sharpe r√°ta alap√∫ kock√°zat-hozam optimaliz√°l√°s</div>
                        
                        <h3>4. üìà Bankroll N√∂veked√©si √©s T√∫l√©l√©si Modell</h3>
                        <div><b>Logaritmikus T≈ëken√∂veked√©s:</b></div>
                        <div class="math-formula">$$\log(W_n) = \log(W_0) + \sum_{i=1}^{n} \log(1 + f_i \times X_i)$$</div>
                        <div><b>Cs≈ëd Val√≥sz√≠n≈±s√©g (Ruin Probability):</b></div>
                        <div class="math-formula">$$P_{\text{cs≈ëd}} = \left(\frac{1-p}{p}\right)^{\frac{W_0}{\text{√°tlag t√©t}}}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $X_i = \begin{cases} b_i & \text{val√≥sz√≠n≈±s√©ggel } p_i \\ -1 & \text{val√≥sz√≠n≈±s√©ggel } 1-p_i \end{cases}$</div>
                        <div style="margin: 1rem 0;"><b>Gyakorlati Jelent√©s:</b> A logaritmikus modell biztos√≠tja, hogy soha ne fogadjunk el olyan t√©tet, ami cs≈ëdbe vihetne. A t√∫l√©l√©si val√≥sz√≠n≈±s√©g ford√≠tottan ar√°nyos a kock√°zatv√°llal√°ssal.</div>
                        
                        <h3>5. üé≤ Hossz√∫t√°v√∫ Nyeres√©gess√©gi Modell</h3>
                        <div><b>Monte Carlo Szimul√°ci√≥ (1000 iter√°ci√≥):</b></div>
                        <div class="math-formula">$$E[\text{Profit}] = \frac{1}{N} \sum_{i=1}^{N} \sum_{j=1}^{M} \text{Outcome}_{i,j}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $N = 1000$ szimul√°ci√≥, $M$ = fogad√°sok sz√°ma</div>
                        
                        <div><b>Nyer√©si Ar√°ny:</b></div>
                        <div class="math-formula">$$\text{Win Rate} = \frac{\sum_{i=1}^{N} \sum_{j=1}^{M} \mathbb{1}[\text{Win}_{i,j}]}{N \times M}$$</div>
                        
                        <div><b>Maximum Drawdown:</b></div>
                        <div class="math-formula">$$\text{Max DD} = \max_{i} \left(\text{Peak}_{i} - \text{Current}_{i}\right)$$</div>
                        
                        <div><b>Hossz√∫t√°v√∫ ROI:</b></div>
                        <div class="math-formula">$$\text{ROI}_{long} = \frac{E[\text{Profit}]}{\text{Total Stake}} \times 100$$</div>
                        
                        <div><b>Nyeres√©gess√©gi Konfidencia:</b></div>
                        <div class="math-formula">$$\text{Confidence} = \min\left(95, \max\left(5, 50 + \text{ROI}_{long} \times 2\right)\right)$$</div>
                        
                        <h3 data-lang="mathEVTitle">6. üí∞ V√°rhat√≥ √ârt√©k √©s ROI Sz√°m√≠t√°sok</h3>
                        <div><b data-lang="mathFormulaLabel">Alapvet≈ë EV K√©plet:</b></div>
                        <div class="math-formula">$$\text{EV} = \text{T√©t} \times \text{Edge} = S \times (p \times o - 1)$$</div>
                        <div><b>R√©szletes EV Felbont√°s:</b></div>
                        <div class="math-formula">$$\text{EV} = S \times p \times (o-1) - S \times (1-p) = S \times [p \times \text{nyerem√©ny} - (1-p) \times \text{vesztes√©g}]$$</div>
                        <div><b>ROI (Return on Investment):</b></div>
                        <div class="math-formula">$$\text{ROI}(\%) = \frac{\text{EV}}{\text{T√©t}} \times 100 = \text{Edge} \times 100$$</div>
                        <div style="margin: 1rem 0;"><b data-lang="mathExplanationLabel">Magyar√°zat:</b> <span data-lang="mathEVExplanation">A v√°rhat√≥ √©rt√©k a fogad√°s hossz√∫ t√°v√∫ √°tlagos nyeres√©g√©t mutatja. Pozit√≠v EV = nyeres√©ges fogad√°s v√°rhat√≥an. ROI sz√°zal√©kban fejezi ki a befektet√©s hat√©konys√°g√°t.</span></div>
                        
                        <h3>5. üìä Kock√°zat M√©r√©se: Variancia √©s Sharpe R√°ta</h3>
                        <div><b>Variancia (Sz√≥r√°s N√©gyzete):</b></div>
                        <div class="math-formula">$$\text{Var}(X) = p(1-p) \times (\text{nett√≥ szorz√≥})^2 = p(1-p) \times (o-1)^2$$</div>
                        <div><b>Sz√≥r√°s (Standard Devi√°ci√≥):</b></div>
                        <div class="math-formula">$$\sigma = \sqrt{\text{Var}(X)} = (o-1)\sqrt{p(1-p)}$$</div>
                        <div><b>Sharpe R√°ta (Kock√°zat-Hozam Ar√°ny):</b></div>
                        <div class="math-formula">$$\text{Sharpe} = \frac{\text{EV}}{\sigma} = \frac{S \times \text{Edge}}{S \times (o-1)\sqrt{p(1-p)}} = \frac{\text{Edge}}{(o-1)\sqrt{p(1-p)}}$$</div>
                        <div style="margin: 1rem 0;"><b>Gyakorlati Haszn√°lat:</b> Magas Sharpe r√°ta = jobb kock√°zat-hozam profil. Optim√°lis fogad√°sok: Sharpe > 0.5</div>
                        
                        <h3>7. üèÜ Sport-Specifikus Matematikai Modellek</h3>
                        
                        <div><b>‚öΩ Labdar√∫g√°s - Dixon-Coles Poisson Modell:</b></div>
                        <div class="math-formula">$$\lambda_{home} = \alpha \times \beta_{home} \times \gamma_{away} \times W_{weather}$$</div>
                        <div class="math-formula">$$\lambda_{away} = \alpha \times \beta_{away} \times \gamma_{home} \times W_{weather}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $\alpha$ = liga √°tlag, $\beta$ = t√°mad√≥er≈ë, $\gamma$ = v√©d≈ëer≈ë, $W$ = id≈ëj√°r√°s hat√°s</div>
                        
                        <div><b>üèí J√©gkorong - Fejlett Corsi/Fenwick + Kapus Modell:</b></div>
                        <div class="math-formula">$$\text{Goals}_{expected} = \text{Corsi}\% \times \text{Shooting}\% \times (1 - \text{Save}\%)_{opponent}$$</div>
                        <div class="math-formula">$$\text{Win Prob} = \frac{\text{Goals}_{home}}{\text{Goals}_{home} + \text{Goals}_{away}} \times G_{impact}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $G_{impact}$ = kapus hat√°s (0.7-1.3 range)</div>
                        
                        <div><b>‚öæ Baseball - Pitagorasz + Sabermetrics:</b></div>
                        <div class="math-formula">$$\text{Win}\% = \frac{\text{RS}^{1.83}}{\text{RS}^{1.83} + \text{RA}^{1.83}} \times P_{impact} \times W_{weather}$$</div>
                        <div class="math-formula">$$\text{Run Factor} = 1 + 0.1 \times \frac{T-21}{10} + 0.05 \times \text{Wind Speed}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $P_{impact}$ = dob√≥ hat√°s (0.6-1.4), $W_{weather}$ = id≈ëj√°r√°s hat√°s</div>
                        
                        <div><b>üéæ Tenisz - Markov L√°nc Modell:</b></div>
                        <div class="math-formula">$$P(\text{Match}) = P(\text{Set})^{n} \times \text{Surface}_{factor} \times I_{impact}$$</div>
                        <div class="math-formula">$$P(\text{Set}) = P(\text{Game})^{6} \times \text{Serve}_{advantage}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $I_{impact}$ = s√©r√ºl√©s hat√°s (0.5-1.0), kritikus egy√©ni sportban</div>
                        
                        <div><b>üèÄ Kos√°rlabda - N√©gy Faktor Modell:</b></div>
                        <div class="math-formula">$$\text{Efficiency} = 0.4 \times \text{eFG}\% + 0.25 \times \text{TOV}\% + 0.2 \times \text{OREB}\% + 0.15 \times \text{FT Rate}$$</div>
                        <div class="math-formula">$$\text{Points} = \text{Efficiency} \times \text{Possessions} \times \text{Pace} \times F_{fatigue}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $F_{fatigue} = e^{-\alpha \times \text{rest days}}$ (back-to-back penalty)</div>
                        
                        <h3 data-lang="mathParlayTitle">8. üîó Kombin√°lt Fogad√°sok Matematik√°ja</h3>
                        <div><b data-lang="mathParlayProbLabel">Egy√ºttes Val√≥sz√≠n≈±s√©g (F√ºggetlens√©g Felt√©telez√©s):</b></div>
                        <div class="math-formula">$$P_{\text{kombi}} = \prod_{i=1}^{n} p_i$$</div>
                        <div><b data-lang="mathParlayOddsLabel">Kombin√°lt Szorz√≥k:</b></div>
                        <div class="math-formula">$$O_{\text{kombi}} = \prod_{i=1}^{n} o_i$$</div>
                        <div><b>üîó Fejlett Korrel√°ci√≥ Kiigaz√≠t√°s:</b></div>
                        <div class="math-formula">$$P_{\text{kombi,korr}} = P_{\text{kombi}} \times C_{penalty}$$</div>
                        <div class="math-formula">$$C_{penalty} = \begin{cases} 
                        0.8 & \text{ha volatilis piacok (sarok/k√°rtya)} \\
                        0.9 & \text{ha nem f≈ë piacok} \\
                        1.0 & \text{ha f√ºggetlen f≈ë piacok}
                        \end{cases}$$</div>
                        
                        <div><b>Kombin√°lt Edge Fejlett Sz√°m√≠t√°s:</b></div>
                        <div class="math-formula">$$\text{Edge}_{\text{kombi}} = P_{\text{kombi,korr}} \times O_{\text{kombi}} - 1$$</div>
                        <div class="math-formula">$$\text{Kelly}_{\text{kombi}} = \frac{(O_{\text{kombi}} - 1) \times P_{\text{kombi,korr}} - (1 - P_{\text{kombi,korr}})}{O_{\text{kombi}} - 1}$$</div>
                        <div style="margin: 0.5rem 0;">Extra konzervat√≠v m√≥dos√≠t√≥: $k_{kombi} = 0.1$ (max 2% t≈ëke)</div>
                        
                        <div style="margin: 1rem 0;"><b data-lang="mathExplanationLabel">Magyar√°zat:</b> <span data-lang="mathParlayExplanation">A fejlett kombin√°lt fogad√°si modell figyelembe veszi a piaci korrel√°ci√≥kat √©s alkalmaz extra konzervat√≠v m√≥dos√≠t√≥kat a magasabb kock√°zat miatt.</span></div>
                        
                        <h3 data-lang="mathRiskTitle">9. üõ°Ô∏è Professzion√°lis Kock√°zatkezel√©si Mutat√≥k</h3>
                        <div><b>üìä Portf√≥li√≥ Kock√°zat:</b></div>
                        <div class="math-formula">$$\sigma_{\text{portf√≥li√≥}} = \sqrt{\sum_{i=1}^{n} w_i^2 \sigma_i^2 + \sum_{i=1}^{n} \sum_{j \neq i} w_i w_j \sigma_i \sigma_j \rho_{ij}}$$</div>
                        
                        <div><b>üéØ Dinamikus T√©t Limitek:</b></div>
                        <div class="math-formula">$$\text{Min Stake} = \max(5, 0.001 \times \text{Bankroll})$$</div>
                        <div class="math-formula">$$\text{Max Risk} = 0.05 \times \text{Bankroll} \text{ (single)}, 0.02 \times \text{Bankroll} \text{ (parlay)}$$</div>
                        
                        <div><b>üìà Portf√≥li√≥ Optimaliz√°l√°s:</b></div>
                        <div class="math-formula">$$\text{Scale Factor} = \min\left(1, \frac{\text{Max Portfolio Risk}}{\text{Planned Total Stake}}\right)$$</div>
                        <div style="margin: 0.5rem 0;">Automatikus sk√°l√°z√°s ha a tervezett t√©t t√∫ll√©pi a maxim√°lis kock√°zatot</div>
                        
                        <div><b>üèÜ Nyeres√©gess√©gi K√ºsz√∂b√∂k:</b></div>
                        <div class="math-formula">$$\text{Minimum Krit√©riumok} = \begin{cases} 
                        \text{Edge} \geq 3\% & \text{singles} \\
                        \text{Edge} \geq 6\% & \text{parlays} \\
                        \text{Confidence} \geq 0.3 & \text{mind} \\
                        \text{EV} \geq 0.5 & \text{mind}
                        \end{cases}$$</div>
                        
                        <div><b>üìä Kihaszn√°lts√°gi R√°ta:</b></div>
                        <div class="math-formula">$$\rho_{\text{kihaszn√°l√°s}} = \frac{\sum_{i=1}^{n} S_i}{W_{\text{teljes}}} \leq \rho_{\max} = 15\%$$</div>
                        
                        <div><b>üé≤ Diverzifik√°ci√≥s Metrik√°k:</b></div>
                        <div class="math-formula">$$D = \frac{\text{Egyedi meccsek sz√°ma}}{\text{√ñsszes fogad√°s}} \times \frac{\text{Sport√°gak sz√°ma}}{\text{√ñsszes sport√°g}}$$</div>
                        <div style="margin: 1rem 0;"><b>üèÖ Optim√°lis Portf√≥li√≥ Krit√©riumok:</b> D > 0.6, max 15% kihaszn√°l√°s, min 3% edge, Sharpe > 0.5, Long-term ROI > 10%</div>
                        <br>
                        <!-- START SPORT-SPECIFIC MODELS -->
                        <h2 style="margin-top:2rem; color:#8b5cf6;" data-lang="sportModelsTitle">üìä Sport-Specific Mathematical Models</h2>
                        <p style="color:#94a3b8;" data-lang="sportModelsInfo">The following section details the statistical/probabilistic models applied by the system for different sports to refine probability estimates. These models provide a more accurate picture than simple statistics.</p>
                        <br>
                        <h3 data-lang="footballTitle">‚öΩ Labdar√∫g√°s</h3>
                        <div><b data-lang="footballDixonColes">Dixon-Coles Poisson modell g√≥lsz√°mokhoz</b></div>
                        <div class="math-formula">
                            $$\lambda_{hazai} = \alpha_{hazai} \times \beta_{vend√©g} \times \gamma_{p√°lya}$$
                            $$P(X=x, Y=y) = \tau(x,y) \times \frac{e^{-\lambda_{hazai}} \lambda_{hazai}^x}{x!} \times \frac{e^{-\lambda_{vend√©g}} \lambda_{vend√©g}^y}{y!}$$
                                </div>
                        <div style="margin: 0.5rem 0;">ahol $\tau$ a Dixon-Coles kiigaz√≠t√°s:</div>
                        <div class="math-formula">
                            $$\tau(x,y) = \begin{cases}
                                1 - \lambda_{hazai} \times \lambda_{vend√©g} \times \rho & \text{ha } x=y=0 \\
                                1 + \lambda_{hazai} \times \rho & \text{ha } x=0, y=1 \\
                                1 + \lambda_{vend√©g} \times \rho & \text{ha } x=1, y=0 \\
                                1 - \rho & \text{ha } x=y=1 \\
                                1 & \text{egy√©b esetben}
                            \end{cases}$$
                            </div>
                            
                        <div><b data-lang="footballSkellam">Skellam eloszl√°s g√≥lk√ºl√∂nbs√©ghez</b></div>
                        <div class="math-formula">
                            $$P(D = k) = e^{-(\lambda_{hazai} + \lambda_{vend√©g})} \times \left(\frac{\lambda_{hazai}}{\lambda_{vend√©g}}\right)^{k/2} \times I_{|k|}(2\sqrt{\lambda_{hazai} \times \lambda_{vend√©g}})$$
                                </div>
                        <div style="margin: 0.5rem 0;">ahol $I_k$ az els≈ë t√≠pus√∫ m√≥dos√≠tott Bessel-f√ºggv√©ny.</div>
                        <br>
                        <div><b>V√°rhat√≥ G√≥lok (xG) Modell Bayes-i Friss√≠t√©ssel</b></div>
                        <div class="math-formula">
                            $$xG = \sum_{i=1}^{n} P(\text{g√≥l}_i | \theta_i)$$
                            $$\theta_i \sim \text{Beta}(\alpha_i, \beta_i)$$
                            </div>
                            
                        <div><b data-lang="footballCornersModel">Sz√∂gletek √©s Lapok Matematikai Modell</b></div>
                        <div class="math-formula">
                            $$\mu_{sz√∂glet} = \alpha_{t√°mad√°s} \times \beta_{v√©delem} \times \gamma_{st√≠lus} \times \delta_{id≈ëj√°r√°s}$$
                            $$\mu_{lap} = \rho_{j√°t√©kvezet≈ë} \times \sigma_{agresszivit√°s} \times \tau_{fontoss√°g}$$
                            $$P(\text{sz√∂glet} > n) = 1 - F_{Poisson}(n; \mu_{sz√∂glet})$$
                                </div>
                        <div style="margin: 0.5rem 0;">Id≈ëj√°r√°si hat√°s: $\delta_{id≈ëj√°r√°s} = 1 + (0.1 \times \text{sz√©lsebess√©g} + 0.05 \times \text{es≈ë intenzit√°s})$</div>
                        
                        <div><b data-lang="football1x2Model">1x2 Piaci Val√≥sz√≠n≈±s√©gi Modell</b></div>
                        <div class="math-formula">
                            $$P(\text{Hazai}) = \sum_{h>v} P(H=h, V=v)$$
                            $$P(\text{D√∂ntetlen}) = \sum_{h=v} P(H=h, V=v)$$
                            $$P(\text{Vend√©g}) = \sum_{v>h} P(H=h, V=v)$$
                                </div>
                        <div style="margin: 0.5rem 0;">Id≈ëj√°r√°si kiigaz√≠t√°s: $P_{adj} = P_{alap} \times (1 + \text{id≈ëj√°r√°s faktor})$</div>
                        <br>
                        <h3 data-lang="tennisTitle">üéæ Tenisz</h3>
                        <div><b data-lang="tennisEloModel">Fejlett Elo-alap√∫ Pont El≈ërejelz√©s</b></div>
                        <div class="math-formula">
                            $$Elo_{adj} = Elo_{alap} + \text{p√°lya kiigaz√≠t√°s} + \text{forma faktor} + \text{f√°radts√°g faktor}$$
                            $$P(\text{pont nyer√©s}) = \frac{1}{1 + 10^{(Elo_{ellenf√©l} - Elo_{j√°t√©kos})/400}}$$
                            $$P_{szolg√°lat} = \frac{p^4 \times (15 - 4p - 10p^2)}{1 - 2p + 2p^2}$$
                            </div>
                        <div style="margin: 0.5rem 0;">S√©r√ºl√©s faktor: $P_{adj} = P \times (1 - 0.2 \times \text{s√©r√ºl√©s s√∫lyoss√°g})$</div>
                        
                        <div><b data-lang="tennisMarkov">Markov-l√°nc modell szolg√°lat j√°t√©k/szett val√≥sz√≠n≈±s√©ghez</b></div>
                        <div class="math-formula">
                            $$p = \text{A j√°t√©kos pontnyer√©si val√≥sz√≠n≈±s√©ge saj√°t szolg√°l√°sn√°l}$$
                            $$\text{√Ållapott√©r: } (a,b) \text{ pont√°ll√°s a j√°t√©kban}$$
                            $$\text{√Åtmenetek: } (a,b) \rightarrow (a+1,b) \text{ val√≥sz√≠n≈±s√©ggel } p$$
                                </div>
                        <div style="margin: 0.5rem 0;">Id≈ëj√°r√°si hat√°s: $p_{adj} = p \times (1 - 0.02 \times \text{sz√©lsebess√©g} - 0.01 \times \text{h≈ëm√©rs√©klet elt√©r√©s})$</div>
                        <div style="margin: 1rem 0;" data-lang="tennisMarkovExplanation">A modell a teniszmeccset √°llapotok sorozatak√©nt kezeli (pontok, j√°t√©kok, szettek). Az id≈ëj√°r√°si k√∂r√ºlm√©nyek jelent≈ësen befoly√°solj√°k a szerva pontoss√°g√°t √©s a labda r√∂pp√°ly√°j√°t.</div>
                        
                        <div><b data-lang="tennisSurfaceModel">P√°lya-specifikus Teljes√≠tm√©ny Modell</b></div>
                        <div class="math-formula">
                            $$\text{P√°lya faktor} = \text{salak faktor} \times (1 + \text{p√°ratartalom hat√°s})$$
                            $$\text{Sebess√©g kiigaz√≠t√°s} = \frac{\text{labda sebess√©g p√°lya}}{\text{labda sebess√©g alapvet≈ë}}$$
                            $$\text{Pattan√°s faktor} = \text{p√°lya egy√ºtthat√≥} \times \text{h≈ëm√©rs√©klet faktor}$$
                                </div>
                        <br>
                        <h3>üèÄ Kos√°rlabda</h3>
                        <div><b>Fejlett Birtokl√°s-alap√∫ Modell</b></div>
                        <div class="math-formula">
                            $$\text{Birtokl√°sok} = 0.5 \times (FGA + 0.4 \times FTA - OREB + TOV)$$
                            $$\text{T√°mad√≥ hat√©konys√°g} = \frac{\text{Pontok}}{\text{Birtokl√°sok}} \times 100$$
                            $$\text{V√°rhat√≥ pontok} = \text{T√°mHat} \times \text{Birtokl√°sok} \times \text{temp√≥ faktor}$$
                        </div>
                        
                        <div><b>N√©gy Faktor Fejlett Modell</b></div>
                        <div class="math-formula">
                            $$eFG\% = \frac{FGM + 0.5 \times 3PM}{FGA}$$
                            $$TOV\% = \frac{TOV}{FGA + 0.44 \times FTA + TOV}$$
                            $$OREB\% = \frac{OREB}{OREB + Opp\_DREB}$$
                                </div>
                        
                        <div><b>F√°radts√°g √©s Menetrend Hat√°s Modell</b></div>
                        <div class="math-formula">
                            $$\text{F√°radts√°g faktor} = e^{-\alpha \times \text{pihen≈ë napok}} \times \text{utaz√°si t√°vols√°g b√ºntet√©s}$$
                            $$\text{Teljes√≠tm√©ny adj} = \text{Alap teljes√≠tm√©ny} \times (1 + \text{f√°radts√°g faktor})$$
                                </div>
                        <br>
                        <h3>üèí J√©gkorong - Fejlett Corsi/Fenwick Modellek</h3>
                        <div><b>üéØ Advanced Corsi/Fenwick Model</b></div>
                        <div class="math-formula">$$\text{Corsi}\% = \frac{SF + BS + MS}{SF + BS + MS + SA + BA + MA}$$</div>
                        <div class="math-formula">$$xG = \sum_{i=1}^{n} Q_i \times D_i \times A_i \times S_i$$</div>
                        <div class="math-formula">$$\text{PDO} = (\text{Shooting}\% + \text{Save}\%) \times 100$$</div>
                        <div style="margin: 0.5rem 0;">ahol $SF$ = l√∂v√©sek, $BS$ = blokkolt, $MS$ = mell√©, $Q_i$ = l√∂v√©s min≈ës√©g, $D_i$ = t√°vols√°g faktor, $A_i$ = sz√∂g faktor, $S_i$ = helyzet t√≠pus</div>
                        
                        <div><b>ü•Ö Kapus Teljes√≠tm√©ny Modell</b></div>
                        <div class="math-formula">$$\text{Save}\% = 1 - \frac{GA}{SA}$$</div>
                        <div class="math-formula">$$\text{GSAA} = xGA - GA$$</div>
                        <div class="math-formula">$$P_{quality} = f(\text{forma}, \text{pihen≈ë}, \text{ellenf√©l er≈ë}) \times W_{f√°radts√°g}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $GA$ = kapott g√≥lok, $SA$ = l√∂v√©sek, $GSAA$ = v√°rhat√≥ f√∂l√∂tti v√©d√©sek, $W_{f√°radts√°g}$ = f√°radts√°g s√∫ly</div>
                        
                        <div><b>‚ö° Speci√°lis Egys√©gek Fejlett Modell</b></div>
                        <div class="math-formula">$$PP_{eff} = \frac{PP_{goals}}{PP_{opportunities}} \times \text{id≈ëj√°r√°s faktor}$$</div>
                        <div class="math-formula">$$PK_{eff} = 1 - \frac{PP_{goals\_allowed}}{Times_{shorthanded}}$$</div>
                        <div class="math-formula">$$ST_{impact} = (PP_{opp} \times PP_{eff}) - (PK_{sit} \times PK_{eff\_opp})$$</div>
                        <div style="margin: 0.5rem 0;">J√©gkorong id≈ëj√°r√°s hat√°s: $W_{temp} = 1 + 0.02 \times |T - (-5)|$ (optim√°lis -5¬∞C)</div>
                        <br>
                        <h3>‚öæ Baseball - Fejlett Sabermetrics Modellek</h3>
                        <div><b>üìä Sabermetric Advanced Model</b></div>
                        <div class="math-formula">$$wOBA = \frac{0.69 \times BB + 0.72 \times HBP + 0.89 \times 1B + 1.27 \times 2B + 1.62 \times 3B + 2.10 \times HR}{AB + BB - IBB + SF + HBP}$$</div>
                        <div class="math-formula">$$wRC+ = \frac{(wOBA - lg_{wOBA})}{wOBA_{scale}} + \frac{lg_R}{PA} \times PF \times 100$$</div>
                        <div class="math-formula">$$FIP = \frac{13 \times HR + 3 \times (BB + HBP) - 2 \times K}{IP} + FIP_{constant}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $BB$ = base on balls, $HBP$ = hit by pitch, $1B/2B/3B/HR$ = egyes/kettes/h√°rmas/hazafut√°s</div>
                        
                        <div><b>üèÜ Pythagorean Expectation Enhanced</b></div>
                        <div class="math-formula">$$W\% = \frac{RS^k}{RS^k + RA^k}$$</div>
                        <div class="math-formula">$$RS_{adj} = RS \times PF \times WF \times AF$$</div>
                        <div class="math-formula">$$WF = f(T, v_{sz√©l}, \text{ir√°ny}, H, h_{altitude})$$</div>
                        <div style="margin: 0.5rem 0;">ahol $k = 1.83$ (optimaliz√°lt kitev≈ë), $RS$ = fut√°sok, $RA$ = engedett fut√°sok, $PF$ = park faktor, $WF$ = id≈ëj√°r√°s faktor, $AF$ = magass√°g faktor</div>
                        
                        <div><b>üéØ Kezd≈ë Dob√≥ Hat√°s Modell</b></div>
                        <div class="math-formula">$$SP_{impact} = \frac{(FIP - Liga_{FIP}) \times IP_{v√°rhat√≥}}{9}$$</div>
                        <div class="math-formula">$$Bullpen_{haszn√°lat} = f(Q_{kezd≈ë}, S_{j√°t√©k}, M_{tendencia})$$</div>
                        <div class="math-formula">$$Total_{impact} = SP_{impact} + BP_{impact} + O_{adj}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $FIP$ = Fielding Independent Pitching, $IP$ = dobott innings, $Q$ = min≈ës√©g, $S$ = j√°t√©khelyzet, $M$ = menedzser</div>
                        
                        <div><b>üå§Ô∏è Id≈ëj√°r√°s Hat√°s Komplex Modell</b></div>
                        <div class="math-formula">$$HR_{faktor} = 1 + 0.1 \times \frac{T - 21}{10} + 0.05 \times \frac{v_{seg√≠t≈ë}}{10}$$</div>
                        <div class="math-formula">$$Run_{k√∂rnyezet} = PF \times WF \times AF \times H_{faktor}$$</div>
                        <div class="math-formula">$$R_{v√°rhat√≥} = (R_A + R_B) \times Run_{k√∂rnyezet} \times D_{faktor}$$</div>
                        <div style="margin: 0.5rem 0;">Baseball id≈ëj√°r√°s optimum: $T_{opt} = 21¬∞C$, $H_{opt} = 40\%$, $v_{sz√©l} < 15$ km/h, $h_{altitude}$ hat√°s: $+0.01\%$/m√©ter</div>
                    </div>
                </div>
            </div>

            <!-- Guide Tab -->
            <div id="guide" role="tabpanel" class="tab-content">
                <div class="card">
                    <h2 data-lang="guideTitle">üìò Professional User Guide</h2>
                    <div class="guide-content" style="font-size: 1.1rem; line-height: 1.8; color: #cbd5e1;">
                        <h3 data-lang="guideApiConfigTitle">1. API Configuration</h3>
                        <p data-lang="guideApiConfigText">Enter your valid OpenAI key in the üîß API Settings tab, then click the Test API Connection button. You can proceed once the connection is successful.</p>
                        <div style="background: #1e293b; padding: 1rem; border-radius: 8px; margin: 1rem 0; border-left: 4px solid #8b5cf6;">
                            <h4 style="color: #8b5cf6; margin: 0 0 0.5rem 0;" data-lang="guideApiKeySources">üîë API Key Sources:</h4>
                            <ul style="margin: 0; padding-left: 1.5rem;">
                                <li><strong>OpenAI API Key:</strong> <a href="https://platform.openai.com/api-keys" target="_blank" style="color: #60a5fa;">https://platform.openai.com/api-keys</a></li>
                                <li><strong>Perplexity API Key:</strong> <a href="https://www.perplexity.ai/account/api/keys" target="_blank" style="color: #60a5fa;">https://www.perplexity.ai/account/api/keys</a></li>
                                <li><strong>ChatGPT API Key:</strong> <a href="https://platform.openai.com/api-keys" target="_blank" style="color: #60a5fa;">https://platform.openai.com/api-keys</a></li>
                                <li><strong>Google Gemini API Key:</strong> <a href="https://makersuite.google.com/app/apikey" target="_blank" style="color: #60a5fa;">https://makersuite.google.com/app/apikey</a></li>
                                <li><strong>DeepSeek API Key:</strong> <a href="https://platform.deepseek.com/api_keys" target="_blank" style="color: #60a5fa;">https://platform.deepseek.com/api_keys</a></li>
                            </ul>
                        </div>
                        
                        <div style="background: #065f46; padding: 1rem; border-radius: 8px; margin: 1rem 0; border-left: 4px solid #10b981;">
                            <h4 style="color: #10b981; margin: 0 0 0.5rem 0;" data-lang="guideAutoAnalysisTitle">ü§ñ Automatic Analysis Feature:</h4>
                            <p style="margin: 0; color: #d1fae5;" data-lang="guideAutoAnalysisText">If you configure the Perplexity API key, the system will automatically perform comprehensive data analysis after image processing. This eliminates the need for manual prompt copying and JSON pasting - the entire analysis process becomes fully automated!</p>
                        </div>

                        <h3 data-lang="guideImageUploadTitle">2. Image Upload</h3>
                        <p data-lang="guideImageUploadText">On the üì∏ Image Collection tab, drag in or select screenshots from bookmaker and statistical pages. The system recognizes multiple sports and markets. Tip: You can paste images directly from the clipboard using Ctrl+V.</p>

                        <h3 data-lang="guideInitialAnalysisTitle">3. Initial AI Analysis</h3>
                        <p data-lang="guideInitialAnalysisText">Once at least one image is available, start the üöÄ Initial GPT-4o Analysis process. Image status (Waiting / Analyzing / Complete) updates in real-time.</p>

                        <h3 data-lang="guideDataRetrievalTitle">4. Data Retrieval Prompt</h3>
                        <p data-lang="guideDataRetrievalText">After the initial analysis, a combined prompt will appear in the üîç Analysis & Data Processing tab. Copy this and run it in a large language model (e.g., ChatGPT).</p>

                        <h3 data-lang="guideDataProcessingTitle">5. Data Processing</h3>
                        <p data-lang="guideDataProcessingText">Paste the full JSON response from the language model into the text area in the üîç Analysis & Data Processing tab, then click the üîÑ Process All Data button. This performs all calculations.</p>

                        <h3 data-lang="guideResultsTitle">6. Review Results</h3>
                        <p data-lang="guideResultsText">The recommendations appear in the üíé Results tab. The system generates optimal single bets and high-value parlay combinations based on the selected strategy.</p>

                        <h3 data-lang="guideMathTitle">7. Understand the Math</h3>
                        <p data-lang="guideMathText">The üìê Math tab explains all the formulas used, from calculating expected value (EV) to the Kelly criterion for staking. This ensures full transparency.</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Enhanced Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay hidden">
        <div class="loading-content">
            <div class="spinner"></div>
            <h3 style="color: #8b5cf6;" id="loadingTitle">GPT-4o Vision Analysis</h3>
            <p style="color: #94a3b8;" id="loadingMessage">Processing images...</p>
            
            <!-- Progress Bar -->
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-percentage" id="progressPercentage">0%</div>
                <div class="progress-text" id="progressText">Initializing...</div>
            </div>
            
            <!-- Loading Steps -->
            <div class="loading-details">
                <div class="loading-step" id="step1">üîç Analyzing images</div>
                <div class="loading-step" id="step2">ü§ñ Processing with AI</div>
                <div class="loading-step" id="step3">üìä Extracting data</div>
                <div class="loading-step" id="step4">üßÆ Calculating probabilities</div>
                <div class="loading-step" id="step5">‚úÖ Finalizing results</div>
            </div>
        </div>
    </div>
    
    <!-- Custom Modal -->
    <div id="customModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
        <div class="modal-content">
            <h2 id="modalTitle" style="color: #8b5cf6; margin-bottom: 1rem;">Confirmation</h2>
            <p id="modalMessage" style="color: #94a3b8; margin-bottom: 2rem;">Are you sure you want to delete all images?</p>
            <div style="display: flex; justify-content: center; gap: 1rem;">
                <button id="modalConfirmBtn" class="btn btn-danger">Delete</button>
                <button id="modalCancelBtn" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Language Pack Module -->
    <script src="src/utils/languagePack.js"></script>

    <script>
        // --- CONSTANTS AND CONFIGURATION --- //
        const CONSTANTS = {
            LOCAL_STORAGE_KEY: 'sportsAI_appState_v2',
            API_URL: 'https://api.openai.com/v1/chat/completions',
            API_MODEL: 'gpt-4o',
        };

        // --- LANGUAGE PACK MODULE --- //
        // Language pack is now handled by the external module (src/utils/languagePack.js)

        const SportConfigs = {
            football: { name: 'Football', icon: '‚öΩ', dataNeeded: ['team form (last 5 matches)', 'head-to-head', 'injuries/suspensions', 'home/away performance', 'expected goals (xG)'], models: ['Poisson', 'Dixon-Coles', 'xG'] },
            soccer: { name: 'Football', icon: '‚öΩ', dataNeeded: ['team form (last 5 matches)', 'head-to-head', 'injuries/suspensions', 'home/away performance', 'expected goals (xG)'], models: ['Poisson', 'Dixon-Coles', 'xG'] }, // Alias
            tennis: { name: 'Tennis', icon: 'üéæ', dataNeeded: ['Elo rating', 'surface-specific performance', 'serve/return %', 'head-to-head', 'physical condition', 'break point conversion'], models: ['Elo Rating', 'Surface analysis'] },
            basketball: { name: 'Basketball', icon: 'üèÄ', dataNeeded: ['pace', 'offensive/defensive efficiency', 'injury report', 'home/away splits', 'back-to-back effect'], models: ['Pace-adjusted efficiency', 'Four Factors'] },
            hockey: { name: 'Hockey', icon: 'üèí', dataNeeded: ['Corsi/Fenwick', 'goalie form', 'power play/penalty kill %', 'shot quality', 'rest days'], models: ['Advanced analytics (Corsi)', 'Goaltender analysis'] },
            baseball: { name: 'Baseball', icon: '‚öæ', dataNeeded: ['season runs scored/allowed', 'starting pitchers FIP/ERA', 'bullpen WAR', 'park factor', 'weather impact'], models: ['Pythagorean expectation', 'Log5', 'Run distribution'] },
            americanfootball: { name: 'American Football', icon: 'üèà', dataNeeded: ['offensive/defensive yards per play', 'turnover differential', 'red zone efficiency', 'strength of schedule'], models: ['EPA model', 'DVOA', 'Point spread model'] },
            unknown: { name: 'Unknown', icon: '‚ùì', dataNeeded: [], models: [] },
            other: { name: 'Other Sport', icon: 'üèÜ', dataNeeded: [], models: [] }
        };
        
        // --- APPLICATION STATE --- //
        const AppState = {
            apiKey: '',
            apiConnected: false,
            uploadedImages: [], // { id, dataUrl, name, size, sport, status, analysisResult, error }
            analyzedData: {},   // { sportBreakdown }
            retrievedData: null,
            portfolio: {
                singles: [],
                parlays: []
            },
            persistentData: {
                extractedMatches: [], // Persistent match data
                extractedOdds: [],    // Persistent odds data
                lastUpdated: null
            },
            perplexitySearchResults: [] // Store Perplexity AI search results
        };

        // --- DOM ELEMENT SELECTORS --- //
        const DOM = {
            apiKeyInput: document.getElementById('apiKey'),
            testApiBtn: document.getElementById('testApiBtn'),
            apiStatus: document.getElementById('apiStatus'),
            fileInput: document.getElementById('fileInput'),
            uploadArea: document.getElementById('uploadArea'),
            imagesContainer: document.getElementById('imagesContainer'),
            startAnalysisBtn: document.getElementById('startAnalysisBtn'),
            deleteAllBtn: document.getElementById('deleteAllBtn'),
            analysisResultsContainer: document.getElementById('analysisResultsContainer'),
            dataProcessingContainer: document.getElementById('dataProcessingContainer'),
            retrievedDataInput: document.getElementById('retrievedData'),
            processDataBtn: document.getElementById('processDataBtn'),
            portfolioSummary: document.getElementById('portfolioSummary'),
            resultsContainer: document.getElementById('resultsContainer'),
            noResults: document.getElementById('noResults'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            loadingTitle: document.getElementById('loadingTitle'),
            loadingMessage: document.getElementById('loadingMessage'),
            customModal: document.getElementById('customModal'),
            modalMessage: document.getElementById('modalMessage'),
            modalConfirmBtn: document.getElementById('modalConfirmBtn'),
            modalCancelBtn: document.getElementById('modalCancelBtn'),
        };

        // --- LANGUAGE MANAGEMENT --- //
        // Language functions using the external module
        function setLanguage(lang) {
            window.languagePack.applyLanguage(lang);
            updateLanguageUI();
            updateDynamicContent();

            // Re-render uploaded images
            UIManager.displayUploadedImages();

            // Re-process analysis results if exist
            if (AppState.analyzedData && AppState.analyzedData.sportBreakdown) {
                processAndDisplayAnalysisResults();
            }

            // Re-display portfolio if exists
            if (AppState.portfolio && (AppState.portfolio.singles.length || AppState.portfolio.parlays.length)) {
                displaySummary(AppState.portfolio);
                displayRecommendations(AppState.portfolio);
            }

            // Update all static elements
            document.querySelectorAll('[data-lang]').forEach(element => {
                const key = element.getAttribute('data-lang');
                element.textContent = getText(key);
            });

            document.querySelectorAll('[data-lang-placeholder]').forEach(element => {
                const key = element.getAttribute('data-lang-placeholder');
                element.setAttribute('placeholder', getText(key));
            });

            // Re-render MathJax after language change
            setTimeout(renderAllMath, 100);
        }
        
        function updateLanguageUI() {
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.lang === window.languagePack.getCurrentLanguage());
            });
        }
        
        function updateDynamicContent() {
            // Update loading messages
            const loadingTitle = document.getElementById('loadingTitle');
            const loadingMessage = document.getElementById('loadingMessage');
            if (loadingTitle) loadingTitle.textContent = getText('loadingTitle');
            if (loadingMessage) loadingMessage.textContent = getText('loadingMessage');
            
            // Update modal content
            const modalTitle = document.getElementById('modalTitle');
            const modalMessage = document.getElementById('modalMessage');
            const modalConfirmBtn = document.getElementById('modalConfirmBtn');
            const modalCancelBtn = document.getElementById('modalCancelBtn');
            
            if (modalTitle) modalTitle.textContent = getText('modalTitle');
            if (modalMessage) modalMessage.textContent = getText('modalDeleteAllImages');
            if (modalConfirmBtn) modalConfirmBtn.textContent = getText('modalDeleteButton');
            if (modalCancelBtn) modalCancelBtn.textContent = getText('modalCancelButton');
        }
        
        function getText(key) {
            return window.languagePack.getText(key);
        }

        // Update status text generation
        function getStatusText(status) {
            const statusMap = {
                'pending': 'statusWaiting',
                'analyzing': 'statusAnalyzing', 
                'completed': 'statusComplete',
                'error': 'statusError'
            };
            return getText(statusMap[status] || 'statusUnknown');
        }

        function getErrorText(error) {
            return getText('errorMessage').replace('{error}', error || getText('unknownError'));
        }

        // Update notification messages
        function showLocalizedNotification(messageKey, type = 'info', replacements = {}) {
            let message = getText(messageKey);
            Object.entries(replacements).forEach(([key, value]) => {
                message = message.replace(`{${key}}`, value);
            });
            UIManager.showNotification(message, type);
        }
        
        function showLocalizedLoading(titleKey, messageKey, replacements = {}) {
            let title = getText(titleKey);
            let message = getText(messageKey);
            Object.entries(replacements).forEach(([key, value]) => {
                title = title.replace(`{${key}}`, value);
                message = message.replace(`{${key}}`, value);
            });
            UIManager.showLoading(title, message);
        }
        
        function setLocalizedLoadingMessage(messageKey, replacements = {}) {
            let message = getText(messageKey);
            Object.entries(replacements).forEach(([key, value]) => {
                message = message.replace(`{${key}}`, value);
            });
            UIManager.setLoadingMessage(message);
        }

        // --- INITIALIZATION --- //
        document.addEventListener('DOMContentLoaded', () => {
            initializeEventListeners();
            loadStateFromLocalStorage();
            // Language pack is initialized automatically when the module loads
            updateLanguageUI();
            updateDynamicContent();
            initializeInputModes();
            console.log('üéØ Advanced Sports Betting Analyzer v2.0 initialized');
            
            // Ensure MathJax renders on page load
            if (window.MathJax) {
                MathJax.startup.defaultReady();
                // Re-render MathJax when switching to math tab
                setTimeout(() => {
                    if (window.MathJax && window.MathJax.typesetPromise) {
                        MathJax.typesetPromise().catch((e) => console.log('MathJax render error:', e));
                    }
                }, 500);
            }
        });

        function initializeEventListeners() {
            document.querySelectorAll('.nav-tab').forEach(tab => tab.addEventListener('click', (e) => switchTabAndRenderMath(e.currentTarget.dataset.tab)));
            
            // Language selector
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    setLanguage(e.currentTarget.dataset.lang);
                });
            });
            
            DOM.fileInput.addEventListener('change', handleFileSelect);
            DOM.uploadArea.addEventListener('click', () => DOM.fileInput.click());
            ['dragover', 'dragleave', 'drop'].forEach(eventName => {
                DOM.uploadArea.addEventListener(eventName, handleDragDrop);
            });
            
            document.addEventListener('paste', handlePaste);
            DOM.apiKeyInput.addEventListener('input', validateApiKey);
            DOM.retrievedDataInput.addEventListener('input', () => {
                DOM.processDataBtn.disabled = DOM.retrievedDataInput.value.trim() === '';
            });

            DOM.modalCancelBtn.addEventListener('click', () => UIManager.hideModal());
        }
        
        // --- STATE MANAGEMENT --- //
        function saveStateToLocalStorage() {
            try {
                const stateToSave = {
                    apiKey: AppState.apiKey,
                    // Only save essential data, not the full dataUrl to save space
                    uploadedImages: AppState.uploadedImages.map(({ id, name, size, sport, status, analysisResult, error }) => ({
                        id, name, size, sport, status, analysisResult, error
                    }))
                };
                // Note: dataUrl is not saved to prevent massive localStorage usage.
                // The app will not be able to restore images on reload, which is a reasonable trade-off.
                localStorage.setItem(CONSTANTS.LOCAL_STORAGE_KEY, JSON.stringify(stateToSave));
            } catch (e) {
                console.error(getText('errorSaving'), e);
                showLocalizedNotification('notificationDataSaveError', 'error');
            }
        }

        function loadStateFromLocalStorage() {
            const savedStateJSON = localStorage.getItem(CONSTANTS.LOCAL_STORAGE_KEY);
            if (savedStateJSON) {
                try {
                    const savedState = JSON.parse(savedStateJSON);
                    if (savedState.apiKey) {
                        DOM.apiKeyInput.value = savedState.apiKey;
                        validateApiKey();
                        testApiConnection();
                    }
                    // Images are not reloaded from state to save storage space.
                    // The user will start with a clean slate of images on each session.
                } catch (e) {
                    console.error(getText('errorLoading'), e);
                    localStorage.removeItem(CONSTANTS.LOCAL_STORAGE_KEY); // Clear corrupted data
                }
            }
        }
        
        // --- UI MANAGER MODULE --- //
        const UIManager = {
            switchTab(tabName) {
                document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.nav-tab').forEach(tab => {
                    const isCurrent = tab.dataset.tab === tabName;
                    tab.classList.toggle('active', isCurrent);
                    tab.setAttribute('aria-selected', isCurrent);
                });
                document.getElementById(tabName).classList.add('active');
            },
            
            showLoading(title, message, steps = []) {
                DOM.loadingTitle.textContent = title;
                DOM.loadingMessage.textContent = message;
                
                // Initialize progress
                this.currentProgress = 0;
                this.loadingSteps = steps.length > 0 ? steps : [
                    getText('loadingStep1') || 'üîç Analyzing images',
                    getText('loadingStep2') || 'ü§ñ Processing with AI', 
                    getText('loadingStep3') || 'üìä Extracting data',
                    getText('loadingStep4') || 'üßÆ Calculating probabilities',
                    getText('loadingStep5') || '‚úÖ Finalizing results'
                ];
                
                this.updateProgress(0, getText('loadingInitializing') || 'Initializing...');
                this.resetLoadingSteps();
                
                DOM.loadingOverlay.classList.remove('hidden');
            },

            setLoadingMessage(message) {
                DOM.loadingMessage.textContent = message;
            },

            updateProgress(percentage, statusText = '') {
                this.currentProgress = Math.max(0, Math.min(100, percentage));
                
                const progressFill = document.getElementById('progressFill');
                const progressPercentage = document.getElementById('progressPercentage');
                const progressText = document.getElementById('progressText');
                
                if (progressFill) {
                    progressFill.style.width = `${this.currentProgress}%`;
                }
                
                if (progressPercentage) {
                    progressPercentage.textContent = `${Math.round(this.currentProgress)}%`;
                }
                
                if (progressText && statusText) {
                    progressText.textContent = statusText;
                }
                
                // Update step status based on progress
                this.updateStepStatus();
            },

            updateStepStatus() {
                const steps = document.querySelectorAll('.loading-step');
                const stepProgress = this.currentProgress / 100 * steps.length;
                
                steps.forEach((step, index) => {
                    step.classList.remove('active', 'completed');
                    
                    if (index < Math.floor(stepProgress)) {
                        step.classList.add('completed');
                    } else if (index === Math.floor(stepProgress)) {
                        step.classList.add('active');
                    }
                });
            },

            resetLoadingSteps() {
                const steps = document.querySelectorAll('.loading-step');
                steps.forEach((step, index) => {
                    step.classList.remove('active', 'completed');
                    if (this.loadingSteps && this.loadingSteps[index]) {
                        step.textContent = this.loadingSteps[index];
                    }
                });
            },

            setLoadingStep(stepIndex, completed = false) {
                const steps = document.querySelectorAll('.loading-step');
                if (steps[stepIndex]) {
                    steps[stepIndex].classList.remove('active', 'completed');
                    if (completed) {
                        steps[stepIndex].classList.add('completed');
                    } else {
                        steps[stepIndex].classList.add('active');
                    }
                }
            },

            hideLoading() {
                DOM.loadingOverlay.classList.add('hidden');
                
                // Reset progress
                this.currentProgress = 0;
                this.updateProgress(0, '');
                this.resetLoadingSteps();
            },

            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `alert alert-${type}`;
                notification.setAttribute('role', type === 'error' ? 'alert' : 'status');
                notification.style.cssText = `position: fixed; top: 20px; right: 20px; z-index: 1001; min-width: 300px; animation: slideIn 0.3s ease;`;
                const icon = type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : '‚ÑπÔ∏è';
                notification.innerHTML = `<span>${icon}</span><span>${message}</span>`;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease forwards';
                    setTimeout(() => notification.remove(), 300);
                }, 5000);
            },
            
            showModal(message, onConfirm) {
                DOM.modalMessage.textContent = message;
                DOM.customModal.classList.remove('hidden');
                
                // Clone and replace the button to remove old event listeners
                const newConfirmBtn = DOM.modalConfirmBtn.cloneNode(true);
                DOM.modalConfirmBtn.parentNode.replaceChild(newConfirmBtn, DOM.modalConfirmBtn);
                DOM.modalConfirmBtn = newConfirmBtn;
                
                DOM.modalConfirmBtn.onclick = () => {
                    onConfirm();
                    this.hideModal();
                };
            },

            hideModal() {
                DOM.customModal.classList.add('hidden');
            },

            updateActionButtons() {
                const hasImages = AppState.uploadedImages.length > 0;
                DOM.startAnalysisBtn.disabled = !AppState.apiConnected || !hasImages;
                DOM.deleteAllBtn.disabled = !hasImages;
            },
            
            displayUploadedImages() {
                DOM.imagesContainer.innerHTML = AppState.uploadedImages.map((image, index) => {
                    const sportInfo = SportConfigs[image.sport] || SportConfigs.unknown;
                    const statusText = getStatusText(image.status);
                    const errorTooltip = image.status === 'error' ? `title="${getErrorText(image.error)}"` : '';

                    return `
                        <div class="image-item" id="image-${image.id}">
                            <img src="${image.dataUrl}" alt="${image.name}">
                            <div class="sport-badge sport-${image.sport}">${sportInfo.icon} ${sportInfo.name}</div>
                            <div class="analysis-status status-${image.status}" ${errorTooltip}>${statusText}</div>
                            <div class="image-overlay-content">
                                <div style="font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${image.name}</div>
                                <div>${getText('sizeLabel')}: ${(image.size / 1024).toFixed(1)} KB</div>
                            </div>
                            <button onclick="removeImage(${index})" aria-label="${getText('deleteImageLabel')}" style="position: absolute; top: 40px; right: 10px; background: rgba(239, 68, 68, 0.8); border: none; border-radius: 50%; width: 30px; height: 30px; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center;">‚ùå</button>
                        </div>
                    `;
                }).join('');
            },
            
            updateImageDisplay(image) {
                const element = document.getElementById(`image-${image.id}`);
                if (!element) return;
                
                const sportInfo = SportConfigs[image.sport] || SportConfigs.unknown;
                const statusText = getStatusText(image.status);
                
                element.querySelector('.sport-badge').className = `sport-badge sport-${image.sport}`;
                element.querySelector('.sport-badge').innerHTML = `${sportInfo.icon} ${sportInfo.name}`;
                
                const statusElement = element.querySelector('.analysis-status');
                statusElement.className = `analysis-status status-${image.status}`;
                statusElement.textContent = statusText;
                if (image.status === 'error') {
                    statusElement.title = getErrorText(image.error);
                    statusElement.style.cursor = 'help';
                } else {
                    statusElement.title = '';
                    statusElement.style.cursor = 'default';
                }
            }
        };

        const style = document.createElement('style');
        style.textContent = `@keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } } @keyframes slideOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }`;
        document.head.appendChild(style);

        // --- API SERVICE MODULE --- //
        const ApiService = {
            async testConnection(apiKey) {
                const response = await fetch(CONSTANTS.API_URL.replace('chat/completions', 'models'), { headers: { 'Authorization': `Bearer ${apiKey}` } });
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || `HTTP ${response.status}`);
                }
                return true;
            },

            async analyzeImage(image, apiKey) {
                const prompt = `Analyze this sports betting image and return the response in the following JSON format. Be precise and detailed. Use standardized keys.

IMPORTANT: Detect ALL sports types including:
- football (soccer) - European football/soccer 
- tennis - individual tennis matches
- basketball - NBA, European leagues, etc. 
- hockey - NHL, European hockey leagues  
- baseball - MLB, etc.
- americanfootball - NFL, college football
- other - any other sport

{
  "sport_type": "football|tennis|basketball|hockey|baseball|americanfootball|other",
  "matches_detected": [
    { "home_team": "Team/Player name", "away_team": "Team/Player name", "league": "League name or null" }
  ],
  "odds_found": [
    { "market_type": "match_result|total_goals_over_under|total_points_over_under|corners|cards|handicap", "market_specifier": "2.5|null", "values": { "Home": 1.90, "Draw": 3.20, "Away": 4.10 }, "applies_to_match_index": 0 }
  ],
  "bookmaker": "Bookmaker name or null"
}

For tennis matches, use "1" and "2" instead of "Home" and "Away".
For basketball/hockey, detect total points/goals markets.
For football, also detect corners, cards, and handicap markets.`;
                const response = await fetch(CONSTANTS.API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                    body: JSON.stringify({
                        model: CONSTANTS.API_MODEL,
                        messages: [{
                            role: 'user',
                            content: [
                                { type: 'text', text: prompt },
                                { type: 'image_url', image_url: { url: image.dataUrl, detail: 'high' } }
                            ]
                        }],
                        response_format: { type: "json_object" }
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || `HTTP ${response.status}`);
                }

                const data = await response.json();
                return JSON.parse(data.choices[0].message.content);
            }
        };

        // --- EVENT HANDLERS --- //
        function handleFileSelect(event) { processFiles(Array.from(event.target.files)); }
        
        function handleDragDrop(event) {
            event.preventDefault();
            const area = event.currentTarget;
            if (event.type === 'dragover') {
                area.classList.add('drag-over');
            } else if (event.type === 'dragleave') {
                area.classList.remove('drag-over');
            } else if (event.type === 'drop') {
                area.classList.remove('drag-over');
                processFiles(Array.from(event.dataTransfer.files));
            }
        }

        function handlePaste(event) {
            const files = Array.from(event.clipboardData.files).filter(file => file.type.startsWith('image/'));
            if (files.length > 0) {
                processFiles(files);
                showLocalizedNotification('notificationImagesFromClipboard', 'success', { count: files.length });
            }
        }

        // --- CORE LOGIC --- //
        function validateApiKey() {
            const apiKey = DOM.apiKeyInput.value.trim();
            const isValid = apiKey.startsWith('sk-') && apiKey.length > 20;
            DOM.testApiBtn.disabled = !isValid;
            if (isValid) {
                AppState.apiKey = apiKey;
            }
        }

        async function testApiConnection() {
            DOM.testApiBtn.disabled = true;
            DOM.testApiBtn.innerHTML = `üîÑ ${getText('testingInProgress')}`;
            DOM.apiStatus.className = 'alert alert-info';
            DOM.apiStatus.innerHTML = `<span>üîÑ</span><span>${getText('testingApiConnection')}</span>`;
            DOM.apiStatus.classList.remove('hidden');

            try {
                await ApiService.testConnection(AppState.apiKey);
                AppState.apiConnected = true;
                DOM.apiStatus.className = 'alert alert-success';
                DOM.apiStatus.innerHTML = `<span>‚úÖ</span><span>${getText('apiConnectionSuccess')}</span>`;
                UIManager.updateActionButtons();
                saveStateToLocalStorage();
            } catch (error) {
                AppState.apiConnected = false;
                DOM.apiStatus.className = 'alert alert-error';
                DOM.apiStatus.innerHTML = `<span>‚ùå</span><span>${getText('apiConnectionFailed')}: ${error.message}</span>`;
            } finally {
                DOM.testApiBtn.disabled = false;
                DOM.testApiBtn.innerHTML = `üîç ${getText('testApiButton')}`;
            }
        }

        function processFiles(files) {
            if (!AppState.apiConnected) {
                showLocalizedNotification('notificationSetupApiFirst', 'warning');
                UIManager.switchTab('setup');
                return;
            }

            files.filter(file => file.type.startsWith('image/')).forEach(file => {
                const reader = new FileReader();
                reader.onload = e => {
                    AppState.uploadedImages.push({
                        id: Date.now() + Math.random(),
                        dataUrl: e.target.result,
                        name: file.name,
                        size: file.size,
                        sport: 'unknown',
                        status: 'pending',
                        analysisResult: null,
                        error: null
                    });
                    UIManager.displayUploadedImages();
                    UIManager.updateActionButtons();
                };
                reader.readAsDataURL(file);
            });
        }
        
        function removeImage(index) {
            AppState.uploadedImages.splice(index, 1);
            UIManager.displayUploadedImages();
            UIManager.updateActionButtons();
        }

        function confirmDeleteImages() {
            UIManager.showModal(getText('modalDeleteImages'), () => {
                AppState.uploadedImages = [];
                UIManager.displayUploadedImages();
                UIManager.updateActionButtons();
                showLocalizedNotification('notificationImagesDeleted', 'info');
            });
        }
        
        function confirmClearAllData() {
            UIManager.showModal(getText('modalClearAllData'), () => {
                AppState.uploadedImages = [];
                AppState.analyzedData = {};
                AppState.retrievedData = null;
                AppState.portfolio = { singles: [], parlays: [] };
                AppState.persistentData = { extractedMatches: [], extractedOdds: [], lastUpdated: null };
                
                // Clear UI
                UIManager.displayUploadedImages();
                UIManager.updateActionButtons();
                DOM.analysisResultsContainer.innerHTML = '<div class="alert alert-info"><span>üìä</span><span data-lang="analysisInfo">' + getText('analysisInfo') + '</span></div>';
                DOM.dataProcessingContainer.classList.add('hidden');
                DOM.portfolioSummary.classList.add('hidden');
                DOM.resultsContainer.classList.add('hidden');
                DOM.noResults.classList.remove('hidden');
                DOM.retrievedDataInput.value = '';
                
                showLocalizedNotification('notificationAllDataCleared', 'info');
                saveStateToLocalStorage();
            });
        }

        async function startInitialAnalysis() {
            const customSteps = [
                getText('loadingStep1') || 'üîç Analyzing images',
                getText('loadingStep2') || 'ü§ñ Processing with AI',
                getText('loadingStep3') || 'üìä Extracting data',
                getText('loadingStep4') || 'üßÆ Calculating probabilities',
                getText('loadingStep5') || '‚úÖ Finalizing results'
            ];
            
            UIManager.showLoading(getText('loadingInitialAnalysis'), getText('loadingMultiSportAnalysis'), customSteps);
            
            const totalImages = AppState.uploadedImages.length;
            let completedImages = 0;
            
            const analysisPromises = AppState.uploadedImages.map(async (image, index) => {
                if (image.status === 'completed') {
                    completedImages++;
                    return;
                }
                
                try {
                    image.status = 'analyzing';
                    image.error = null;
                    UIManager.updateImageDisplay(image);
                    
                    // Update progress based on current image
                    const baseProgress = (completedImages / totalImages) * 80; // 80% for analysis
                    UIManager.updateProgress(baseProgress, getText('loadingAnalyzing') || 'Analyzing images...');
                    
                    const result = await ApiService.analyzeImage(image, AppState.apiKey);
                    image.analysisResult = result;
                    image.sport = (result?.sport_type || 'unknown').trim().toLowerCase();
                    image.status = 'completed';
                    
                    completedImages++;
                    const newProgress = (completedImages / totalImages) * 80;
                    UIManager.updateProgress(newProgress, `${getText('loadingAnalyzing') || 'Analyzing images...'} (${completedImages}/${totalImages})`);
                    
                } catch (error) {
                    console.error(`Error analyzing image ${image.name}:`, error);
                    image.status = 'error';
                    image.error = error.message;
                    completedImages++;
                } finally {
                    UIManager.updateImageDisplay(image);
                }
            });

            await Promise.all(analysisPromises);
            
            // Processing results phase
            UIManager.updateProgress(85, getText('loadingProcessing') || 'Processing with AI...');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            UIManager.updateProgress(90, getText('loadingExtracting') || 'Extracting data...');
            processAndDisplayAnalysisResults();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            UIManager.updateProgress(95, getText('loadingCalculating') || 'Calculating probabilities...');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            UIManager.updateProgress(100, getText('loadingFinalizing') || 'Finalizing results...');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            UIManager.hideLoading();
            showLocalizedNotification('notificationInitialAnalysisComplete', 'success');
            UIManager.switchTab('analysis');
            
            // Check if post-analysis automatic data search is enabled
            await checkPostAnalysisAutoSearch();
        }
        
        // Check and execute post-analysis automatic data search
        async function checkPostAnalysisAutoSearch() {
            const postAnalysisSearchEnabled = document.getElementById('enablePostAnalysisSearch').checked;
            const selectedAiModel = document.getElementById('aiModel').value;
            const aiApiKey = document.getElementById('aiApiKey').value.trim();
            
            if (postAnalysisSearchEnabled && selectedAiModel === 'perplexity' && aiApiKey) {
                console.log('üöÄ Starting post-analysis automatic comprehensive data search...');
                
                // Show loading message
                showLocalizedLoading('postAnalysisSearch', 'postAnalysisSearchDescription');
                
                try {
                    // Perform comprehensive data search
                    const searchResults = await performComprehensiveDataSearch(aiApiKey);
                    
                    // Automatically fill the retrieved data field
                    DOM.retrievedDataInput.value = searchResults;
                    DOM.processDataBtn.disabled = false;
                    
                    showLocalizedNotification('notificationPostAnalysisSearchComplete', 'success');
                    
                    // Optionally auto-process the data after a short delay
                    setTimeout(() => {
                        processAllRetrievedData();
                    }, 2000);
                    
                } catch (error) {
                    console.error('Post-analysis search error:', error);
                    showLocalizedNotification('notificationPostAnalysisSearchError', 'error', { error: error.message });
                } finally {
                    UIManager.hideLoading();
                }
            }
        }
        
        // Perform comprehensive data search for all mathematical formulas
        async function performComprehensiveDataSearch(apiKey) {
            console.log('üîç Starting comprehensive data search for all mathematical formulas...');
            
            // Extract matches from uploaded images
            const allMatches = [];
            AppState.uploadedImages.forEach(image => {
                if (image.analysisResult && image.analysisResult.matches_detected) {
                    image.analysisResult.matches_detected.forEach(match => {
                        allMatches.push({
                            home_team: match.home_team,
                            away_team: match.away_team,
                            sport: image.sport || 'football',
                            league: match.league,
                            odds: match.odds || {}
                        });
                    });
                }
            });
            
            if (allMatches.length === 0) {
                throw new Error('No matches found for comprehensive data search');
            }
            
            console.log(`Found ${allMatches.length} matches for comprehensive data search`);
            
            // Group matches by sport (limit to prevent overwhelming)
            const matchesBySport = {};
            allMatches.forEach(match => {
                if (!matchesBySport[match.sport]) {
                    matchesBySport[match.sport] = [];
                }
                matchesBySport[match.sport].push(match);
            });
            
            // Limit to max 5 sports and 5 matches per sport
            const limitedSports = Object.keys(matchesBySport).slice(0, 5);
            const analyses = [];
            
            // Process each sport with comprehensive data search
            for (const sport of limitedSports) {
                const matches = matchesBySport[sport].slice(0, 5); // Max 5 matches per sport
                console.log(`üîç Comprehensive search for ${sport}: ${matches.length} matches`);
                
                const sportAnalysis = {
                    sport: sport,
                    matches: []
                };
                
                // Search comprehensive data for each match
                for (let i = 0; i < matches.length; i++) {
                    const match = matches[i];
                    console.log(`üîç Comprehensive search: ${match.home_team} vs ${match.away_team}`);
                    
                    try {
                        const matchData = await searchMatchDataComprehensive(match, apiKey);
                        sportAnalysis.matches.push(matchData);
                        
                        // Extended delay for comprehensive searches
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        
                    } catch (error) {
                        console.error(`Error in comprehensive search for ${match.home_team} vs ${match.away_team}:`, error);
                        
                        // Add enhanced fallback data
                        sportAnalysis.matches.push(createComprehensiveFallbackData(match));
                    }
                }
                
                analyses.push(sportAnalysis);
            }
            
            const result = { analyses };
            console.log('‚úÖ Comprehensive data search completed:', result);
            
            return JSON.stringify(result, null, 2);
        }
        
        // Create comprehensive fallback data when search fails
        function createComprehensiveFallbackData(match) {
            return {
                home_team: match.home_team,
                away_team: match.away_team,
                league: match.league || 'Unknown League',
                match_date: new Date().toISOString().split('T')[0],
                venue: {
                    name: 'Unknown Venue',
                    capacity: 50000,
                    surface_type: 'unknown',
                    venue_type: 'unknown',
                    altitude: 100,
                    weather_forecast: {
                        temperature: 15,
                        wind_speed: 5,
                        wind_direction: 'N',
                        precipitation_probability: 20,
                        humidity: 60
                    }
                },
                comprehensive_team_data: {
                    home_team: {
                        recent_form_detailed: [],
                        league_position: 'Unknown',
                        points: 0,
                        goals_for: 0,
                        goals_against: 0,
                        home_record: {"wins": 0, "draws": 0, "losses": 0},
                        away_record: {"wins": 0, "draws": 0, "losses": 0},
                        advanced_metrics: {
                            xG_per_game: 1.5,
                            xGA_per_game: 1.5,
                            possession_avg: 50,
                            shot_conversion_rate: 10,
                            defensive_actions_per_game: 40
                        }
                    },
                    away_team: {
                        recent_form_detailed: [],
                        league_position: 'Unknown',
                        points: 0,
                        goals_for: 0,
                        goals_against: 0,
                        home_record: {"wins": 0, "draws": 0, "losses": 0},
                        away_record: {"wins": 0, "draws": 0, "losses": 0},
                        advanced_metrics: {
                            xG_per_game: 1.5,
                            xGA_per_game: 1.5,
                            possession_avg: 50,
                            shot_conversion_rate: 10,
                            defensive_actions_per_game: 40
                        }
                    }
                },
                head_to_head_detailed: {
                    overall_wins_home: 0,
                    overall_wins_away: 0,
                    overall_draws: 0,
                    last_5_meetings: [],
                    goals_scored_home: 0,
                    goals_scored_away: 0,
                    average_goals_per_meeting: 2.5
                },
                injury_suspension_impact: {
                    home_team_missing: [],
                    away_team_missing: [],
                    total_impact_home: 0,
                    total_impact_away: 0
                },
                tactical_analysis: {
                    home_team_formation: 'Unknown',
                    away_team_formation: 'Unknown',
                    home_team_style: 'unknown',
                    away_team_style: 'unknown',
                    manager_impact: {
                        home_manager_experience: 5,
                        away_manager_experience: 5,
                        tactical_flexibility: 'medium'
                    }
                },
                psychological_factors: {
                    home_team_morale: 50,
                    away_team_morale: 50,
                    pressure_level: {
                        home_team: 50,
                        away_team: 50
                    },
                    fan_support_impact: 5,
                    media_coverage: 'normal'
                },
                betting_market_analysis: {
                    opening_odds: {"home": 2.0, "draw": 3.0, "away": 4.0},
                    current_odds: {"home": 2.0, "draw": 3.0, "away": 4.0},
                    odds_movement: 'stable',
                    betting_volume: 'medium',
                    sharp_money_indicator: 'neutral'
                },
                fair_odds_calculation: {
                    home_win_prob: 0.40,
                    draw_prob: 0.30,
                    away_win_prob: 0.30,
                    calculation_method: 'Fallback probabilities - comprehensive search failed',
                    confidence_level: 30
                },
                total_goals_analysis: {
                    expected_total_goals: 2.5,
                    over_2_5_prob: 0.50,
                    under_2_5_prob: 0.50,
                    over_1_5_prob: 0.75,
                    under_1_5_prob: 0.25,
                    btts_prob: 0.55
                },
                additional_markets: {
                    corners: {"expected": 10, "over_10_5": 0.45},
                    cards: {"expected": 4, "over_4_5": 0.40},
                    first_goal: {"home": 0.45, "away": 0.40}
                },
                reasoning: `Comprehensive fallback data for ${match.home_team} vs ${match.away_team}. Search failed or returned insufficient data. All values are neutral/baseline estimates.`,
                data_sources: ["Fallback System"],
                last_updated: new Date().toISOString()
            };
        }
        
        function processAndDisplayAnalysisResults() {
            const sportBreakdown = {};
            AppState.uploadedImages.forEach(image => {
                if (!image.analysisResult || image.status !== 'completed') return;
                
                const sport = image.sport;
                if (!sport || !SportConfigs[sport]) return;

                if (!sportBreakdown[sport]) {
                    sportBreakdown[sport] = { images: 0, matches: new Map() };
                }
                sportBreakdown[sport].images++;
                (image.analysisResult.matches_detected || []).forEach(match => {
                    const matchKey = `${match.home_team} vs ${match.away_team}`.toLowerCase();
                    if (!sportBreakdown[sport].matches.has(matchKey)) {
                        sportBreakdown[sport].matches.set(matchKey, match);
                    }
                });
            });
            AppState.analyzedData.sportBreakdown = sportBreakdown;

            DOM.analysisResultsContainer.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-card"><div class="stat-value">${AppState.uploadedImages.length}</div><div class="stat-label">${getText('uploadedImagesLabel')}</div></div>
                    <div class="stat-card"><div class="stat-value">${Object.keys(sportBreakdown).length}</div><div class="stat-label">${getText('recognizedSportsLabel')}</div></div>
                </div>
                ${generateCombinedPromptHTML()}
            `;
            
            DOM.dataProcessingContainer.classList.remove('hidden');
            
            // Check for automatic processing
            checkForAutomaticProcessing(sportBreakdown);
        }

        function generateCombinedPromptHTML() {
            const { sportBreakdown } = AppState.analyzedData;
            if (!sportBreakdown || Object.keys(sportBreakdown).length === 0) {
                return `<div class="alert alert-warning"><span>‚ö†Ô∏è</span><span>${getText('errorNoSportsDetected')}</span></div>`;
            }

            // MINDIG csak 1 nagy prompt - f√ºggetlen√ºl a meccsek sz√°m√°t√≥l
            const promptContent = generateSingleMasterPrompt(sportBreakdown);
            
            // Check if automatic processing is available
            const selectedAiModel = document.getElementById('aiModel').value;
            const aiApiKey = document.getElementById('aiApiKey').value.trim();
            const canAutoProcess = selectedAiModel !== 'none' && aiApiKey.length > 0;
            
            let autoProcessButton = '';
            if (canAutoProcess) {
                autoProcessButton = `
                    <button class="btn btn-primary" onclick="processPromptAutomatically()" style="margin-left: 1rem;">
                        ü§ñ ${getText('autoProcessButton')}
                    </button>
                `;
            }
            
            return `
                <div class="prompt-box">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <h3 style="color: #8b5cf6; margin: 0;">‚öôÔ∏è ${getText('promptTitle')}</h3>
                        <div>
                            <button class="copy-btn" onclick="copyToClipboard('combinedPromptContent')">üìã ${getText('promptCopyButton')}</button>
                            ${autoProcessButton}
                        </div>
                    </div>
                    <p style="color: #94a3b8; margin-bottom: 1rem;">${getText('promptDescription')}</p>
                    <pre id="combinedPromptContent" class="prompt-content" style="white-space: pre-wrap; word-wrap: break-word; max-height: 600px; overflow-y: auto;">${promptContent}</pre>
                </div>
            `;
        }

        function generateSingleMasterPrompt(sportBreakdown) {
            let combinedPrompt = '';
            
            // Sz√°moljuk √∂ssze az √∂sszes meccset
            let totalMatches = 0;
            let allSports = [];
            Object.entries(sportBreakdown).forEach(([sport, data]) => {
                if (data.matches && data.matches.size > 0) {
                    totalMatches += data.matches.size;
                    allSports.push(sport);
                }
            });
            
            // === PROFESSZION√ÅLIS FEJL√âC === //
            combinedPrompt += `# üéØ PROFESSZION√ÅLIS SPORTFOGAD√ÅSI ELEMZ√âS\n\n`;
            combinedPrompt += `Szia! Te egy vil√°gsz√≠nvonal√∫ sportfogad√°si elemz≈ë vagy. K√©rlek, v√©gezd el az al√°bbi ${totalMatches} meccs r√©szletes elemz√©s√©t kiz√°r√≥lag val√≥s, friss internetes adatok alapj√°n.\n\n`;
            combinedPrompt += `**FONTOS:** Te magad kell megkeresned az internetr≈ël minden sz√ºks√©ges adatot a megadott meccsek alapj√°n. Ne v√°rj tov√°bbi inform√°ci√≥t - haszn√°ld a csapatneveket/j√°t√©kosneveket √©s keress r√° minden relev√°ns adatra!\n\n`;
            
            // === ADATFORR√ÅSOK === //
            combinedPrompt += `## üåê ADATGY≈∞JT√âS - TE KERESED MEG!\n\n`;
            combinedPrompt += `**A te feladatod:** Minden meccshez keress ki az internetr≈ël az al√°bbi adatokat:\n`;
            combinedPrompt += `‚Ä¢ **Csapatnevek/j√°t√©kosnevek alapj√°n** keress r√° a legfrissebb inform√°ci√≥kra\n`;
            combinedPrompt += `‚Ä¢ **Haszn√°lhat√≥ forr√°sok:** ESPN, BBC Sport, hivatalos lig√°k, Wikipedia, transfermarkt\n`;
            combinedPrompt += `‚Ä¢ **Keres√©si m√≥dszer:** G√©peld be a csapat/j√°t√©kos neveket + "recent form" / "injuries" / "head to head"\n`;
            combinedPrompt += `‚Ä¢ **Ha nem tal√°lsz adatot:** √çrj "nincs adat" - ne tal√°lj ki semmit!\n`;
            combinedPrompt += `‚Ä¢ **Forr√°s megjel√∂l√©s:** "ESPN szerint" / "BBC Sport alapj√°n" / "logikus becsl√©s"\n\n`;
            
            // === KUTAT√ÅSI √öTMUTAT√ì === //
            combinedPrompt += `## üîç KONKR√âT KERES√âSI FELADATOK MECCSENK√âT\n\n`;
            combinedPrompt += `**MINDEN MECCSHEZ K√ñTELEZ≈êEN KERESS KI:**\n\n`;
            combinedPrompt += `### 1Ô∏è‚É£ ALAPADATOK (k√∂telez≈ë keres√©s)\n`;
            combinedPrompt += `‚Ä¢ **Csapatnevek ellen≈ërz√©se:** Keress r√° hogy helyesen √≠rtad-e\n`;
            combinedPrompt += `‚Ä¢ **Liga/bajnoks√°g:** Melyik lig√°ban j√°tszanak jelenleg\n`;
            combinedPrompt += `‚Ä¢ **Meccs d√°tuma:** Mikor lesz/volt a meccs\n`;
            combinedPrompt += `‚Ä¢ **Helysz√≠n:** Stadion/arena neve √©s t√≠pusa (indoor/outdoor)\n\n`;
            combinedPrompt += `### 2Ô∏è‚É£ FORMA ADATOK (keres√©s: "team name recent results")\n`;
            combinedPrompt += `‚Ä¢ **Utols√≥ 5 meccs:** Eredm√©nyek W-L-D form√°ban\n`;
            combinedPrompt += `‚Ä¢ **Hazai/vend√©g forma:** K√ºl√∂n keres√©s otthon √©s idegenben\n`;
            combinedPrompt += `‚Ä¢ **Liga poz√≠ci√≥:** Aktu√°lis tabellahely\n\n`;
            combinedPrompt += `### 3Ô∏è‚É£ EGYM√ÅS ELLENI M√âRLEG (keres√©s: "Team A vs Team B head to head")\n`;
            combinedPrompt += `‚Ä¢ **Utols√≥ tal√°lkoz√≥k:** Legut√≥bbi 3-5 meccs eredm√©nye\n`;
            combinedPrompt += `‚Ä¢ **√ñsszes√≠tett m√©rleg:** Ki vezet t√∂rt√©nelmileg\n\n`;
            combinedPrompt += `### 4Ô∏è‚É£ HI√ÅNYZ√ì J√ÅT√âKOSOK (keres√©s: "team name injuries suspensions")\n`;
            combinedPrompt += `‚Ä¢ **S√©r√ºltek list√°ja:** Nevek, poz√≠ci√≥k, visszat√©r√©s v√°rhat√≥ ideje\n`;
            combinedPrompt += `‚Ä¢ **Eltiltottak:** Lapok, fegyelmi √ºgyek\n`;
            combinedPrompt += `‚Ä¢ **Kulcsj√°t√©kosok:** Kik a legfontosabb hi√°nyz√≥k\n\n`;
            combinedPrompt += `### 5Ô∏è‚É£ ID≈êJ√ÅR√ÅS (csak szabadt√©ri sportok, keres√©s: "city name weather forecast")\n`;
            combinedPrompt += `‚Ä¢ **H≈ëm√©rs√©klet:** Celsius fokban\n`;
            combinedPrompt += `‚Ä¢ **Sz√©l:** Ir√°ny √©s sebess√©g\n`;
            combinedPrompt += `‚Ä¢ **Csapad√©k:** Es≈ë val√≥sz√≠n≈±s√©ge\n`;
            combinedPrompt += `‚Ä¢ **√Åltal√°nos k√∂r√ºlm√©nyek:** Naps√ºt√©s/felh≈ës/viharos\n\n`;
            combinedPrompt += `### 6Ô∏è‚É£ MOTIV√ÅCI√ì (keres√©s: "team name league position goals")\n`;
            combinedPrompt += `‚Ä¢ **Szezon c√©lok:** Bajnoks√°g/r√°j√°tsz√°s/kies√©s elker√ºl√©se\n`;
            combinedPrompt += `‚Ä¢ **Aktu√°lis helyzet:** Mennyire fontos a meccs\n`;
            combinedPrompt += `‚Ä¢ **Nyom√°s:** Van-e extra motiv√°ci√≥/nyom√°s\n\n`;
            combinedPrompt += `**FONTOS EML√âKEZTET≈ê:** Ha b√°rmelyik adatot nem tal√°lod meg 2-3 keres√©s ut√°n, √≠rj "nincs adat" √©s menj tov√°bb!\n\n`;
            
            // === MATEMATIKAI MODELLEK === //
            combinedPrompt += `## üßÆ ALKALMAZAND√ì MATEMATIKAI MODELLEK\n\n`;
            combinedPrompt += `Haszn√°ld ezeket a modelleket a val√≥sz√≠n≈±s√©gek kisz√°m√≠t√°s√°hoz:\n\n`;
            
            // Minden sport modellj√©t hozz√°adjuk
            allSports.forEach(sport => {
                combinedPrompt += generateDetailedSportModel(sport);
            });
            
            // === ELEMZEND≈ê MECCSEK === //
            combinedPrompt += `## üèÜ ELEMZEND≈ê MECCSEK (${totalMatches} DB)\n\n`;

            Object.entries(sportBreakdown).forEach(([sport, data]) => {
                if (data.matches && data.matches.size > 0) {
                    const config = SportConfigs[sport] || SportConfigs.unknown;
                    const matchesList = Array.from(data.matches.values()).map(m => `- ${m.home_team} vs ${m.away_team}`).join('\n');
                    combinedPrompt += `### ${config.icon} ${config.name.toUpperCase()}\n`;
                    combinedPrompt += `${matchesList}\n\n`;
                    
                    // Sport-specifikus k√∂vetelm√©nyek
                    combinedPrompt += generateEnhancedSportRequirements(sport);
                }
            });
            
            // === JSON V√ÅLASZ FORM√ÅTUM === //
            combinedPrompt += `## üìã V√ÅLASZ FORM√ÅTUM\n\n`;
            combinedPrompt += `**KRITIKUS K√ñVETELM√âNYEK:**\n`;
            combinedPrompt += `1. ‚úÖ Csak tiszta JSON objektumot k√ºldj vissza\n`;
            combinedPrompt += `2. ‚ùå Ne √≠rj semmit a JSON el√© vagy m√∂g√©\n`;
            combinedPrompt += `3. ‚ùå Ne haszn√°lj \`\`\`json vagy \`\`\` jel√∂l√©seket\n`;
            combinedPrompt += `4. ‚úÖ Minden adat val√≥s internetr≈ël sz√°rmazzon\n`;
            combinedPrompt += `5. ‚úÖ A reasoning mez≈ëben k√∂telez≈ë a forr√°s megad√°sa\n`;
            combinedPrompt += `6. ‚úÖ Minden meccshez t√∂ltsd ki az √∂sszes k√∂telez≈ë mez≈ët\n\n`;
            
            // === JSON P√âLDA === //
            combinedPrompt += `**JSON STRUKT√öRA P√âLDA:**\n`;
            combinedPrompt += `{\n  "analyses": [\n`;
            
            // Minden sporthoz gener√°lunk p√©ld√°t
            allSports.forEach((sport, index) => {
                combinedPrompt += generateComprehensiveJsonExample(sport);
                if (index < allSports.length - 1) {
                    combinedPrompt += `    },\n`;
                }
            });
            
            combinedPrompt += `  ]\n}\n\n`;
            
            // === V√âGS≈ê UTAS√çT√ÅSOK === //
            combinedPrompt += `## üöÄ V√âGS≈ê UTAS√çT√ÅSOK\n\n`;
            combinedPrompt += `**KERES√âSI FOLYAMAT:**\n\n`;
            combinedPrompt += `1. **KEZDJ EL KERESNI MOST!** Minden meccshez k√ºl√∂n-k√ºl√∂n keress adatokat\n`;
            combinedPrompt += `2. **Haszn√°ld a csapatneveket** keres≈ëszavakk√©nt az interneten\n`;
            combinedPrompt += `3. **2-3 keres√©s meccsenk√©t** - ha nincs adat, √≠rj "nincs adat"\n`;
            combinedPrompt += `4. **Reasoning mez≈ëben** √≠rd le milyen forr√°sb√≥l sz√°rmazik az adat\n`;
            combinedPrompt += `5. **Matematikai modelleket** alkalmazd a megtal√°lt adatokra\n`;
            combinedPrompt += `6. **50 (semleges) √©rt√©keket** haszn√°lj ahol nincs konkr√©t info\n`;
            combinedPrompt += `7. **Tiszta JSON** - semmi extra sz√∂veg el≈ëtte/ut√°na\n\n`;
            combinedPrompt += `**EML√âKEZTET≈ê:** Te vagy felel≈ës az adatok megkeres√©s√©rt! Ne v√°rj t√∂bbet - kezdj el keresni a csapatnevek alapj√°n!\n\n`;
            
            // === KERES√âSI P√âLDA === //
            combinedPrompt += `## üí° KERES√âSI P√âLDA\n\n`;
            combinedPrompt += `**Ha van egy "Manchester City vs Arsenal" meccs:**\n`;
            combinedPrompt += `1. Keres√©s: "Manchester City recent results 2024"\n`;
            combinedPrompt += `2. Keres√©s: "Arsenal recent results 2024"\n`;
            combinedPrompt += `3. Keres√©s: "Manchester City vs Arsenal head to head"\n`;
            combinedPrompt += `4. Keres√©s: "Manchester City injuries suspensions"\n`;
            combinedPrompt += `5. Keres√©s: "Arsenal injuries suspensions"\n`;
            combinedPrompt += `6. Keres√©s: "Manchester weather forecast" (ha szabadt√©ri)\n\n`;
            combinedPrompt += `**Reasoning p√©lda:** "ESPN szerint Man City utols√≥ 5: WWDWL, Arsenal: LWWDW. BBC Sport alapj√°n H2H: City vezet 3-1. Transfermarkt szerint De Bruyne s√©r√ºlt."\n\n`;
            
            combinedPrompt += `**C√©l:** Val√≥s adatokon alapul√≥ pontos val√≥sz√≠n≈±s√©gek, nem kital√°lt inform√°ci√≥k!\n\n`;
            
            // === S√öLYOZ√ÅSI √öTMUTAT√ì === //
            combinedPrompt += `## ‚öñÔ∏è KRITIKUS S√öLYOZ√ÅSI √öTMUTAT√ì\n\n`;
            combinedPrompt += `**SPORTSPECIFIKUS PRIORIT√ÅSOK:**\n\n`;
            combinedPrompt += `### üå§Ô∏è ID≈êJ√ÅR√ÅS S√öLYOZ√ÅS:\n`;
            combinedPrompt += `‚Ä¢ **SZABADT√âRI SPORTOK** (labdar√∫g√°s, tenisz, baseball, amerikai futball):\n`;
            combinedPrompt += `  - Id≈ëj√°r√°s hat√°s: 1-100 sk√°la (50 = semleges)\n`;
            combinedPrompt += `  - Optim√°lis h≈ëm√©rs√©klet: Labdar√∫g√°s 15¬∞C, Tenisz 22¬∞C, Baseball 21¬∞C\n`;
            combinedPrompt += `  - Sz√©l/Es≈ë hat√°s: Jelent≈ës befoly√°s a j√°t√©kra\n`;
            combinedPrompt += `‚Ä¢ **BELT√âRI SPORTOK** (kos√°rlabda, j√©gkorong):\n`;
            combinedPrompt += `  - Id≈ëj√°r√°s hat√°s: MINDIG 50 (semleges) - nincs hat√°s!\n`;
            combinedPrompt += `  - Ne keress id≈ëj√°r√°si adatokat belt√©ri sportokhoz\n\n`;
            
            combinedPrompt += `### üë• KULCSJ√ÅT√âKOS S√öLYOZ√ÅS:\n`;
            combinedPrompt += `‚Ä¢ **EGY√âNI SPORTOK** (tenisz):\n`;
            combinedPrompt += `  - J√°t√©kos s√©r√ºl√©s: 20-80 sk√°la (kritikus hat√°s!)\n`;
            combinedPrompt += `  - Nincs cserepad - minden s√©r√ºl√©s kritikus\n`;
            combinedPrompt += `‚Ä¢ **CSAPAT SPORTOK**:\n`;
            combinedPrompt += `  - Kulcsj√°t√©kos: 20-80 sk√°la + is_key_player: true\n`;
            combinedPrompt += `  - Norm√°l j√°t√©kos: 40-60 sk√°la + is_key_player: false\n\n`;
            
            combinedPrompt += `### üéØ POZ√çCI√ì SPECIFIKUS S√öLYOZ√ÅS:\n`;
            combinedPrompt += `‚Ä¢ **J√âGKORONG**: Kapus >> minden m√°s (70-80 vs 20-30)\n`;
            combinedPrompt += `‚Ä¢ **BASEBALL**: Dob√≥ >> minden m√°s (70-90 vs 10-30)\n`;
            combinedPrompt += `‚Ä¢ **AMERIKAI FUTBALL**: QB >> RB >> WR >> Defense\n`;
            combinedPrompt += `‚Ä¢ **LABDAR√öG√ÅS**: Kapus > V√©d≈ë > K√∂z√©pp√°ly√°s > T√°mad√≥\n`;
            combinedPrompt += `‚Ä¢ **KOS√ÅRLABDA**: Szt√°rok > Rot√°ci√≥ > Kisebb szerepek\n\n`;
            
            combinedPrompt += `### üìä SK√ÅLA HASZN√ÅLAT:\n`;
            combinedPrompt += `‚Ä¢ **1-20**: Nagyon rossz hat√°s/forma\n`;
            combinedPrompt += `‚Ä¢ **20-40**: Rossz hat√°s/forma\n`;
            combinedPrompt += `‚Ä¢ **40-60**: Semleges/√°tlagos (50 = t√∂k√©letesen semleges)\n`;
            combinedPrompt += `‚Ä¢ **60-80**: J√≥ hat√°s/forma\n`;
            combinedPrompt += `‚Ä¢ **80-100**: Kiv√°l√≥ hat√°s/forma\n\n`;
            
            combinedPrompt += `**EML√âKEZTET≈ê:** A s√∫lyoz√°s sportspecifikus! J√©gkorongn√°l a kapus, baseballn√°l a dob√≥, teniszn√©l minden s√©r√ºl√©s kritikus!`;
            
            return combinedPrompt;
        }

        function generateDetailedSportModel(sport) {
            let modelText = '';
            
            switch(sport) {
                case 'football':
                case 'soccer':
                    modelText += "### ‚öΩ LABDAR√öG√ÅS MATEMATIKAI MODELLEK:\n";
                    modelText += "‚Ä¢ **Dixon-Coles Poisson**: G√≥lok el≈ërejelz√©se Œª = t√°mad√°s √ó v√©delem √ó hazai el≈ëny √ó id≈ëj√°r√°s\n";
                    modelText += "‚Ä¢ **Skellam Eloszl√°s**: G√≥lk√ºl√∂nbs√©g val√≥sz√≠n≈±s√©g\n";
                    modelText += "‚Ä¢ **xG Model**: V√°rhat√≥ g√≥lok poz√≠ci√≥ √©s l√∂v√©s min≈ës√©g alapj√°n\n";
                    modelText += "‚Ä¢ **Id≈ëj√°r√°s S√∫lyoz√°s**: W_faktor = 1 + Œ±√ó|T-15¬∞| + Œ≤√ósz√©l + Œ≥√óes≈ë (max 15% hat√°s)\n";
                    modelText += "‚Ä¢ **Hi√°nyz√≥ J√°t√©kos**: Edge_adj = Edge √ó ‚àè(1 - I_i √ó K_i), ahol K_i = 1.5 ha kulcs\n";
                    modelText += "‚Ä¢ **Hazai El≈ëny**: 1.15x szorz√≥ + szurkol√≥i t√°mogat√°s\n\n";
                    break;
                case 'tennis':
                    modelText += "### üéæ TENISZ MATEMATIKAI MODELLEK:\n";
                    modelText += "‚Ä¢ **Markov L√°nc**: P(pont) ‚Üí P(game) ‚Üí P(set) ‚Üí P(match)\n";
                    modelText += "‚Ä¢ **Elo Rating**: Dinamikus er≈ëss√©g sz√°m√≠t√°s p√°lya-specifikusan\n";
                    modelText += "‚Ä¢ **P√°lya Faktor**: Clay (0.9), Hard (1.0), Grass (1.15) szerva szorz√≥k\n";
                    modelText += "‚Ä¢ **Id≈ëj√°r√°s (szabadt√©ri)**: Sz√©l hat√°s max 20%, h≈ëm√©rs√©klet optimum 22¬∞C\n";
                    modelText += "‚Ä¢ **S√©r√ºl√©s Hat√°s**: P_adj = P √ó (1 - 0.5 √ó s√©r√ºl√©s_s√∫lyoss√°g) - egy√©ni sportban kritikus!\n";
                    modelText += "‚Ä¢ **F√°radts√°g**: El≈ëz≈ë meccs hossza √©s pihen≈ë napok\n\n";
                    break;
                case 'basketball':
                    modelText += "### üèÄ KOS√ÅRLABDA MATEMATIKAI MODELLEK:\n";
                    modelText += "‚Ä¢ **N√©gy Faktor**: S√∫lyozott kombin√°ci√≥: 40% l√∂v√©s, 25% labdaveszt√©s, 20% lepattan√≥, 15% b√ºntet≈ëk\n";
                    modelText += "‚Ä¢ **Temp√≥ Elemz√©s**: Pontok = Hat√©konys√°g √ó Birtokl√°sok √ó Temp√≥_faktor\n";
                    modelText += "‚Ä¢ **Pitagorasz**: Win% = Pontok^k / (Pontok^k + Engedett^k), k=14\n";
                    modelText += "‚Ä¢ **Id≈ëj√°r√°s**: NINCS HAT√ÅS (belt√©ri sport) - mindig 50 (semleges)\n";
                    modelText += "‚Ä¢ **F√°radts√°g**: e^(-Œ± √ó pihen≈ë_napok) √ó utaz√°si_t√°vols√°g_b√ºntet√©s\n";
                    modelText += "‚Ä¢ **Kulcsj√°t√©kos**: Max 25% hat√°s (kev√©sb√© kritikus mint egy√©ni sportban)\n\n";
                    break;
                case 'hockey':
                    modelText += "### üèí J√âGKORONG MATEMATIKAI MODELLEK:\n";
                    modelText += "‚Ä¢ **Corsi/Fenwick**: L√∂v√©s min≈ës√©g √ó t√°vols√°g √ó sz√∂g √ó helyzet t√≠pus\n";
                    modelText += "‚Ä¢ **KAPUS KRITIKUS**: 50-70% hat√°s! Save% = 1 - (GA/SA), GSAA = xGA - GA\n";
                    modelText += "‚Ä¢ **PDO Regresszi√≥**: (Shooting% + Save%) √ó 100, visszat√©r√©s 100-hoz\n";
                    modelText += "‚Ä¢ **Id≈ëj√°r√°s**: NINCS HAT√ÅS (belt√©ri sport) - mindig 50 (semleges)\n";
                    modelText += "‚Ä¢ **Speci√°lis Egys√©gek**: PP_eff √ó lehet≈ës√©gek - PK_hat√©konys√°g\n";
                    modelText += "‚Ä¢ **Kapus vs Mez≈ënyj√°t√©kos**: Kapus >> minden m√°s poz√≠ci√≥!\n\n";
                    break;
                case 'baseball':
                    modelText += "### ‚öæ BASEBALL MATEMATIKAI MODELLEK:\n";
                    modelText += "‚Ä¢ **Pitagorasz Enhanced**: Win% = RS^1.83 / (RS^1.83 + RA^1.83)\n";
                    modelText += "‚Ä¢ **DOB√ì KRITIKUS**: 60-80% hat√°s! FIP, ERA, WHIP alap√∫ teljes√≠tm√©ny\n";
                    modelText += "‚Ä¢ **Id≈ëj√°r√°s MAXIM√ÅLIS**: Leg√©rz√©kenyebb sport! HR_faktor = 1 + 0.1√ó(T-21)/10 + 0.05√ósz√©l\n";
                    modelText += "‚Ä¢ **Park Faktor**: Stadion m√©ret √ó magass√°g √ó sz√©l ir√°ny kombin√°ci√≥ja\n";
                    modelText += "‚Ä¢ **Sabermetrics**: wOBA, wRC+, FIP kombin√°lt elemz√©s\n";
                    modelText += "‚Ä¢ **Dob√≥ vs √út≈ëk**: Dob√≥ >> minden m√°s poz√≠ci√≥!\n\n";
                    break;
                case 'americanfootball':
                    modelText += "### üèà AMERIKAI FUTBALL MATEMATIKAI MODELLEK:\n";
                    modelText += "‚Ä¢ **EPA Model**: Expected Points Added per play\n";
                    modelText += "‚Ä¢ **DVOA**: Defense-adjusted Value Over Average\n";
                    modelText += "‚Ä¢ **Quarterback Kritikus**: 40-50% hat√°s (legfontosabb poz√≠ci√≥)\n";
                    modelText += "‚Ä¢ **Id≈ëj√°r√°s (szabadt√©ri)**: Sz√©l hat√°s passing vs rushing game ar√°nyra\n";
                    modelText += "‚Ä¢ **Turnover Differential**: Labdaveszt√©s/szerz√©s hat√°s pontokra\n";
                    modelText += "‚Ä¢ **Poz√≠ci√≥ S√∫lyoz√°s**: QB >> RB >> WR >> Defense\n\n";
                    break;
                default:
                    modelText += `### ${sport.toUpperCase()} √ÅLTAL√ÅNOS MODELLEK:\n`;
                    modelText += "‚Ä¢ Sport-specifikus statisztikai modellek\n";
                    modelText += "‚Ä¢ Teljes√≠tm√©ny elemz√©s\n";
                    modelText += "‚Ä¢ T√∂rt√©neti adatok ki√©rt√©kel√©se\n";
                    modelText += "‚Ä¢ Id≈ëj√°r√°s hat√°s sport f√ºgg≈ëen\n\n";
            }
            
            return modelText;
        }

        function generateEnhancedSportRequirements(sport) {
            let requirements = '';
            
            switch(sport) {
                case 'football':
                case 'soccer':
                    requirements += "### ‚öΩ LABDAR√öG√ÅS - KRITIKUS ADATOK S√öLYOZ√ÅSSAL:\n\n";
                    requirements += "#### üèüÔ∏è HELYSZ√çN √âS K√ñRNYEZET (SZABADT√âRI SPORT!):\n";
                    requirements += "‚Ä¢ **Stadion t√≠pus**: Szabadt√©ri (id≈ëj√°r√°s KRITIKUS!)\n";
                    requirements += "‚Ä¢ **F√ºves p√°lya**: Term√©szetes/mesters√©ges\n";
                    requirements += "‚Ä¢ **Stadion m√©ret**: Befoly√°solja a j√°t√©kst√≠lust\n\n";
                    requirements += "#### üå§Ô∏è ID≈êJ√ÅR√ÅS - MAXIM√ÅLIS PRIORIT√ÅS (15% HAT√ÅS!):\n";
                    requirements += "‚Ä¢ **H≈ëm√©rs√©klet**: Optim√°lis 15¬∞C, ¬±10¬∞C elt√©r√©s = teljes√≠tm√©nycs√∂kken√©s\n";
                    requirements += "‚Ä¢ **Sz√©l**: >5 km/h = labda r√∂pp√°lya v√°ltoz√°s, max 12% hat√°s\n";
                    requirements += "‚Ä¢ **Es≈ë**: >30% val√≥sz√≠n≈±s√©g = cs√∫sz√≥s p√°lya, max 10% hat√°s\n";
                    requirements += "‚Ä¢ **P√°ratartalom**: Optim√°lis 50%, ¬±20% = j√°t√©kos komfort\n";
                    requirements += "‚Ä¢ **S√öLYOZ√ÅS**: Id≈ëj√°r√°s hat√°s 1-100 sk√°l√°n mindk√©t csapathoz!\n\n";
                    requirements += "#### üë• J√ÅT√âKOSOK - KULCSJ√ÅT√âKOS DIFFERENCI√ÅL√ÅS:\n";
                    requirements += "‚Ä¢ **Kulcsj√°t√©kosok**: Max 30% hat√°s (csapatkapit√°ny, g√≥lkir√°ly, playmaker)\n";
                    requirements += "‚Ä¢ **Norm√°l j√°t√©kosok**: Max 10% hat√°s\n";
                    requirements += "‚Ä¢ **Poz√≠ci√≥ fontoss√°g**: Kapus > V√©d≈ë > K√∂z√©pp√°ly√°s > T√°mad√≥\n";
                    requirements += "‚Ä¢ **S√öLYOZ√ÅS**: 1-100 sk√°la + kulcsj√°t√©kos boolean!\n\n";
                    break;
                    
                case 'tennis':
                    requirements += "### üéæ TENISZ - KRITIKUS ADATOK S√öLYOZ√ÅSSAL:\n\n";
                    requirements += "#### üèüÔ∏è HELYSZ√çN T√çPUS MEGHAT√ÅROZ√ÅSA:\n";
                    requirements += "‚Ä¢ **Szabadt√©ri**: Id≈ëj√°r√°s KRITIKUS hat√°s!\n";
                    requirements += "‚Ä¢ **Fedett**: Id≈ëj√°r√°s NINCS hat√°s!\n";
                    requirements += "‚Ä¢ **P√°lya t√≠pus**: Clay/Hard/Grass - j√°t√©kos specifikus teljes√≠tm√©ny\n\n";
                    requirements += "#### üå§Ô∏è ID≈êJ√ÅR√ÅS (CSAK SZABADT√âRI!):\n";
                    requirements += "‚Ä¢ **H≈ëm√©rs√©klet**: Optim√°lis 22¬∞C, ¬±8¬∞C elt√©r√©s = teljes√≠tm√©nycs√∂kken√©s\n";
                    requirements += "‚Ä¢ **Sz√©l**: >5 km/h = szerva pontoss√°g cs√∂kken√©s, max 20% hat√°s\n";
                    requirements += "‚Ä¢ **Napf√©ny/√Årny√©k**: L√°t√°si viszonyok befoly√°sol√°sa\n";
                    requirements += "‚Ä¢ **S√öLYOZ√ÅS**: Csak szabadt√©ri teniszn√©l sz√°m√≠t!\n\n";
                    requirements += "#### üë§ J√ÅT√âKOS √ÅLLAPOT - EGY√âNI SPORT S√öLYOZ√ÅS:\n";
                    requirements += "‚Ä¢ **Fizikai √°llapot**: 100% kritikus (nincs cserepad!)\n";
                    requirements += "‚Ä¢ **S√©r√ºl√©sek**: B√°rmilyen s√©r√ºl√©s = 50%+ teljes√≠tm√©nycs√∂kken√©s\n";
                    requirements += "‚Ä¢ **F√°radts√°g**: El≈ëz≈ë meccsek hossza √©s ideje\n";
                    requirements += "‚Ä¢ **S√öLYOZ√ÅS**: Egy√©ni sportban minden s√©r√ºl√©s kritikus!\n\n";
                    break;
                    
                case 'basketball':
                    requirements += "### üèÄ KOS√ÅRLABDA - KRITIKUS ADATOK S√öLYOZ√ÅSSAL:\n\n";
                    requirements += "#### üèüÔ∏è HELYSZ√çN T√çPUS (BELT√âRI SPORT!):\n";
                    requirements += "‚Ä¢ **Arena t√≠pus**: Belt√©ri (id≈ëj√°r√°s NINCS HAT√ÅS!)\n";
                    requirements += "‚Ä¢ **Hazai p√°lya**: Szurkol√≥i t√°mogat√°s, ismer≈ës k√∂rnyezet\n";
                    requirements += "‚Ä¢ **Utaz√°si t√°vols√°g**: F√°radts√°g hat√°s\n\n";
                    requirements += "#### üå§Ô∏è ID≈êJ√ÅR√ÅS - NINCS K√ñZVETLEN HAT√ÅS:\n";
                    requirements += "‚Ä¢ **Belt√©ri sport**: Id≈ëj√°r√°s nem befoly√°solja a j√°t√©kot\n";
                    requirements += "‚Ä¢ **Utaz√°si k√∂r√ºlm√©nyek**: Csak k√∂zvetett hat√°s\n";
                    requirements += "‚Ä¢ **S√öLYOZ√ÅS**: Id≈ëj√°r√°s hat√°s = 50 (semleges) minden esetben!\n\n";
                    requirements += "#### üë• J√ÅT√âKOSOK - CSAPATJ√ÅT√âK S√öLYOZ√ÅS:\n";
                    requirements += "‚Ä¢ **Kulcsj√°t√©kosok**: Max 25% hat√°s (szt√°rok, playmaker)\n";
                    requirements += "‚Ä¢ **Rot√°ci√≥**: Cserepad m√©lys√©ge fontos\n";
                    requirements += "‚Ä¢ **F√°radts√°g**: Back-to-back meccsek hat√°sa\n";
                    requirements += "‚Ä¢ **S√öLYOZ√ÅS**: Csapatj√°t√©kban kev√©sb√© kritikus mint egy√©ni sportban!\n\n";
                    break;
                    
                case 'hockey':
                    requirements += "### üèí J√âGKORONG - KRITIKUS ADATOK S√öLYOZ√ÅSSAL:\n\n";
                    requirements += "#### üèüÔ∏è HELYSZ√çN T√çPUS (BELT√âRI SPORT!):\n";
                    requirements += "‚Ä¢ **J√©gcsarnok**: Belt√©ri (id≈ëj√°r√°s NINCS HAT√ÅS!)\n";
                    requirements += "‚Ä¢ **J√©g min≈ës√©g**: H≈ëm√©rs√©klet csak a j√©g √°llapot√°ra\n";
                    requirements += "‚Ä¢ **Hazai p√°lya**: Utols√≥ cserepad el≈ëny\n\n";
                    requirements += "#### üå§Ô∏è ID≈êJ√ÅR√ÅS - NINCS K√ñZVETLEN HAT√ÅS:\n";
                    requirements += "‚Ä¢ **Belt√©ri sport**: Id≈ëj√°r√°s nem befoly√°solja a j√°t√©kot\n";
                    requirements += "‚Ä¢ **J√©g h≈ëm√©rs√©klet**: Optim√°lis -5¬∞C (bels≈ë h≈ëm√©rs√©klet)\n";
                    requirements += "‚Ä¢ **S√öLYOZ√ÅS**: Id≈ëj√°r√°s hat√°s = 50 (semleges) minden esetben!\n\n";
                    requirements += "#### ü•Ö KAPUS - KULCSFONTOSS√ÅG√ö POZ√çCI√ì (50%+ HAT√ÅS!):\n";
                    requirements += "‚Ä¢ **Kapus szem√©lye**: KRITIKUS! 50-70% hat√°s a meccsen!\n";
                    requirements += "‚Ä¢ **Kapus forma**: Save%, GAA, recent performance\n";
                    requirements += "‚Ä¢ **Kapus s√©r√ºl√©s**: Cserekapus = 30-50% teljes√≠tm√©nycs√∂kken√©s\n";
                    requirements += "‚Ä¢ **Kapus pihen≈ë**: F√°radts√°g hat√°s kritikus\n";
                    requirements += "‚Ä¢ **S√öLYOZ√ÅS**: Kapus = 70-80 ha j√≥ forma, 20-30 ha rossz!\n\n";
                    requirements += "#### üë• EGY√âB J√ÅT√âKOSOK:\n";
                    requirements += "‚Ä¢ **Kulcs v√©d≈ëk**: Max 20% hat√°s\n";
                    requirements += "‚Ä¢ **T√°mad√≥k**: Max 15% hat√°s\n";
                    requirements += "‚Ä¢ **S√öLYOZ√ÅS**: Kapus >> minden m√°s j√°t√©kos!\n\n";
                    break;
                    
                case 'baseball':
                    requirements += "### ‚öæ BASEBALL - KRITIKUS ADATOK S√öLYOZ√ÅSSAL:\n\n";
                    requirements += "#### üèüÔ∏è HELYSZ√çN T√çPUS (SZABADT√âRI SPORT!):\n";
                    requirements += "‚Ä¢ **Stadion t√≠pus**: Szabadt√©ri (id≈ëj√°r√°s KRITIKUS!)\n";
                    requirements += "‚Ä¢ **Park faktor**: Stadion m√©ret √©s jellemz≈ëk\n";
                    requirements += "‚Ä¢ **Magass√°g**: Altitude hat√°s labda r√∂pp√°ly√°ra\n\n";
                    requirements += "#### üå§Ô∏è ID≈êJ√ÅR√ÅS - MAXIM√ÅLIS PRIORIT√ÅS (25% HAT√ÅS!):\n";
                    requirements += "‚Ä¢ **H≈ëm√©rs√©klet**: Optim√°lis 21¬∞C, ¬±12¬∞C = labda t√°vols√°g v√°ltoz√°s\n";
                    requirements += "‚Ä¢ **Sz√©l**: KRITIKUS! Seg√≠t≈ë/g√°tl√≥ sz√©l = home run k√ºl√∂nbs√©g\n";
                    requirements += "‚Ä¢ **P√°ratartalom**: Optim√°lis 40%, ¬±25% = labda viselked√©s\n";
                    requirements += "‚Ä¢ **Magass√°g**: +0.01%/m√©ter hat√°s (Denver = +6% home run)\n";
                    requirements += "‚Ä¢ **S√öLYOZ√ÅS**: Baseball leg√©rz√©kenyebb az id≈ëj√°r√°sra!\n\n";
                    requirements += "#### ‚öæ DOB√ì - KULCSFONTOSS√ÅG√ö POZ√çCI√ì (60%+ HAT√ÅS!):\n";
                    requirements += "‚Ä¢ **Kezd≈ë dob√≥**: KRITIKUS! 60-80% hat√°s a meccsen!\n";
                    requirements += "‚Ä¢ **Dob√≥ forma**: FIP, ERA, WHIP, recent starts\n";
                    requirements += "‚Ä¢ **Dob√≥ f√°radts√°g**: Pihen≈ë napok sz√°ma\n";
                    requirements += "‚Ä¢ **Bullpen min≈ës√©g**: K√©s≈ëi innings hat√°s\n";
                    requirements += "‚Ä¢ **S√öLYOZ√ÅS**: Dob√≥ = 70-90 ha j√≥ forma, 10-30 ha rossz!\n\n";
                    requirements += "#### üë• EGY√âB J√ÅT√âKOSOK:\n";
                    requirements += "‚Ä¢ **Kulcs √ºt≈ëk**: Max 20% hat√°s\n";
                    requirements += "‚Ä¢ **V√©d≈ëk**: Max 10% hat√°s\n";
                    requirements += "‚Ä¢ **S√öLYOZ√ÅS**: Dob√≥ >> minden m√°s j√°t√©kos!\n\n";
                    break;
                    
                case 'americanfootball':
                    requirements += "### üèà AMERIKAI FUTBALL - KRITIKUS ADATOK S√öLYOZ√ÅSSAL:\n\n";
                    requirements += "#### üèüÔ∏è HELYSZ√çN T√çPUS (SZABADT√âRI/BELT√âRI):\n";
                    requirements += "‚Ä¢ **Stadion t√≠pus**: Ellen≈ërizd szabadt√©ri/fedett!\n";
                    requirements += "‚Ä¢ **M≈±f≈±/Term√©szetes**: S√©r√ºl√©s kock√°zat\n";
                    requirements += "‚Ä¢ **Hazai p√°lya**: Crowd noise hat√°s\n\n";
                    requirements += "#### üå§Ô∏è ID≈êJ√ÅR√ÅS (SZABADT√âRI STADIONOKBAN!):\n";
                    requirements += "‚Ä¢ **H≈ëm√©rs√©klet**: Extr√©m hideg/meleg = teljes√≠tm√©nycs√∂kken√©s\n";
                    requirements += "‚Ä¢ **Sz√©l**: Passing game vs rushing game\n";
                    requirements += "‚Ä¢ **Es≈ë/H√≥**: Labda kontroll neh√©zs√©gek\n";
                    requirements += "‚Ä¢ **S√öLYOZ√ÅS**: Csak szabadt√©ri stadionokban sz√°m√≠t!\n\n";
                    requirements += "#### üë• J√ÅT√âKOSOK - POZ√çCI√ì SPECIFIKUS S√öLYOZ√ÅS:\n";
                    requirements += "‚Ä¢ **Quarterback**: 40-50% hat√°s (legfontosabb poz√≠ci√≥)\n";
                    requirements += "‚Ä¢ **Running Back**: 20-25% hat√°s\n";
                    requirements += "‚Ä¢ **Wide Receiver**: 15-20% hat√°s\n";
                    requirements += "‚Ä¢ **V√©delem**: Poz√≠ci√≥nk√©nt 10-15% hat√°s\n\n";
                    break;
                    
                case 'tennis':
                    requirements += "### üéæ TENISZ - RE√ÅLIS ADATOK:\n\n";
                    requirements += "#### üèüÔ∏è Alapadatok:\n";
                    requirements += "‚Ä¢ **J√°t√©kosok**: Pontos nevek\n";
                    requirements += "‚Ä¢ **Tornament**: N√©v, kateg√≥ria (ha ismert)\n";
                    requirements += "‚Ä¢ **Helysz√≠n**: Indoor/outdoor (FONTOS!)\n";
                    requirements += "‚Ä¢ **P√°lya**: Clay/hard/grass (ha ismert)\n\n";
                    requirements += "#### üìä Egyszer≈± adatok:\n";
                    requirements += "‚Ä¢ **Rangsor**: Ha k√∂nnyen el√©rhet≈ë\n";
                    requirements += "‚Ä¢ **Forma**: Ha van friss adat\n";
                    requirements += "‚Ä¢ **S√©r√ºl√©sek**: Ha nyilv√°nos\n\n";
                    requirements += "#### üå§Ô∏è Id≈ëj√°r√°s (csak outdoor):\n";
                    requirements += "‚Ä¢ **H≈ëm√©rs√©klet**: √Åltal√°nos el≈ërejelz√©s\n";
                    requirements += "‚Ä¢ **Sz√©l**: Ha jelent≈ës\n";
                    requirements += "‚Ä¢ **Hat√°s**: 50 (semleges) alap√©rtelmez√©s\n\n";
                    break;
                    
                case 'basketball':
                    requirements += "### üèÄ KOS√ÅRLABDA - RE√ÅLIS ADATOK:\n\n";
                    requirements += "#### üèüÔ∏è Alapadatok:\n";
                    requirements += "‚Ä¢ **Csapatok**: Pontos nevek, liga\n";
                    requirements += "‚Ä¢ **Helysz√≠n**: Arena neve (indoor)\n";
                    requirements += "‚Ä¢ **Liga poz√≠ci√≥**: Ha el√©rhet≈ë\n\n";
                    requirements += "#### üìä Egyszer≈± adatok:\n";
                    requirements += "‚Ä¢ **Forma**: Ha van friss adat\n";
                    requirements += "‚Ä¢ **S√©r√ºl√©sek**: Ha nyilv√°nos\n";
                    requirements += "‚Ä¢ **Alap√©rtelmez√©s**: 50 (semleges) √©rt√©kek\n\n";
                    break;
                    
                case 'hockey':
                    requirements += "### üèí J√âGKORONG - RE√ÅLIS ADATOK:\n\n";
                    requirements += "#### üèüÔ∏è Alapadatok:\n";
                    requirements += "‚Ä¢ **Csapatok**: Pontos nevek, liga\n";
                    requirements += "‚Ä¢ **Helysz√≠n**: Arena neve (indoor)\n";
                    requirements += "‚Ä¢ **Liga poz√≠ci√≥**: Ha el√©rhet≈ë\n\n";
                    requirements += "#### üìä Egyszer≈± adatok:\n";
                    requirements += "‚Ä¢ **Forma**: Ha van friss adat\n";
                    requirements += "‚Ä¢ **Kapus**: Ha ismert a kezd≈ë\n";
                    requirements += "‚Ä¢ **Alap√©rtelmez√©s**: 50 (semleges) √©rt√©kek\n\n";
                    break;
                    
                case 'baseball':
                    requirements += "### ‚öæ BASEBALL - RE√ÅLIS ADATOK:\n\n";
                    requirements += "#### üèüÔ∏è Alapadatok:\n";
                    requirements += "‚Ä¢ **Csapatok**: Pontos nevek, liga\n";
                    requirements += "‚Ä¢ **Helysz√≠n**: Stadion neve (outdoor)\n";
                    requirements += "‚Ä¢ **Liga poz√≠ci√≥**: Ha el√©rhet≈ë\n\n";
                    requirements += "#### üå§Ô∏è Id≈ëj√°r√°s (szabadt√©ri):\n";
                    requirements += "‚Ä¢ **H≈ëm√©rs√©klet**: √Åltal√°nos el≈ërejelz√©s\n";
                    requirements += "‚Ä¢ **Sz√©l**: Ha jelent≈ës\n";
                    requirements += "‚Ä¢ **Es≈ë**: Ha v√°rhat√≥\n\n";
                    requirements += "#### üìä Egyszer≈± adatok:\n";
                    requirements += "‚Ä¢ **Forma**: Ha van friss adat\n";
                    requirements += "‚Ä¢ **Dob√≥k**: Ha ismert a kezd≈ë\n";
                    requirements += "‚Ä¢ **Alap√©rtelmez√©s**: 50 (semleges) √©rt√©kek\n\n";
                    break;
                    
                default:
                    requirements += `### ${sport.toUpperCase()} - GENERAL REQUIREMENTS:\n\n`;
                    requirements += "‚Ä¢ Recent form and performance data\n";
                    requirements += "‚Ä¢ Head-to-head records\n";
                    requirements += "‚Ä¢ Player availability and injuries\n";
                    requirements += "‚Ä¢ Venue conditions and advantages\n";
                    requirements += "‚Ä¢ Motivational factors\n\n";
            }
            
            return requirements;
        }

        function generateComprehensiveJsonExample(sport) {
            if (sport === 'football') {
                return `    {
      "sport": "football",
      "matches": [
        {
          "home_team": "Manchester City",
          "away_team": "Arsenal",
          "league": "Premier League",
          "match_date": "2024-01-15",
          "venue": "Etihad Stadium",
          "venue_type": "outdoor",
          
          "fair_odds_calculation": {
            "home_win_prob": 0.52,
            "draw_prob": 0.28,
            "away_win_prob": 0.20,
            "calculation_method": "Dixon-Coles modell √©s logikus becsl√©s alapj√°n"
          },
          
          "total_goals_prob": {
            "over_2_5": 0.58, "under_2_5": 0.42,
            "over_3_5": 0.32, "under_3_5": 0.68
          },
          
          "both_teams_score": { "yes": 0.65, "no": 0.35 },
          
          "team_stats": {
            "home_team": {
              "recent_form": "W-W-D-W-L",
              "league_position": 2
            },
            "away_team": {
              "recent_form": "W-L-W-W-D", 
              "league_position": 4
            }
          },
          
          "head_to_head": {
            "overall_record": "City leads slightly",
            "recent_meetings": "nincs adat"
          },
          
          "weather_analysis": {
            "temperature": 8,
            "conditions": "Partly cloudy",
            "venue_type": "outdoor",
            "team_a_weather_impact": 48,
            "team_b_weather_impact": 52,
            "weather_impact_reasoning": "SZABADT√âRI labdar√∫g√°s - 8¬∞C h≈±v√∂s, optim√°lis 15¬∞C, enyhe hat√°s"
          },
          
          "missing_players_analysis": {
            "team_a_missing": [
              {
                "player_name": "Kevin De Bruyne",
                "position": "Midfielder",
                "is_key_player": true,
                "impact_scale": 25,
                "injury_reasoning": "KULCSJ√ÅT√âKOS labdar√∫g√°sban - playmaker hi√°nya jelent≈ës"
              }
            ],
            "team_b_missing": [
              {
                "player_name": "Martin Odegaard",
                "position": "Midfielder", 
                "is_key_player": false,
                "impact_scale": 45,
                "injury_reasoning": "Norm√°l j√°t√©kos - m√©rs√©kelt hat√°s"
              }
            ]
          },
          
          "motivation_analysis": {
            "home_team_motivation": {
              "league_position": 2,
              "is_high_motivation": true,
              "motivation_scale": 85,
              "motivation_reasoning": "C√≠mv√©d√©s fontos"
            },
            "away_team_motivation": {
              "league_position": 4,
              "is_high_motivation": true,
              "motivation_scale": 75,
              "motivation_reasoning": "Top 4 hely√©rt k√ºzd"
            }
          },
          
          "reasoning": "Manchester City enyhe es√©lyes otthon. Arsenal j√≥ form√°ban, de City hazai rekordja er≈ës. De Bruyne hi√°nya befoly√°solja City j√°t√©k√°t. Mindk√©t csapat motiv√°lt - forr√°s: Premier League tabella √©s forma adatok."
        }
      ]
    },
`;
            } else if (sport === 'tennis') {
                return `    {
      "sport": "tennis",
      "matches": [
        {
          "home_team": "Novak Djokovic",
          "away_team": "Carlos Alcaraz",
          "tournament": "Australian Open",
          "match_date": "2024-01-26",
          "venue": "Rod Laver Arena",
          "venue_type": "outdoor",
          "surface_type": "hard",
          
          "fair_odds_calculation": {
            "player1_win_prob": 0.48,
            "player2_win_prob": 0.52,
            "calculation_method": "Elo rating √©s p√°lya t√≠pus alapj√°n"
          },
          
          "total_games": {
            "over_22_5": 0.58, "under_22_5": 0.42
          },
          
          "tennis_analysis": {
            "player1_stats": {
              "current_ranking": 1,
              "recent_form": "j√≥"
            },
            "player2_stats": {
              "current_ranking": 2,
              "recent_form": "j√≥"
            },
            "surface_advantage": {
              "player_a_advantage": 75,
              "player_b_advantage": 82,
              "surface_reasoning": "Alcaraz jobb hard p√°ly√°n"
            },
            "recent_injuries": {
              "player_a_injury": null,
              "player_b_injury": null
            }
          },
          
          "weather_analysis": {
            "temperature": 28,
            "conditions": "Sunny",
            "player_a_weather_impact": 50,
            "player_b_weather_impact": 50,
            "weather_impact_reasoning": "Semleges id≈ëj√°r√°si hat√°s"
          },
          
          "venue_conditions": {
            "venue_type": "outdoor",
            "court_surface": "hard"
          },
          
          "head_to_head": {
            "overall_record": "Djokovic leads 3-2",
            "recent_meetings": "v√°ltoz√≥ eredm√©nyek"
          },
          
          "motivation_analysis": {
            "player1_motivation": {
              "is_high_motivation": true,
              "motivation_scale": 95,
              "motivation_reasoning": "Grand Slam c√≠m"
            },
            "player2_motivation": {
              "is_high_motivation": true,
              "motivation_scale": 92,
              "motivation_reasoning": "Fiatal, bizony√≠tani akar"
            }
          },
          
          "reasoning": "Szoros meccs v√°rhat√≥. Alcaraz enyhe es√©lyes a hard p√°ly√°n mutatott jobb forma miatt. Djokovic tapasztalata vs Alcaraz lend√ºlete. Mindketten motiv√°ltak - forr√°s: ATP rangsor √©s forma."
        }
      ]
    },
`;
            } else if (sport === 'basketball') {
                return `    {
      "sport": "basketball",
      "matches": [
        {
          "home_team": "Los Angeles Lakers",
          "away_team": "Boston Celtics",
          "league": "NBA",
          "match_date": "2024-01-15",
          "venue": "Crypto.com Arena",
          "venue_type": "indoor",
          "tipoff_time": "22:00",
          
          "fair_odds_calculation": {
            "home_win_prob": 0.45,
            "away_win_prob": 0.55,
            "calculation_method": "Four Factors + Pace + Efficiency + Injuries"
          },
          
          "total_points_prob": {
            "specifier": "225.5",
            "over": 0.52,
            "under": 0.48,
            "over_220_5": 0.62, "under_220_5": 0.38,
            "over_230_5": 0.38, "under_230_5": 0.62
          },
          
          "handicap_prob": {
            "home_+3": 0.52, "away_-3": 0.48,
            "home_+2.5": 0.50, "away_-2.5": 0.50
          },
          
          "team_stats": {
            "home_team": {
              "offensive_efficiency": 115.2,
              "defensive_efficiency": 112.8,
              "pace": 99.5,
              "effective_fg_percentage": 54.2,
              "turnover_rate": 13.8,
              "offensive_rebound_rate": 24.5,
              "free_throw_rate": 22.1,
              "home_record": "15-8",
              "recent_form": "W-L-W-W-L"
            },
            "away_team": {
              "offensive_efficiency": 118.5,
              "defensive_efficiency": 110.2,
              "pace": 97.8,
              "effective_fg_percentage": 56.8,
              "turnover_rate": 12.2,
              "offensive_rebound_rate": 22.8,
              "free_throw_rate": 20.5,
              "away_record": "18-5",
              "recent_form": "W-W-W-L-W"
            }
          },
          
          "venue_conditions": {
            "venue_type": "indoor",
            "arena_capacity": 20000,
            "court_conditions": "Excellent",
            "home_court_advantage": 3.2,
            "arena_atmosphere": "Electric for rivalry game"
          },
          
          "missing_players_analysis": {
            "team_a_missing": [
              {
                "player_name": "Anthony Davis",
                "position": "PF/C",
                "injury_type": "Knee soreness",
                "is_key_player": true,
                "impact_scale": 20,
                "expected_return": "Game time decision"
              }
            ],
            "team_b_missing": [
              {
                "player_name": "Kristaps Porzingis",
                "position": "C",
                "injury_type": "Ankle sprain",
                "is_key_player": false,
                "impact_scale": 40,
                "expected_return": "2-3 weeks"
              }
            ]
          },
          
          "schedule_analysis": {
            "home_team_rest": 2,
            "away_team_rest": 1,
            "back_to_back": false,
            "travel_distance": 2500,
            "time_zone_change": 3,
            "fatigue_impact": "Moderate for away team"
          },
          
          "motivation_analysis": {
            "home_team_motivation": {
              "conference_standing": 9,
              "playoff_race": "Fighting for play-in",
              "is_high_motivation": true,
              "motivation_scale": 78,
              "motivation_reasoning": "Must-win game for playoff hopes"
            },
            "away_team_motivation": {
              "conference_standing": 1,
              "playoff_race": "Securing top seed",
              "is_high_motivation": false,
              "motivation_scale": 65,
              "motivation_reasoning": "Comfortable lead, can rest players"
            }
          },
          
          "reasoning": "Celtics favored despite road game due to superior efficiency and health. Lakers desperate for win but missing AD hurts interior defense. Expect high-scoring game given both teams' pace. Celtics' better shooting should overcome Lakers' home court advantage."
        }
      ]
    },
`;
            } else if (sport === 'hockey') {
                return `    {
      "sport": "hockey",
      "matches": [
        {
          "home_team": "Toronto Maple Leafs",
          "away_team": "Boston Bruins",
          "league": "NHL",
          "match_date": "2024-01-15",
          "venue": "Scotiabank Arena",
          "venue_type": "indoor",
          
          "fair_odds_calculation": {
            "home_win_prob": 0.42,
            "away_win_prob": 0.58,
            "calculation_method": "Corsi/Fenwick + Kapus teljes√≠tm√©ny + Speci√°lis egys√©gek"
          },
          
          "total_goals_prob": {
            "over_5_5": 0.55, "under_5_5": 0.45,
            "over_6_5": 0.35, "under_6_5": 0.65
          },
          
          "team_stats": {
            "home_team": {
              "corsi_for_percentage": 52.3,
              "expected_goals_for": 3.1,
              "power_play_percentage": 22.5,
              "penalty_kill_percentage": 81.2,
              "recent_form": "W-L-W-L-W"
            },
            "away_team": {
              "corsi_for_percentage": 54.8,
              "expected_goals_for": 3.4,
              "power_play_percentage": 25.1,
              "penalty_kill_percentage": 84.7,
              "recent_form": "W-W-W-L-W"
            }
          },
          
          "weather_analysis": {
            "venue_type": "indoor",
            "team_a_weather_impact": 50,
            "team_b_weather_impact": 50,
            "weather_impact_reasoning": "BELT√âRI j√©gkorong - id≈ëj√°r√°s NINCS HAT√ÅS!"
          },
          
          "goaltender_analysis": {
            "home_goalie": {
              "name": "Joseph Woll",
              "save_percentage": 0.912,
              "goals_against_average": 2.85,
              "recent_form": "3-1-0 utols√≥ 4 meccs",
              "is_starting": true,
              "goalie_impact_scale": 75,
              "goalie_reasoning": "KRITIKUS POZ√çCI√ì - j√≥ forma, 75/100 teljes√≠tm√©ny"
            },
            "away_goalie": {
              "name": "Jeremy Swayman", 
              "save_percentage": 0.924,
              "goals_against_average": 2.41,
              "recent_form": "4-0-1 utols√≥ 5 meccs",
              "is_starting": true,
              "goalie_impact_scale": 85,
              "goalie_reasoning": "KRITIKUS POZ√çCI√ì - kiv√°l√≥ forma, 85/100 teljes√≠tm√©ny"
            }
          },
          
          "missing_players_analysis": {
            "team_a_missing": [
              {
                "player_name": "Auston Matthews",
                "position": "Center",
                "is_key_player": true,
                "impact_scale": 30,
                "injury_reasoning": "Kulcs t√°mad√≥ - j√©gkorongban kev√©sb√© kritikus mint kapus"
              }
            ],
            "team_b_missing": [
              {
                "player_name": "David Pastrnak",
                "position": "Right Wing",
                "is_key_player": true,
                "impact_scale": 25,
                "injury_reasoning": "Kulcs t√°mad√≥ - m√©rs√©kelt hat√°s, kapus fontosabb"
              }
            ]
          },
          
          "motivation_analysis": {
            "home_team_motivation": {
              "conference_standing": 3,
              "is_high_motivation": true,
              "motivation_scale": 80,
              "motivation_reasoning": "Playoff poz√≠ci√≥ v√©delme"
            },
            "away_team_motivation": {
              "conference_standing": 1,
              "is_high_motivation": false,
              "motivation_scale": 70,
              "motivation_reasoning": "Vezet≈ë poz√≠ci√≥, kev√©sb√© s√ºrg≈ës"
            }
          },
          
          "reasoning": "Boston es√©lyes a kiv√°l√≥ kapus teljes√≠tm√©ny (Swayman 92.4% vs Woll 91.2%) √©s jobb Corsi% miatt. J√âGKORONGBAN A KAPUS A LEGFONTOSABB - Swayman 85/100 vs Woll 75/100 hat√°s. Id≈ëj√°r√°s nincs hat√°s (belt√©ri). Hi√°nyz√≥ t√°mad√≥k kev√©sb√© kritikusak."
        }
      ]
    },
`;
            } else if (sport === 'baseball') {
                    return `    {
      "sport": "baseball",
      "matches": [
        {
          "home_team": "Detroit Tigers",
          "away_team": "Seattle Mariners",
          "league": "MLB",
          "match_date": "2025-07-11",
          "venue": "Comerica Park",
          "venue_type": "outdoor",
          
          "fair_odds_calculation": {
            "home_win_prob": 0.602,
            "away_win_prob": 0.398,
            "draw_prob": 0.0,
            "calculation_method": "Pythagorean expectation model applied with Detroit expected winning percentage 0.617 based on runs scored 468 and runs allowed 360, Seattle expected 0.516 with 416 runs scored and 405 allowed. Log5 method for head-to-head probability calculation accounting for home field advantage."
          },
          
          "total_runs_prob": {
            "over_7_5": 0.58, "under_7_5": 0.42,
            "over_8_5": 0.45, "under_8_5": 0.55,
            "over_9_5": 0.32, "under_9_5": 0.68,
            "over_10_5": 0.22, "under_10_5": 0.78
          },
          
          "team_stats": {
            "home_team": {
              "runs_scored_season": 468,
              "runs_allowed_season": 360,
              "home_ops": 0.766,
              "home_era": 3.42,
              "home_record": "28-15",
              "bullpen_era": 3.18,
              "team_batting_avg": 0.254
            },
            "away_team": {
              "runs_scored_season": 416,
              "runs_allowed_season": 405,
              "away_ops": 0.769,
              "away_era": 4.01,
              "away_record": "22-21",
              "bullpen_era": 3.95,
              "team_batting_avg": 0.248
            }
          },
          
          "starting_pitchers": {
            "home_pitcher": {
              "name": "Tarik Skubal",
              "record": "10-2",
              "era": 2.02,
              "whip": 0.95,
              "strikeouts_per_9": 11.2,
              "recent_form": "3 consecutive quality starts",
              "pitcher_impact_scale": 85,
              "pitcher_reasoning": "KRITIKUS POZ√çCI√ì - kiv√°l√≥ forma, 85/100 teljes√≠tm√©ny"
            },
            "away_pitcher": {
              "name": "Luis Castillo",
              "record": "5-5",
              "era": 3.31,
              "whip": 1.18,
              "strikeouts_per_9": 9.8,
              "recent_form": "scoreless last start",
              "pitcher_impact_scale": 65,
              "pitcher_reasoning": "KRITIKUS POZ√çCI√ì - √°tlagos forma, 65/100 teljes√≠tm√©ny"
            }
          },
          
          "weather_analysis": {
            "temperature": 30,
            "wind_direction": "SSW",
            "wind_speed": 12,
            "humidity": 50,
            "precipitation_probability": 70,
            "conditions": "Thunderstorms late, partly cloudy",
            "venue_type": "outdoor",
            "team_a_weather_impact": 35,
            "team_b_weather_impact": 35,
            "weather_impact_reasoning": "SZABADT√âRI baseball - MAXIM√ÅLIS ID≈êJ√ÅR√ÅS HAT√ÅS! 30¬∞C meleg (opt. 21¬∞C), SSW sz√©l 12km/h = home run t√°vols√°g n√∂veked√©s, 70% es≈ë val√≥sz√≠n≈±s√©g"
          },
          
          "venue_conditions": {
            "park_factor": {
              "runs": 100,
              "home_runs": 98,
              "batting": 100,
              "pitching": 98
            },
            "dimensions": {
              "left_field": 342,
              "left_center": 370,
              "center_field": 412,
              "right_center": 365,
              "right_field": 330,
              "foul_territory": "average"
            },
            "altitude": 620
          },
          
          "missing_players_analysis": {
            "team_a_missing": [
              {
                "player_name": "Gleyber Torres",
                "position": "2B",
                "injury_type": "neck contusion",
                "is_key_player": false,
                "impact_scale": 40,
                "expected_return": "day-to-day"
              }
            ],
            "team_b_missing": [
              {
                "player_name": "Alex Cobb",
                "position": "SP",
                "injury_type": "hip inflammation",
                "is_key_player": true,
                "impact_scale": 30,
                "expected_return": "2 weeks"
              }
            ]
          },
          
          "head_to_head": {
            "season_series": "Detroit leads 4-2",
            "last_5_meetings": [
              {"date": "2024-06-15", "result": "7-4", "winner": "Detroit"},
              {"date": "2024-06-14", "result": "3-8", "winner": "Seattle"},
              {"date": "2024-06-13", "result": "5-2", "winner": "Detroit"},
              {"date": "2024-05-20", "result": "1-6", "winner": "Seattle"},
              {"date": "2024-05-19", "result": "9-3", "winner": "Detroit"}
            ],
            "historical_record": "Detroit leads overall series 81-80 since 1993"
          },
          
          "motivation_analysis": {
            "home_team_motivation": {
              "division_standing": 1,
              "games_ahead": 3.5,
              "playoff_probability": 85,
              "is_high_motivation": true,
              "motivation_scale": 75,
              "motivation_reasoning": "Leading AL Central division, seeking to maintain momentum before All-Star break"
            },
            "away_team_motivation": {
              "division_standing": 3,
              "games_behind": 8.5,
              "playoff_probability": 45,
              "is_high_motivation": true,
              "motivation_scale": 80,
              "motivation_reasoning": "Fighting for wild card position in competitive AL West race"
            }
          },
          
          "reasoning": "Detroit jelent≈ës el≈ënyben Pythagorean expectation alapj√°n (0.617 vs 0.516). DOB√ì KRITIKUS POZ√çCI√ì - Skubal 85/100 vs Castillo 65/100 teljes√≠tm√©ny. Id≈ëj√°r√°s MAXIM√ÅLIS hat√°s baseballban - 30¬∞C + SSW sz√©l = home run n√∂veked√©s. H2H Detroit vezet 4-2. Mindk√©t csapat motiv√°lt. Detroit 60.2% val√≥sz√≠n≈±s√©g."
        }
      ]
    },
`;
            } else {
                    // Generic example for all sports or unknown sports
                    return `    {
      "sport": "SPORT_NAME",
      "matches": [
        {
          "home_team": "Team/Player A",
          "away_team": "Team/Player B",
          "league": "League Name",
          "match_date": "2024-XX-XX",
          "venue": "Venue Name",
          "venue_type": "indoor/outdoor",
          
          "fair_odds_calculation": {
            "home_win_prob": 0.XX,
            "away_win_prob": 0.XX,
            "draw_prob": 0.XX,
            "calculation_method": "Detailed method explanation with specific models and data sources used"
          },
          
          "SPORT_SPECIFIC_MARKETS": {
            "market_name": { "option1": 0.XX, "option2": 0.XX }
          },
          
          "team_stats": { "detailed_statistics": "Complete statistical breakdown" },
          "head_to_head": { "historical_data": "Recent meetings and historical record" },
          "weather_analysis": { "IF_OUTDOOR_ONLY": "Temperature, wind, precipitation with impact analysis" },
          "venue_conditions": { "IF_INDOOR_ONLY": "Arena conditions and advantages" },
          "missing_players_analysis": { "injuries_and_impact": "Player availability with impact scale 1-100" },
          "motivation_analysis": { "stakes_and_motivation": "League position, playoff implications, motivation scale 1-100" },
          
          "reasoning": "Comprehensive analysis explanation incorporating all researched factors with specific data points and source justification"
        }
      ]
    },
`;
            }
        }
        
        function extractJsonFromText(text) {
            console.log('üîß Starting intelligent JSON extraction...');
            
            // Enhanced cleaning for LLM artifacts and escaped characters
            let cleanedText = text
                .replace(/```json\s*/gi, '') // Remove json code block markers
                .replace(/```\s*/g, '') // Remove closing code block markers
                .replace(/:contentReference\[[^\]]+\]\{[^}]+\}/g, '') // Remove contentReference citations
                .replace(/::contentReference\[[^\]]+\]\{[^}]+\}/g, '') // Remove double colon contentReference
                .replace(/\s*:contentReference\[[^\]]+\]\{[^}]+\}\s*/g, ' ') // Remove with whitespace cleanup
                .replace(/contentReference\[[^\]]+\]\{[^}]+\}/g, '') // Remove without colon
                .replace(/\\\"/g, '"') // Fix escaped quotes (improved regex)
                .replace(/\\\[/g, '[') // Fix escaped brackets
                .replace(/\\\]/g, ']') // Fix escaped brackets
                .replace(/\\\\/g, '\\') // Fix double escapes
                .replace(/\s+/g, ' ') // Normalize whitespace
                .trim();
            
            // Try to find JSON object boundaries
            let startIndex = cleanedText.indexOf('{');
            let endIndex = cleanedText.lastIndexOf('}');
            
            if (startIndex === -1 || endIndex === -1 || startIndex >= endIndex) {
                console.warn('‚ùå No valid JSON structure found, trying emergency fallback...');
                return tryEmergencyJsonExtraction(text);
            }
            
            const jsonText = cleanedText.substring(startIndex, endIndex + 1);
            
            try {
                // Test parse to validate JSON
                const parsed = JSON.parse(jsonText);
                
                // Validate structure - handle both direct analyses array and nested structure
                let analysesArray;
                if (parsed.analyses && Array.isArray(parsed.analyses)) {
                    analysesArray = parsed.analyses;
                } else if (Array.isArray(parsed)) {
                    // Handle case where JSON is directly an array
                    analysesArray = parsed;
                } else {
                    console.warn('‚ö†Ô∏è Invalid structure detected, trying intelligent repair...');
                    return tryIntelligentJsonRepair(parsed, text);
                }
                
                // Ensure we have the correct structure
                if (!analysesArray || analysesArray.length === 0) {
                    console.warn('‚ö†Ô∏è Empty analyses array, trying data extraction...');
                    return tryDataExtraction(text);
                }
                
                // Normalize the structure
                if (!parsed.analyses) {
                    parsed = { analyses: analysesArray };
                }
                
                // Intelligent data validation and repair
                const repairedData = intelligentDataRepair(parsed);
                
                // Count total matches across all analyses
                let totalMatches = 0;
                let analysisDetails = [];
                
                // Check each analysis has required fields
                for (const analysis of repairedData.analyses) {
                    if (!analysis.sport || !analysis.matches || !Array.isArray(analysis.matches)) {
                        console.warn(`‚ö†Ô∏è Repairing analysis structure for sport: ${analysis.sport || 'unknown'}`);
                        analysis.sport = analysis.sport || 'football';
                        analysis.matches = analysis.matches || [];
                    }
                    
                    totalMatches += analysis.matches.length;
                    analysisDetails.push(`${analysis.sport}: ${analysis.matches.length} matches`);
                    
                    // Repair each match with minimum required fields
                    for (const match of analysis.matches) {
                        repairMatchData(match);
                    }
                }
                
                // Log analysis summary
                console.log(`‚úÖ JSON Analysis Summary: ${totalMatches} total matches found`);
                console.log('Details:', analysisDetails.join('; '));
                
                return JSON.stringify(repairedData);
                
            } catch (parseError) {
                console.error('‚ùå JSON parse error:', parseError);
                console.warn('üîß Trying emergency repair methods...');
                
                return tryEmergencyJsonRepair(jsonText, text);
            }
        }
        
        // Emergency JSON extraction when structure is completely broken
        function tryEmergencyJsonExtraction(text) {
            console.log('üö® Emergency JSON extraction activated');
            
            try {
                // Try to extract any team names and basic data
                const teamMatches = text.match(/([A-Za-z\s]+)\s+vs?\s+([A-Za-z\s]+)/gi) || [];
                const oddsMatches = text.match(/\d+\.\d+/g) || [];
                
                if (teamMatches.length === 0) {
                    throw new Error('No team matches found in emergency extraction');
                }
                
                const emergencyData = {
                    analyses: [{
                        sport: 'football',
                        matches: teamMatches.slice(0, 5).map((match, index) => {
                            const teams = match.split(/\s+vs?\s+/i);
                            const homeTeam = teams[0]?.trim() || `Team A${index + 1}`;
                            const awayTeam = teams[1]?.trim() || `Team B${index + 1}`;
                            
                            return {
                                home_team: homeTeam,
                                away_team: awayTeam,
                                league: "Unknown League",
                                match_date: new Date().toISOString().split('T')[0],
                                venue: "Unknown Venue",
                                venue_type: "outdoor",
                                
                                fair_odds_calculation: {
                                    home_win_prob: 0.40,
                                    draw_prob: 0.30,
                                    away_win_prob: 0.30,
                                    calculation_method: "Emergency fallback - equal probabilities with slight home advantage"
                                },
                                
                                total_goals_prob: {
                                    over_2_5: 0.50,
                                    under_2_5: 0.50
                                },
                                
                                both_teams_score: {
                                    yes: 0.55,
                                    no: 0.45
                                },
                                
                                reasoning: `Emergency data extraction for ${homeTeam} vs ${awayTeam}. No detailed analysis available - using conservative estimates.`
                            };
                        })
                    }]
                };
                
                console.log('‚úÖ Emergency extraction successful:', emergencyData.analyses[0].matches.length, 'matches created');
                return JSON.stringify(emergencyData);
                
            } catch (error) {
                console.error('‚ùå Emergency extraction failed:', error);
                throw new Error('Nem siker√ºlt semmilyen adatot kinyerni a sz√∂vegb≈ël. K√©rlek, ellen≈ërizd a JSON form√°tumot!');
            }
        }
        
        // Intelligent JSON repair for complex/oversized data
        function tryIntelligentJsonRepair(parsed, originalText) {
            console.log('üîß Intelligent JSON repair starting...');
            
            try {
                const repairedData = { analyses: [] };
                
                // Try to find sport and match data in various possible structures
                const possibleKeys = Object.keys(parsed);
                console.log('Available keys:', possibleKeys);
                
                // Look for sport-related data
                for (const key of possibleKeys) {
                    const value = parsed[key];
                    
                    if (typeof value === 'object' && value !== null) {
                        // Check if this could be a sport analysis
                        if (value.sport || value.matches || Array.isArray(value)) {
                            const sportData = extractSportDataFromObject(value, key);
                            if (sportData) {
                                repairedData.analyses.push(sportData);
                            }
                        }
                    }
                }
                
                // If no analyses found, create a basic structure
                if (repairedData.analyses.length === 0) {
                    console.warn('‚ö†Ô∏è No valid sport data found, creating basic structure...');
                    repairedData.analyses.push(createBasicSportAnalysis(parsed));
                }
                
                console.log('‚úÖ Intelligent repair successful:', repairedData.analyses.length, 'analyses created');
                return JSON.stringify(repairedData);
                
            } catch (error) {
                console.error('‚ùå Intelligent repair failed:', error);
                return tryDataExtraction(originalText);
            }
        }
        
        // Extract sport data from complex objects
        function extractSportDataFromObject(obj, fallbackSport = 'football') {
            try {
                const sport = obj.sport || fallbackSport.toLowerCase();
                let matches = [];
                
                if (obj.matches && Array.isArray(obj.matches)) {
                    matches = obj.matches;
                } else if (Array.isArray(obj)) {
                    matches = obj;
                } else {
                    // Try to create a match from the object itself
                    if (obj.home_team || obj.away_team || obj.team_a || obj.team_b) {
                        matches = [obj];
                    }
                }
                
                // Repair each match
                matches = matches.map(match => repairMatchData(match)).filter(match => match !== null);
                
                if (matches.length === 0) {
                    return null;
                }
                
                return {
                    sport: sport,
                    matches: matches
                };
                
            } catch (error) {
                console.error('Error extracting sport data:', error);
                return null;
            }
        }
        
        // Create basic sport analysis from any object
        function createBasicSportAnalysis(obj) {
            const analysis = {
                sport: 'football',
                matches: []
            };
            
            // Try to extract any team-like data
            const possibleMatch = {
                home_team: obj.home_team || obj.team_a || obj.team1 || 'Team A',
                away_team: obj.away_team || obj.team_b || obj.team2 || 'Team B',
                league: obj.league || obj.tournament || 'Unknown League',
                match_date: obj.match_date || obj.date || new Date().toISOString().split('T')[0],
                venue: obj.venue || obj.stadium || 'Unknown Venue',
                venue_type: obj.venue_type || 'outdoor'
            };
            
            analysis.matches.push(repairMatchData(possibleMatch));
            
            return analysis;
        }
        
        // Repair individual match data
        function repairMatchData(match) {
            if (!match || typeof match !== 'object') {
                return null;
            }
            
            // Ensure basic team names
            if (!match.home_team && !match.away_team) {
                return null;
            }
            
            match.home_team = match.home_team || match.team_a || match.team1 || 'Team A';
            match.away_team = match.away_team || match.team_b || match.team2 || 'Team B';
            match.league = match.league || match.tournament || 'Unknown League';
            match.match_date = match.match_date || match.date || new Date().toISOString().split('T')[0];
            match.venue = match.venue || match.stadium || 'Unknown Venue';
            match.venue_type = match.venue_type || 'outdoor';
            
            // Ensure fair_odds_calculation exists
            if (!match.fair_odds_calculation) {
                match.fair_odds_calculation = {
                    home_win_prob: 0.40,
                    draw_prob: 0.30,
                    away_win_prob: 0.30,
                    calculation_method: "Auto-generated fallback probabilities"
                };
            }
            
            // Ensure basic market probabilities for football
            if (!match.total_goals_prob) {
                match.total_goals_prob = {
                    over_2_5: 0.50,
                    under_2_5: 0.50
                };
            }
            
            if (!match.both_teams_score) {
                match.both_teams_score = {
                    yes: 0.55,
                    no: 0.45
                };
            }
            
            // Ensure reasoning exists
            if (!match.reasoning) {
                match.reasoning = `Auto-repaired data for ${match.home_team} vs ${match.away_team}. Limited analysis available.`;
            }
            
            return match;
        }
        
        // Try simple data extraction from text
        function tryDataExtraction(text) {
            console.log('üîß Trying simple data extraction...');
            
            try {
                // Extract team names using various patterns
                const teamPatterns = [
                    /([A-Za-z\s]+)\s+vs?\s+([A-Za-z\s]+)/gi,
                    /([A-Za-z\s]+)\s+-\s+([A-Za-z\s]+)/gi,
                    /"home_team":\s*"([^"]+)"/gi,
                    /"away_team":\s*"([^"]+)"/gi
                ];
                
                const matches = [];
                const foundTeams = new Set();
                
                for (const pattern of teamPatterns) {
                    let match;
                    while ((match = pattern.exec(text)) !== null) {
                        const homeTeam = match[1]?.trim();
                        const awayTeam = match[2]?.trim();
                        
                        if (homeTeam && awayTeam && homeTeam !== awayTeam) {
                            const matchKey = `${homeTeam}_vs_${awayTeam}`;
                            if (!foundTeams.has(matchKey)) {
                                foundTeams.add(matchKey);
                                matches.push({
                                    home_team: homeTeam,
                                    away_team: awayTeam,
                                    league: "Extracted League",
                                    match_date: new Date().toISOString().split('T')[0],
                                    venue: "Extracted Venue",
                                    venue_type: "outdoor",
                                    fair_odds_calculation: {
                                        home_win_prob: 0.40,
                                        draw_prob: 0.30,
                                        away_win_prob: 0.30,
                                        calculation_method: "Text extraction fallback"
                                    },
                                    total_goals_prob: { over_2_5: 0.50, under_2_5: 0.50 },
                                    both_teams_score: { yes: 0.55, no: 0.45 },
                                    reasoning: `Extracted from text: ${homeTeam} vs ${awayTeam}`
                                });
                            }
                        }
                    }
                }
                
                if (matches.length === 0) {
                    throw new Error('No matches found in text extraction');
                }
                
                const extractedData = {
                    analyses: [{
                        sport: 'football',
                        matches: matches.slice(0, 10) // Limit to 10 matches
                    }]
                };
                
                console.log('‚úÖ Data extraction successful:', matches.length, 'matches found');
                return JSON.stringify(extractedData);
                
            } catch (error) {
                console.error('‚ùå Data extraction failed:', error);
                throw new Error('Nem siker√ºlt semmilyen haszn√°lhat√≥ adatot kinyerni a sz√∂vegb≈ël!');
            }
        }
        
        // Emergency JSON repair for broken syntax
        function tryEmergencyJsonRepair(brokenJson, originalText) {
            console.log('üö® Emergency JSON repair activated');
            
            try {
                // Try to fix common JSON syntax errors
                let repairedJson = brokenJson
                    .replace(/,\s*}/g, '}') // Remove trailing commas
                    .replace(/,\s*]/g, ']') // Remove trailing commas in arrays
                    .replace(/:\s*,/g, ': null,') // Fix empty values
                    .replace(/}\s*{/g, '}, {') // Fix missing commas between objects
                    .replace(/]\s*\[/g, '], [') // Fix missing commas between arrays
                    .replace(/([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '"$1":') // Quote unquoted keys
                    .replace(/:\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*([,}])/g, ': "$1"$2'); // Quote unquoted string values
                
                // Try to parse the repaired JSON
                const parsed = JSON.parse(repairedJson);
                
                // If successful, process normally
                return tryIntelligentJsonRepair(parsed, originalText);
                
            } catch (error) {
                console.error('‚ùå Emergency JSON repair failed:', error);
                
                // Last resort: try data extraction
                return tryDataExtraction(originalText);
            }
        }
        
        // Intelligent data repair for oversized or complex data
        function intelligentDataRepair(data) {
            try {
                console.log('üîß Intelligent data repair starting...');
                
                // Limit the size of data to prevent performance issues
                if (data.analyses && Array.isArray(data.analyses)) {
                    // Limit to 5 sports maximum
                    data.analyses = data.analyses.slice(0, 5);
                    
                    data.analyses.forEach(analysis => {
                        if (analysis.matches && Array.isArray(analysis.matches)) {
                            // Limit to 10 matches per sport
                            analysis.matches = analysis.matches.slice(0, 10);
                            
                            // Clean up oversized objects
                            analysis.matches.forEach(match => {
                                // Remove overly complex nested objects
                                Object.keys(match).forEach(key => {
                                    if (typeof match[key] === 'object' && match[key] !== null) {
                                        const obj = match[key];
                                        const objKeys = Object.keys(obj);
                                        
                                        // If object has too many keys, simplify it
                                        if (objKeys.length > 20) {
                                            console.warn(`‚ö†Ô∏è Simplifying oversized object: ${key}`);
                                            match[key] = simplifyComplexObject(obj);
                                        }
                                    }
                                });
                                
                                // Ensure essential fields exist
                                repairMatchData(match);
                            });
                        }
                    });
                }
                
                console.log('‚úÖ Intelligent data repair completed');
                return data;
                
            } catch (error) {
                console.error('‚ùå Intelligent data repair failed:', error);
                return data; // Return original data if repair fails
            }
        }
        
        // Simplify complex objects to essential data only
        function simplifyComplexObject(obj) {
            const essential = {};
            const importantKeys = [
                'home_win_prob', 'draw_prob', 'away_win_prob', 'player1_win_prob', 'player2_win_prob',
                'over_2_5', 'under_2_5', 'over_3_5', 'under_3_5',
                'yes', 'no', 'home', 'away', 'draw',
                'calculation_method', 'reasoning', 'impact_scale', 'motivation_scale'
            ];
            
            importantKeys.forEach(key => {
                if (obj.hasOwnProperty(key)) {
                    essential[key] = obj[key];
                }
            });
            
            // If no important keys found, keep first 5 keys
            if (Object.keys(essential).length === 0) {
                const keys = Object.keys(obj).slice(0, 5);
                keys.forEach(key => {
                    essential[key] = obj[key];
                });
            }
            
            return essential;
        }

        function processAllRetrievedData() {
            showLocalizedLoading('loadingPortfolioBuilder', 'loadingGeneratingRecommendations');
            
            try {
                const rawData = DOM.retrievedDataInput.value.trim();
                if (!rawData) {
                    showLocalizedNotification('notificationEmptyDataField', 'warning');
                    UIManager.hideLoading();
                    return;
                }

                let parsedData;
                try {
                    const jsonText = extractJsonFromText(rawData);
                    parsedData = JSON.parse(jsonText);
                    
                    // Ellen≈ërizz√ºk a JSON strukt√∫r√°t - t√°mogatjuk mindk√©t form√°tumot
                    if (!parsedData.analyses || !Array.isArray(parsedData.analyses)) {
                        throw new Error(getText('errorInvalidJsonStructure') + '. Expected: {"analyses": [...]}');
                    }
                    
                    // Valid√°ljuk hogy minden analysis tartalmaz sportot √©s meccseket
                    parsedData.analyses.forEach((analysis, index) => {
                        if (!analysis.sport) {
                            throw new Error(`Analysis ${index + 1}: Missing sport field`);
                        }
                        if (!analysis.matches || !Array.isArray(analysis.matches)) {
                            throw new Error(`Analysis ${index + 1}: Missing or invalid matches array`);
                        }
                        if (analysis.matches.length === 0) {
                            console.warn(`Analysis ${index + 1}: Empty matches array for sport ${analysis.sport}`);
                        }
                    });
                    
                } catch (e) {
                    console.error('JSON parsing error:', e);
                    showLocalizedNotification('notificationJsonError', 'error', { error: e.message });
                    UIManager.hideLoading();
                    return;
                }
                
                // T√°roljuk az adatokat √©s gener√°ljuk a portf√≥li√≥t
                AppState.retrievedData = parsedData;
                console.log(`Successfully processed ${parsedData.analyses.length} sport analyses with ${parsedData.analyses.reduce((total, a) => total + a.matches.length, 0)} total matches`);
                
                showLocalizedNotification('notificationDataLoaded', 'success');
                
                // Gener√°ljuk a portf√≥li√≥t az √∂sszes matematikai modellel
                const portfolio = generatePortfolio(AppState.retrievedData.analyses, AppState.uploadedImages);
                AppState.portfolio = portfolio;

                // Megjelen√≠√≠tj√ºk az eredm√©nyeket
                displayPortfolio(portfolio);
                UIManager.switchTab('results');
                
                showLocalizedNotification('notificationAllPromptsComplete', 'success');

            } catch (error) {
                console.error("Error processing retrieved data:", error);
                showLocalizedNotification('notificationDataLoadError', 'error', { error: error.message });
            } finally {
                UIManager.hideLoading();
            }
        }
        
        // Prompt completion functions removed - now we always have only one prompt
        
        function generatePortfolio(llmAnalyses, imageAnalyses) {
            const capital = parseFloat(document.getElementById('capital').value);
            const maxRiskPct = parseFloat(document.getElementById('maxRisk').value) / 100;
            const kellyModifierSingle = parseFloat(document.getElementById('kellyModifierSingle').value);
            const kellyModifierParlay = parseFloat(document.getElementById('kellyModifierParlay').value);

            // √âletszer≈± minimum t√©tek
            const MIN_STAKE_SINGLE = capital * 0.005; // Minimum 0.5% of capital (5 EUR for 1000 EUR)
            const MIN_STAKE_PARLAY = capital * 0.002; // Minimum 0.2% for parlays (2 EUR for 1000 EUR)
            const MIN_EDGE = 0.03; // Minimum 3% edge required
            const MIN_EV = capital * 0.001; // Minimum expected value 0.1% of capital

            // 1. Create a flat list of all odds found in the uploaded images.
            const allFoundOdds = imageAnalyses.flatMap(image => {
                if (!image.analysisResult || image.status !== 'completed') return [];
                return (image.analysisResult.odds_found || []).map(odd => ({
                    ...odd,
                    match: (image.analysisResult.matches_detected || [])[odd.applies_to_match_index],
                    sport: (image.analysisResult.sport_type || 'unknown').toLowerCase(),
                }));
            });

            const bestBetsMap = new Map();
            
            console.log('Processing odds for portfolio generation...');
            console.log('Found odds by sport:', allFoundOdds.reduce((acc, odd) => {
                acc[odd.sport] = (acc[odd.sport] || 0) + 1;
                return acc;
            }, {}));

            // 2. Enhanced odds matching with detailed probability extraction
            allFoundOdds.forEach(oddInfo => {
                if (!oddInfo.match) return;

                const normalizeSport = (sport) => {
                    const sportLower = sport.toLowerCase();
                    if (sportLower === 'soccer') return 'football';
                    if (sportLower === 'americanfootball') return 'americanfootball';
                    return sportLower;
                };

                const normalizedOddSport = normalizeSport(oddInfo.sport);
                const llmAnalysisForSport = llmAnalyses.find(a => 
                    normalizeSport(a.sport) === normalizedOddSport
                );
                
                if (!llmAnalysisForSport) {
                    console.warn(`No LLM analysis found for sport: ${oddInfo.sport}`);
                    return;
                }

                const llmMatchAnalysis = llmAnalysisForSport.matches.find(m =>
                    m.home_team.toLowerCase().includes(oddInfo.match.home_team.toLowerCase().split(' ')[0]) ||
                    m.away_team.toLowerCase().includes(oddInfo.match.away_team.toLowerCase().split(' ')[0]) ||
                    oddInfo.match.home_team.toLowerCase().includes(m.home_team.toLowerCase().split(' ')[0]) ||
                    oddInfo.match.away_team.toLowerCase().includes(m.away_team.toLowerCase().split(' ')[0])
                );
                
                if (!llmMatchAnalysis) {
                    console.warn(`No LLM match analysis found for: ${oddInfo.match.home_team} vs ${oddInfo.match.away_team}`);
                    return;
                }

                // Enhanced probability extraction for multiple markets
                for (const [selection, odds] of Object.entries(oddInfo.values)) {
                    let prob = 0;
                    let marketAnalysis = null;

                    // Match Result Markets
                    if (oddInfo.market_type === 'match_result' && llmMatchAnalysis.fair_odds_calculation) {
                        const probCalc = llmMatchAnalysis.fair_odds_calculation;
                        const selLower = selection.toLowerCase();
                        
                        if (oddInfo.sport === 'tennis') {
                            if (selLower.includes(llmMatchAnalysis.home_team.toLowerCase()) || selLower === '1') {
                                prob = probCalc.player1_win_prob || 0;
                            } else if (selLower.includes(llmMatchAnalysis.away_team.toLowerCase()) || selLower === '2') {
                                prob = probCalc.player2_win_prob || 0;
                            }
                        } else {
                            if (selLower.includes('home') || selLower === '1') prob = probCalc.home_win_prob || 0;
                            else if (selLower.includes('away') || selLower === '2') prob = probCalc.away_win_prob || 0;
                            else if (selLower.includes('draw') || selLower === 'x') prob = probCalc.draw_prob || 0;
                        }
                        marketAnalysis = llmMatchAnalysis.fair_odds_calculation;
                    }
                    
                    // Total Goals/Points Markets
                    else if (oddInfo.market_type.includes('total') || oddInfo.market_type.includes('over_under')) {
                        const totalProbKeys = ['total_goals_prob', 'total_points_prob', 'total_runs_prob'];
                        let probCalc = totalProbKeys.map(key => llmMatchAnalysis[key]).find(p => p);
                        
                        if (probCalc) {
                            const selLower = selection.toLowerCase();
                            // Try to match the specifier (e.g., 2.5, 218.5)
                            const specifier = oddInfo.market_specifier;
                            
                            // Look for matching over/under in detailed breakdown
                            if (specifier) {
                                const overKey = `over_${specifier.replace('.', '_')}`;
                                const underKey = `under_${specifier.replace('.', '_')}`;
                                
                                if (selLower.includes('over') && probCalc[overKey]) {
                                    prob = probCalc[overKey];
                                } else if (selLower.includes('under') && probCalc[underKey]) {
                                    prob = probCalc[underKey];
                                }
                            }
                            
                            // Fallback to basic over/under if detailed not found
                            if (prob === 0) {
                                if (selLower.includes('over')) prob = probCalc.over || 0;
                                else if (selLower.includes('under')) prob = probCalc.under || 0;
                            }
                            marketAnalysis = probCalc;
                        }
                    }
                    
                    // Corner Markets
                    else if (oddInfo.market_type.includes('corner')) {
                        if (llmMatchAnalysis.corners_prob) {
                            const selLower = selection.toLowerCase();
                            const specifier = oddInfo.market_specifier;
                            
                            if (specifier) {
                                const overKey = `over_${specifier.replace('.', '_')}`;
                                const underKey = `under_${specifier.replace('.', '_')}`;
                                
                                if (selLower.includes('over') && llmMatchAnalysis.corners_prob[overKey]) {
                                    prob = llmMatchAnalysis.corners_prob[overKey];
                                } else if (selLower.includes('under') && llmMatchAnalysis.corners_prob[underKey]) {
                                    prob = llmMatchAnalysis.corners_prob[underKey];
                                }
                            }
                            marketAnalysis = llmMatchAnalysis.corners_prob;
                        }
                    }
                    
                    // Card Markets
                    else if (oddInfo.market_type.includes('card')) {
                        if (llmMatchAnalysis.cards_prob) {
                            const selLower = selection.toLowerCase();
                            const specifier = oddInfo.market_specifier;
                            
                            if (specifier) {
                                const overKey = `over_${specifier.replace('.', '_')}`;
                                const underKey = `under_${specifier.replace('.', '_')}`;
                                
                                if (selLower.includes('over') && llmMatchAnalysis.cards_prob[overKey]) {
                                    prob = llmMatchAnalysis.cards_prob[overKey];
                                } else if (selLower.includes('under') && llmMatchAnalysis.cards_prob[underKey]) {
                                    prob = llmMatchAnalysis.cards_prob[underKey];
                                }
                            }
                            marketAnalysis = llmMatchAnalysis.cards_prob;
                        }
                    }
                    
                    // Handicap Markets
                    else if (oddInfo.market_type.includes('handicap')) {
                        if (llmMatchAnalysis.handicap_prob) {
                            const selLower = selection.toLowerCase();
                            const specifier = oddInfo.market_specifier;
                            
                            // Try to match handicap selection
                            Object.entries(llmMatchAnalysis.handicap_prob).forEach(([key, value]) => {
                                if (key.toLowerCase().includes(selLower) || selLower.includes(key.toLowerCase())) {
                                    prob = value;
                                }
                            });
                            marketAnalysis = llmMatchAnalysis.handicap_prob;
                        }
                    }
                    
                    // Both Teams to Score
                    else if (oddInfo.market_type.includes('both') || oddInfo.market_type.includes('btts')) {
                        if (llmMatchAnalysis.both_teams_score) {
                            const selLower = selection.toLowerCase();
                            if (selLower.includes('yes') || selLower.includes('both')) {
                                prob = llmMatchAnalysis.both_teams_score.yes || 0;
                            } else if (selLower.includes('no')) {
                                prob = llmMatchAnalysis.both_teams_score.no || 0;
                            }
                            marketAnalysis = llmMatchAnalysis.both_teams_score;
                        }
                    }

                    // Apply advanced adjustments if we found a probability
                    if (prob > 0) {
                        prob = applyAdvancedAdjustments(prob, llmMatchAnalysis, oddInfo.market_type);
                        
                        const edge = (prob * odds) - 1;

                        if (edge > MIN_EDGE) {
                            console.log(`Found valuable bet: ${oddInfo.sport} - ${oddInfo.match.home_team} vs ${oddInfo.match.away_team}, ${oddInfo.market_type} ${selection}, edge: ${(edge * 100).toFixed(2)}%`);
                            
                            const uniqueBetKey = `${oddInfo.sport}-${oddInfo.match.home_team}-${oddInfo.match.away_team}-${oddInfo.market_type}-${oddInfo.market_specifier}-${selection}`;
                            const currentBet = { 
                                sport: oddInfo.sport, 
                                home_team: oddInfo.match.home_team, 
                                away_team: oddInfo.match.away_team, 
                                market_type: oddInfo.market_type, 
                                market_specifier: oddInfo.market_specifier, 
                                selection, 
                                odds, 
                                prob,
                                edge,
                                marketAnalysis,
                                llmAnalysis: llmMatchAnalysis
                            };
                            
                            const existingBet = bestBetsMap.get(uniqueBetKey);
                            if (!existingBet || currentBet.odds > existingBet.odds) {
                                bestBetsMap.set(uniqueBetKey, currentBet);
                            }
                        }
                    }
                }
            });

            // 3. Enhanced stake calculation with detailed Kelly
            const finalBets = Array.from(bestBetsMap.values());
            finalBets.forEach(bet => {
                const b = bet.odds - 1; // Net odds
                const p = bet.prob;
                const q = 1 - p;
                
                // PROFESSIONAL INTEGRATED EV CALCULATION
                const advancedEV = calculateAdvancedEV({
                    prob: p, odds: bet.odds, stake: 100, sport: bet.sport, matchAnalysis: bet.matchAnalysis
                });
                
                // Update probability and edge with advanced calculations
                const adjustedProb = advancedEV.adjustedProb;
                const adjustedEdge = adjustedProb * bet.odds - 1;
                
                // Kelly fraction with enhanced calculation using adjusted probability
                const kellyFraction = b > 0 ? (b * adjustedProb - (1 - adjustedProb)) / b : 0;
                
                // Apply sport-specific and market-specific modifiers
                let modifier = kellyModifierSingle;
                if (bet.market_type.includes('corner') || bet.market_type.includes('card')) {
                    modifier *= 0.8; // More conservative for volatile markets
                } else if (bet.market_type.includes('handicap')) {
                    modifier *= 0.9; // Slightly more conservative for handicaps
                }
                
                const adjustedFraction = Math.max(0, Math.min(kellyFraction * modifier, 0.05)); // Cap at 5%
                let stake = adjustedFraction * capital;
                
                // Update bet with advanced calculations
                bet.adjustedProb = adjustedProb;
                bet.adjustedEdge = adjustedEdge;
                bet.advancedEV = advancedEV;
                
                // Enhanced stake rounding with market considerations
                if (stake > 100) {
                    stake = Math.round(stake / 10) * 10;
                } else if (stake > 50) {
                    stake = Math.round(stake / 5) * 5;
                } else if (stake > 20) {
                    stake = Math.round(stake / 2) * 2;
                } else {
                    stake = Math.round(stake);
                }
                
                bet.stake = stake;
                bet.ev = bet.stake * bet.adjustedEdge; // Use adjusted edge for EV
                bet.kellyFraction = kellyFraction;
                bet.adjustedFraction = adjustedFraction;
                bet.modifier = modifier;
                
                // Enhanced confidence calculation
                let confidenceFactors = {
                    edge: Math.min(bet.edge * 10, 1), // Edge contribution
                    probability: bet.prob, // Probability contribution
                    market: bet.market_type === 'match_result' ? 1 : 0.8, // Market type
                    dataQuality: bet.marketAnalysis ? 1 : 0.7 // Data quality
                };
                
                bet.confidence = Object.values(confidenceFactors).reduce((a, b) => a * b, 1);
            });

            // Enhanced filtering with multiple criteria
            const valuableBets = finalBets.filter(bet => 
                bet.stake >= MIN_STAKE_SINGLE && 
                bet.ev >= MIN_EV &&
                bet.edge >= MIN_EDGE &&
                bet.confidence > 0.3 // Minimum confidence threshold
            );

            // PROFESSIONAL INTEGRATED MATHEMATICAL SORTING
        // Comprehensive scoring system for long-term profitability
        valuableBets.sort((a, b) => {
            // Multi-factor scoring system
            const scoreA = calculateProfessionalScore(a);
            const scoreB = calculateProfessionalScore(b);
            return scoreB - scoreA;
        });

            // Portfolio risk management
            let totalStakePlanned = valuableBets.reduce((sum, bet) => sum + bet.stake, 0);
            const maxPortfolioStake = capital * maxRiskPct;
            
            if (totalStakePlanned > maxPortfolioStake && totalStakePlanned > 0) {
                const scale = maxPortfolioStake / totalStakePlanned;
                valuableBets.forEach(bet => {
                    bet.stake = Math.max(MIN_STAKE_SINGLE, Math.round(bet.stake * scale));
                    bet.ev = bet.stake * bet.edge;
                });
            }

            const singles = valuableBets;
            const parlays = generateEnhancedParlays(valuableBets, capital, kellyModifierParlay, MIN_STAKE_PARLAY, MIN_EDGE);

            console.log(`Generated portfolio: ${singles.length} singles, ${parlays.length} parlays`);

            return { singles, parlays };
        }
        
        function generateEnhancedParlays(bets, capital, kellyModifier, minStake, minEdge) {
            const comboStrategy = document.getElementById('comboStrategy').value;

            // Enhanced parlay generation with better filtering
            const uniqueBets = [];
            const seenMatches = new Set();
            const seenMarkets = new Set();
            
            for (const bet of bets) {
                const matchIdentifier = `${bet.home_team}-${bet.away_team}`;
                const marketIdentifier = `${matchIdentifier}-${bet.market_type}`;
                
                // Avoid same match and correlated markets
                if (!seenMatches.has(matchIdentifier) && !seenMarkets.has(marketIdentifier)) {
                    // Avoid highly correlated markets (e.g., match result + handicap)
                    const isCorrelated = bet.market_type === 'handicap' && 
                        uniqueBets.some(existing => 
                            existing.home_team === bet.home_team && 
                            existing.away_team === bet.away_team && 
                            existing.market_type === 'match_result'
                        );
                    
                    if (!isCorrelated) {
                    uniqueBets.push(bet);
                    seenMatches.add(matchIdentifier);
                        seenMarkets.add(marketIdentifier);
                    }
                }
            }

            if (uniqueBets.length < 3) return [];

            let selectedLegs;

            if (comboStrategy === 'ev') {
                // High EV Parlay Strategy: combine the top 3 EV bets
                selectedLegs = uniqueBets.sort((a, b) => b.ev - a.ev).slice(0, 3);
            } else {
                // High Probability Parlay Strategy: combine the top 3 highest probability bets
                selectedLegs = uniqueBets.sort((a, b) => b.prob - a.prob).slice(0, 3);
            }
            
            if (selectedLegs.length < 3) return [];

            const combinedOdds = selectedLegs.reduce((acc, leg) => acc * leg.odds, 1);
            const combinedProb = selectedLegs.reduce((acc, leg) => acc * leg.prob, 1);
            const edge = (combinedProb * combinedOdds) - 1;

            // Enhanced parlay filtering with correlation penalty
            const correlationPenalty = selectedLegs.some(leg => 
                leg.market_type.includes('corner') || leg.market_type.includes('card')
            ) ? 0.8 : 1.0; // Reduce edge if volatile markets included
            
            const adjustedEdge = edge * correlationPenalty;

            if (adjustedEdge > minEdge * 2) { // Parlays need higher edge
                const b = combinedOdds - 1;
                const p = combinedProb;
                const q = 1 - p;
                
                const kellyFraction = b > 0 ? (b * p - q) / b : 0;
                
                // Extra conservative for parlays with market-specific adjustments
                let parlayModifier = kellyModifier;
                if (selectedLegs.some(leg => leg.market_type !== 'match_result')) {
                    parlayModifier *= 0.8; // Even more conservative for non-main markets
                }
                
                const adjustedFraction = Math.max(0, Math.min(kellyFraction * parlayModifier, 0.02)); // Cap at 2%
                let stake = adjustedFraction * capital;
                
                // Enhanced parlay stake rounding
                if (stake > 50) {
                    stake = Math.round(stake / 5) * 5;
                } else if (stake > 20) {
                    stake = Math.round(stake / 2) * 2;
                } else {
                    stake = Math.round(stake);
                }
                
                if (stake >= minStake) {
                    // Enhanced confidence calculation for parlays
                    const avgConfidence = selectedLegs.reduce((sum, leg) => sum + leg.confidence, 0) / selectedLegs.length;
                    const parlayConfidence = avgConfidence * correlationPenalty * 0.8; // Parlay penalty
                    
                     return [{
                        legs: selectedLegs,
                        combinedOdds,
                        combinedProb,
                        edge: adjustedEdge,
                        stake,
                        ev: stake * adjustedEdge,
                        confidence: parlayConfidence,
                        kellyFraction: kellyFraction,
                        correlationPenalty,
                        strategy: comboStrategy
                    }];
                }
            }
            return [];
        }

        function displayPortfolio(portfolio) {
            DOM.noResults.classList.add('hidden');
            DOM.resultsContainer.classList.remove('hidden');
            DOM.portfolioSummary.classList.remove('hidden');

            displaySummary(portfolio);
            displayRecommendations(portfolio);
        }

        function displaySummary(portfolio) {
            const capital = parseFloat(document.getElementById('capital').value);
            const totalStake = portfolio.singles.reduce((sum, bet) => sum + bet.stake, 0) + portfolio.parlays.reduce((sum, bet) => sum + bet.stake, 0);
            const totalEV = portfolio.singles.reduce((sum, bet) => sum + bet.ev, 0) + portfolio.parlays.reduce((sum, bet) => sum + bet.ev, 0);
            
            // Enhanced profit calculations
            const totalPotentialWinnings = portfolio.singles.reduce((sum, bet) => sum + (bet.stake * (bet.odds - 1)), 0) + 
                                          portfolio.parlays.reduce((sum, bet) => sum + (bet.stake * (bet.combinedOdds - 1)), 0);
            const portfolioROI = totalStake > 0 ? (totalEV / totalStake) * 100 : 0;
            const utilizationRate = (totalStake / capital) * 100;
            const expectedProfitMargin = totalStake > 0 ? ((totalEV / totalStake) * 100) : 0;

            DOM.portfolioSummary.innerHTML = `
                <div class="stat-card" style="background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(30,41,59,0.9)); border: 2px solid rgba(16,185,129,0.4);">
                    <div class="stat-value" style="color: #10b981;">‚Ç¨${capital.toFixed(2)}</div>
                    <div class="stat-label" data-lang="totalCapital">${getText('totalCapital')}</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(30,41,59,0.9)); border: 2px solid rgba(139,92,246,0.4);">
                    <div class="stat-value" style="color: #8b5cf6;">‚Ç¨${totalStake.toFixed(2)}</div>
                    <div class="stat-label" data-lang="totalStake">${getText('totalStake')}</div>
                    <div style="font-size: 0.8rem; color: #94a3b8; margin-top: 0.5rem;">${utilizationRate.toFixed(1)}% ${getText('capitalUtilization')}</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(30,41,59,0.9)); border: 2px solid rgba(6,182,212,0.4);">
                    <div class="stat-value" style="color: #06b6d4;">‚Ç¨${(capital - totalStake).toFixed(2)}</div>
                    <div class="stat-label" data-lang="remainingCapital">${getText('remainingCapital')}</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(30,41,59,0.9)); border: 2px solid rgba(16,185,129,0.6); box-shadow: 0 10px 30px rgba(16,185,129,0.3);">
                    <div class="stat-value" style="color: #10b981; font-size: 2.8rem; font-weight: 900;">‚Ç¨${totalEV.toFixed(2)}</div>
                    <div class="stat-label" style="color: #10b981; font-weight: 700;">${getText('expectedProfit')}</div>
                    <div style="font-size: 0.9rem; color: #10b981; margin-top: 0.5rem; font-weight: 600;">+${expectedProfitMargin.toFixed(1)}% margin</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(30,41,59,0.9)); border: 2px solid rgba(6,182,212,0.4);">
                    <div class="stat-value" style="color: #06b6d4;">‚Ç¨${totalPotentialWinnings.toFixed(2)}</div>
                    <div class="stat-label">${getText('potentialWinnings')}</div>
                    <div style="font-size: 0.8rem; color: #94a3b8; margin-top: 0.5rem;">${getText('ifAllWin')}</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(30,41,59,0.9)); border: 2px solid rgba(245,158,11,0.4);">
                    <div class="stat-value" style="color: ${portfolioROI > 15 ? '#10b981' : portfolioROI > 8 ? '#f59e0b' : '#ef4444'};">${portfolioROI.toFixed(1)}%</div>
                    <div class="stat-label">${getText('expectedROI')}</div>
                </div>
            `;

            // Egyszer≈±s√≠tett portf√≥li√≥ √∂sszegz√©s
            const betCount = portfolio.singles.length + portfolio.parlays.length;
            const avgBetSize = betCount > 0 ? totalStake / betCount : 0;
            const singlesBetCount = portfolio.singles.length;
            const parlaysBetCount = portfolio.parlays.length;
            
            DOM.portfolioSummary.innerHTML += `
                <div class="stat-card" style="background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(30,41,59,0.9)); border: 2px solid rgba(16,185,129,0.4);">
                    <div class="stat-value" style="color: #10b981;">‚Ç¨${(capital + totalPotentialWinnings).toFixed(2)}</div>
                    <div class="stat-label" data-lang="potentialMaxCapital">${getText('potentialMaxCapital')}</div>
                    <div style="font-size: 0.8rem; color: #94a3b8; margin-top: 0.5rem;">${getText('potentialMaxCapitalHint')}</div>
                </div>
            `;
            
            // PROFESSIONAL LONG-TERM PROFITABILITY ANALYSIS
            const longTermAnalysis = calculateLongTermProfitability(portfolio);
            
            // Add professional portfolio insights
            DOM.portfolioSummary.innerHTML += `
                <div style="grid-column: 1 / -1; background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(6,182,212,0.1)); border: 1px solid rgba(139,92,246,0.3); border-radius: 20px; padding: 2rem; margin-top: 1rem;">
                    <h4 style="color: #8b5cf6; margin-bottom: 1rem; font-size: 1.3rem;">üìä ${getText('portfolioAnalysis')}</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                        <div><strong>${getText('totalBets')}:</strong> ${betCount} (${singlesBetCount} ${getText('singles')}, ${parlaysBetCount} ${getText('parlays')})</div>
                        <div><strong>${getText('avgBetSize')}:</strong> ‚Ç¨${avgBetSize.toFixed(2)}</div>
                        <div><strong>${getText('expectedProfitMargin')}:</strong> <span style="color: #10b981; font-weight: bold;">${expectedProfitMargin.toFixed(1)}%</span></div>
                        <div><strong>${getText('riskCategory')}:</strong> <span style="color: ${utilizationRate > 15 ? '#ef4444' : utilizationRate > 10 ? '#f59e0b' : '#10b981'};">${getText(utilizationRate > 15 ? 'riskHigh' : utilizationRate > 10 ? 'riskMedium' : 'riskLow')}</span></div>
                    </div>
                    ${longTermAnalysis ? `
                        <div style="margin-top: 1.5rem; padding: 1rem; background: rgba(16,185,129,0.1); border: 1px solid rgba(16,185,129,0.3); border-radius: 10px;">
                            <h5 style="color: #10b981; margin-bottom: 0.75rem; font-size: 1.1rem;">üéØ Hossz√∫t√°v√∫ Nyeres√©gess√©gi Elemz√©s</h5>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                                <div><strong>V√°rhat√≥ Nyeres√©g:</strong> <span style="color: ${longTermAnalysis.expectedProfit > 0 ? '#10b981' : '#ef4444'};">‚Ç¨${longTermAnalysis.expectedProfit.toFixed(2)}</span></div>
                                <div><strong>Nyer√©si Ar√°ny:</strong> <span style="color: #06b6d4;">${(longTermAnalysis.winRate * 100).toFixed(1)}%</span></div>
                                <div><strong>Hossz√∫t√°v√∫ ROI:</strong> <span style="color: ${longTermAnalysis.roi > 0 ? '#10b981' : '#ef4444'};">${longTermAnalysis.roi.toFixed(1)}%</span></div>
                                <div><strong>Max Drawdown:</strong> <span style="color: #f59e0b;">‚Ç¨${longTermAnalysis.maxDrawdown.toFixed(2)}</span></div>
                            </div>
                            <div style="padding: 0.75rem; background: rgba(0,0,0,0.2); border-radius: 8px; text-align: center;">
                                <strong style="color: ${longTermAnalysis.profitability === 'PROFITABLE' ? '#10b981' : '#ef4444'}; font-size: 1.1rem;">
                                    ${longTermAnalysis.profitability === 'PROFITABLE' ? '‚úÖ HOSSZ√öT√ÅVON NYERES√âGES' : '‚ùå HOSSZ√öT√ÅVON VESZTES√âGES'}
                                </strong>
                                <div style="margin-top: 0.5rem; color: #94a3b8;">
                                    Megb√≠zhat√≥s√°g: ${longTermAnalysis.confidence.toFixed(0)}%
                                </div>
                            </div>
                        </div>
                    ` : ''}
                    <div style="margin-top: 1rem; padding: 1rem; background: rgba(0,0,0,0.2); border-radius: 10px;">
                        <strong style="color: #10b981;">üí° ${getText('professionalAdvice')}:</strong> 
                        ${getText(portfolioROI > 20 ? 'excellentPortfolio' : portfolioROI > 10 ? 'goodPortfolio' : 'conservativePortfolio')}
                        ${utilizationRate > 15 ? ' ' + getText('considerReducingRisk') : ''}
                        ${longTermAnalysis && longTermAnalysis.profitability === 'PROFITABLE' ? 
                            ' A matematikai modellek alapj√°n ez a portf√≥li√≥ hossz√∫t√°von nyeres√©ges.' : 
                            longTermAnalysis ? ' Figyelem: A modellek szerint ez a portf√≥li√≥ hossz√∫t√°von vesztes√©ges lehet.' : ''}
                    </div>
                </div>
            `;
        }

        // --- PROFESSIONAL MONTE CARLO SIMULATION MODULE --- //
        // REMOVED - Not needed for simpler, more practical approach

        function displayRecommendations(portfolio) {
            const container = document.getElementById('recommendations-container');
            
            // Add download summary buttons
            const downloadButtonHTML = `
                <div style="text-align: center; margin: 2rem 0; padding: 1.5rem; background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(6,182,212,0.1)); border: 1px solid rgba(139,92,246,0.3); border-radius: 20px;">
                    <h3 style="color: #8b5cf6; margin-bottom: 1rem;">üìÑ Let√∂lthet≈ë √ñsszefoglal√≥k</h3>
                    <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="downloadPortfolioSummary()" style="display: flex; align-items: center; gap: 0.5rem;">
                            üìä <span data-lang="downloadPortfolioSummary">Portf√≥li√≥ √ñsszefoglal√≥</span>
                        </button>
                        <button class="btn btn-secondary" onclick="downloadCalculationDetails()" style="display: flex; align-items: center; gap: 0.5rem;">
                            üßÆ <span data-lang="downloadCalculationDetails">Matematikai Sz√°m√≠t√°sok</span>
                        </button>
                        <button class="btn btn-secondary" onclick="downloadDataSources()" style="display: flex; align-items: center; gap: 0.5rem;">
                            üîç <span data-lang="downloadDataSources">Adatforr√°sok & Ellen≈ërz√©s</span>
                        </button>
                    </div>
                </div>
            `;
            
            container.innerHTML = `
                ${downloadButtonHTML}
                ${generateSectionHTML('single', portfolio.singles)}
                ${generateSectionHTML('parlay', portfolio.parlays)}
            `;
            
            // Trigger MathJax to render the formulas
            setTimeout(() => {
                if (window.MathJax && window.MathJax.typesetPromise) {
                    MathJax.typesetPromise([container]).then(() => {
                        console.log('MathJax recommendations rendered successfully');
                    }).catch((e) => console.error('MathJax error:', e));
                }
            }, 100);
        }

        function generateSectionHTML(type, bets) {
            if (!bets || bets.length === 0) return '';
            
            const title = type === 'single' ? getText('singleRecommendations') : getText('parlayRecommendations');
            const icon = type === 'single' ? 'üéØ' : 'üîó';

            const cardsHTML = bets.map(bet => type === 'single' ? generateSingleCardHTML(bet) : generateParlayCardHTML(bet)).join('');

            return `
                <div class="recommendation-section">
                    <h3 class="section-title">${icon} ${title}</h3>
                    <div class="recommendation-grid">
                        ${cardsHTML}
                    </div>
                </div>
            `;
        }

        function generateSingleCardHTML(bet) {
            const { sport, home_team, away_team, market_type, market_specifier, selection, odds, prob, edge, stake, ev } = bet;
            const sportConfig = SportConfigs[sport] || SportConfigs.unknown;
            const capital = parseFloat(document.getElementById('capital').value);

            const prettyMarketType = market_type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            const marketDisplay = `${prettyMarketType} ${market_specifier || ''}`.trim();
            
            // Accurate profit calculations
            const netOdds = odds - 1; // b in Kelly formula
            const grossWinnings = stake * odds; // Total return if win
            const netProfit = stake * netOdds; // Pure profit if win
            const impliedProb = 1 / odds; // Bookmaker's implied probability
            const roi = ((ev / stake) * 100);
            
            // PhD-level metrics
            const kellyPercentage = (bet.kellyFraction * 100).toFixed(2);
            const adjustedKellyPercentage = (bet.adjustedFraction * 100).toFixed(2);
            
            // Confidence level based on edge and probability
            let confidenceLevel = 'low';
            let confidenceColor = '#ef4444';
            if (edge > 0.15 && prob > 0.6) {
                confidenceLevel = 'high';
                confidenceColor = '#10b981';
            } else if (edge > 0.08 && prob > 0.45) {
                confidenceLevel = 'medium';
                confidenceColor = '#f59e0b';
            }

            return `
                <div class="recommendation-card single">
                    <div class="rec-header">
                        <div class="bet-confidence confidence-${confidenceLevel}" style="background: ${confidenceColor}; padding: 0.5rem 1rem; border-radius: 20px; font-weight: 700;">
                            ${getText('confidence')}: ${confidenceLevel.toUpperCase()} (${(prob * 100).toFixed(1)}%)
                    </div>
                    </div>
                    
                    <!-- MATCH INFORMATION -->
                    <div style="background: linear-gradient(135deg, rgba(6,182,212,0.15), rgba(6,182,212,0.05)); border: 1px solid rgba(6,182,212,0.3); border-radius: 15px; padding: 1.2rem; margin-bottom: 1rem;">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span style="font-size: 2rem;">${sportConfig.icon}</span>
                    <div>
                                <div style="color: #06b6d4; font-weight: 600; font-size: 0.9rem; margin-bottom: 0.3rem;">${getText('matchInfo')}</div>
                                <div style="font-size: 1.2rem; font-weight: 700; color: #e2e8f0;">${home_team} ${getText('vs')} ${away_team}</div>
                    </div>
                        </div>
                    </div>
                    
                    <!-- BETTING DETAILS -->
                    <div style="background: linear-gradient(135deg, rgba(139,92,246,0.15), rgba(139,92,246,0.05)); border: 1px solid rgba(139,92,246,0.3); border-radius: 15px; padding: 1.2rem; margin-bottom: 1rem;">
                        <div style="margin-bottom: 0.8rem;">
                            <span style="color: #8b5cf6; font-weight: 600;">${getText('betType')}:</span>
                            <span style="color: #e2e8f0; margin-left: 0.5rem;">${marketDisplay}</span>
                        </div>
                        <div>
                            <span style="color: #8b5cf6; font-weight: 600;">${getText('selection')}:</span>
                            <span style="font-size: 1.2rem; font-weight: 700; color: #10b981; margin-left: 0.5rem;">${selection}</span>
                        </div>
                    </div>
                    
                    <!-- STAKE DISPLAY (PROMINENT) -->
                    <div class="stake-display" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(139, 92, 246, 0.1)); border: 2px solid rgba(139, 92, 246, 0.5); border-radius: 15px; padding: 1.5rem; margin: 1rem 0; text-align: center; position: relative; overflow: hidden;">
                        <div style="color: #8b5cf6; font-weight: 600; margin-bottom: 0.5rem;">üíé ${getText('recommendedStake')}</div>
                        <div class="stake-amount" style="font-size: 3rem; font-weight: 900; color: #8b5cf6; text-shadow: 0 0 20px rgba(139, 92, 246, 0.5); position: relative;">‚Ç¨${stake}</div>
                        <div class="math-formula">
                            Kelly: ${(bet.kellyFraction * 100).toFixed(2)}% √ó ‚Ç¨${capital.toFixed(0)} = ‚Ç¨${stake}
                        </div>
                    </div>
                    
                    <!-- PROFIT DISPLAY (SECONDARY) -->
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.05)); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 12px; padding: 1rem; margin: 1rem 0; text-align: center;">
                        <div style="color: #059669; font-weight: 600; margin-bottom: 0.5rem;">üí∞ ${getText('profitIfWin')}</div>
                        <div style="font-size: 1.8rem; font-weight: 700; color: #10b981;">‚Ç¨${netProfit.toFixed(0)}</div>
                        <div class="math-formula">
                            ‚Ç¨${stake} √ó (${odds} - 1) = ‚Ç¨${stake} √ó ${netOdds.toFixed(2)} = ‚Ç¨${netProfit.toFixed(0)}
                        </div>
                    </div>
                    
                    <!-- DETAILED METRICS -->
                    <div style="margin-top: 1.5rem;">
                        <h4 style="color: #8b5cf6; margin-bottom: 1rem; font-size: 1.1rem;">üìä ${getText('detailedAnalysis')}</h4>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('tipOdds')} (Decimal)</span>
                            <span class="bet-metric-value" style="color: #06b6d4;">${odds.toFixed(2)}</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('ourProbability')}</span>
                            <span class="bet-metric-value" style="color: #10b981;">${(prob * 100).toFixed(1)}%</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('impliedProbability')}</span>
                            <span class="bet-metric-value" style="color: #f59e0b;">${(impliedProb * 100).toFixed(1)}%</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('valueEdge')}</span>
                            <span class="bet-metric-value" style="color: ${edge > 0.1 ? '#10b981' : '#f59e0b'};">${(edge * 100).toFixed(2)}%</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('recommendedStake')}</span>
                            <span class="bet-metric-value" style="color: #8b5cf6;">‚Ç¨${stake}</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('grossReturn')}</span>
                            <span class="bet-metric-value">‚Ç¨${grossWinnings.toFixed(0)}</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('expectedValue')} (EV)</span>
                            <span class="bet-metric-value" style="color: #6366f1;">${(ev/stake * 100).toFixed(2)}%</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('expectedROI')}</span>
                            <span class="bet-metric-value" style="color: ${roi > 15 ? '#10b981' : roi > 8 ? '#f59e0b' : '#ef4444'};">${roi.toFixed(1)}%</span>
                        </div>
                    </div>
                    
                    <!-- MATHEMATICAL FOUNDATION -->
                    <div style="margin-top: 1.5rem; padding: 1rem; background: rgba(99, 102, 241, 0.05); border-radius: 12px; border: 1px solid rgba(99, 102, 241, 0.2);">
                        <h5 style="color: #a5b4fc; margin-bottom: 0.75rem; font-size: 0.9rem;">üî¨ ${getText('mathematicalFoundation')}</h5>
                                                    <div style="font-size: 0.85rem; color: #c7d2fe; line-height: 1.6;">
                            <div>Kelly %: ${kellyPercentage}% ‚Üí Kiigaz√≠tott: ${adjustedKellyPercentage}%</div>
                            <div>K√©plet: \\(f^* = \\frac{p \\times (o-1) - (1-p)}{o-1} = \\frac{${prob.toFixed(3)} \\times ${netOdds.toFixed(2)} - ${(1-prob).toFixed(3)}}{${netOdds.toFixed(2)}}\\)</div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function generateParlayCardHTML(parlay) {
            const { legs, combinedOdds, combinedProb, edge, stake, ev } = parlay;
            const capital = parseFloat(document.getElementById('capital').value);

            // Accurate parlay profit calculations
            const netOdds = combinedOdds - 1;
            const grossWinnings = stake * combinedOdds;
            const netProfit = stake * netOdds;
            const impliedProb = 1 / combinedOdds;
            const roi = ((ev / stake) * 100);
            
            // Parlay confidence level (more conservative)
            let confidenceLevel = 'low';
            let confidenceColor = '#ef4444';
            if (edge > 0.25 && combinedProb > 0.3) {
                confidenceLevel = 'high';
                confidenceColor = '#10b981';
            } else if (edge > 0.15 && combinedProb > 0.2) {
                confidenceLevel = 'medium';
                confidenceColor = '#f59e0b';
            }

            const legsHTML = legs.map((leg, index) => {
                const { home_team, away_team, market_type, market_specifier, selection, odds, prob } = leg;
                const sportConfig = SportConfigs[leg.sport] || SportConfigs.unknown;
                const prettyMarket = market_type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                const marketDisplay = `${prettyMarket} ${market_specifier || ''}`.trim();
                return `
                    <div class="rec-parlay-leg" style="border-left: 3px solid ${index % 2 === 0 ? '#8b5cf6' : '#06b6d4'}; margin-bottom: 0.75rem;">
                        <div style="background: linear-gradient(135deg, rgba(6,182,212,0.1), rgba(6,182,212,0.05)); border-radius: 10px; padding: 0.75rem; margin-bottom: 0.5rem;">
                            <div style="display: flex; align-items: center; gap: 0.75rem;">
                                <span style="font-size: 1.5rem;">${sportConfig.icon}</span>
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; color: #06b6d4; font-size: 0.95rem;">
                                        ${home_team} ${getText('vs')} ${away_team}
                                    </div>
                                    <div style="color: #94a3b8; font-size: 0.85rem; margin-top: 0.25rem;">
                                        ${marketDisplay}: <strong style="color: #10b981;">${selection}</strong>
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="color: #06b6d4; font-weight: 700;">@ ${odds.toFixed(2)}</div>
                                    <div style="color: #f59e0b; font-size: 0.85rem;">${(prob*100).toFixed(1)}%</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            return `
                 <div class="recommendation-card parlay">
                    <div class="rec-header">
                        <div style="display: flex; align-items: center; justify-content: space-between;">
                            <span style="color: #f59e0b; font-weight: 700; font-size: 1.2rem;">
                                üîó ${getText('parlayBet')} (${legs.length}x)
                            </span>
                            <div class="bet-confidence confidence-${confidenceLevel}" style="background: ${confidenceColor}; padding: 0.5rem 1rem; border-radius: 20px; font-weight: 700;">
                                ${getText('confidence')}: ${confidenceLevel.toUpperCase()} (${(combinedProb * 100).toFixed(1)}%)
                    </div>
                        </div>
                    </div>
                    
                    <!-- PARLAY LEGS -->
                    <div style="margin: 1.5rem 0;">
                       ${legsHTML}
                    </div>
                    
                    <!-- STAKE DISPLAY (PROMINENT) -->
                    <div class="stake-display" style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(245, 158, 11, 0.1)); border: 2px solid rgba(245, 158, 11, 0.5); border-radius: 15px; padding: 1.5rem; margin: 1rem 0; text-align: center; position: relative; overflow: hidden;">
                        <div style="color: #f59e0b; font-weight: 600; margin-bottom: 0.5rem;">üíé ${getText('recommendedStake')}</div>
                        <div class="stake-amount" style="font-size: 3rem; font-weight: 900; color: #f59e0b; text-shadow: 0 0 20px rgba(245, 158, 11, 0.5); position: relative;">‚Ç¨${stake}</div>
                        <div class="math-formula">
                            Kombi Kelly: ${(parlay.kellyFraction * 100).toFixed(2)}% √ó ‚Ç¨${capital.toFixed(0)} = ‚Ç¨${stake}
                        </div>
                    </div>
                    
                    <!-- PROFIT DISPLAY (SECONDARY) -->
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.05)); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 12px; padding: 1rem; margin: 1rem 0; text-align: center;">
                        <div style="color: #059669; font-weight: 600; margin-bottom: 0.5rem;">üí∞ ${getText('profitIfWin')}</div>
                        <div style="font-size: 1.8rem; font-weight: 700; color: #10b981;">‚Ç¨${netProfit.toFixed(0)}</div>
                        <div class="math-formula">
                            ‚Ç¨${stake} √ó (${combinedOdds.toFixed(2)} - 1) = ‚Ç¨${stake} √ó ${netOdds.toFixed(2)} = ‚Ç¨${netProfit.toFixed(0)}
                        </div>
                    </div>
                    
                    <!-- DETAILED METRICS -->
                    <div style="margin-top: 1.5rem;">
                        <h4 style="color: #f59e0b; margin-bottom: 1rem; font-size: 1.1rem;">üìä ${getText('detailedAnalysis')}</h4>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('tipOdds')} (Combined)</span>
                            <span class="bet-metric-value" style="color: #06b6d4;">${combinedOdds.toFixed(2)}</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('ourProbability')}</span>
                            <span class="bet-metric-value" style="color: #10b981;">${(combinedProb * 100).toFixed(1)}%</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('impliedProbability')}</span>
                            <span class="bet-metric-value" style="color: #f59e0b;">${(impliedProb * 100).toFixed(1)}%</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('valueEdge')}</span>
                            <span class="bet-metric-value" style="color: ${edge > 0.2 ? '#10b981' : '#f59e0b'};">${(edge * 100).toFixed(2)}%</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('recommendedStake')}</span>
                            <span class="bet-metric-value" style="color: #8b5cf6;">‚Ç¨${stake}</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('grossReturn')}</span>
                            <span class="bet-metric-value">‚Ç¨${grossWinnings.toFixed(0)}</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('expectedValue')} (EV)</span>
                            <span class="bet-metric-value" style="color: #6366f1;">${(ev/stake * 100).toFixed(2)}%</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('expectedROI')}</span>
                            <span class="bet-metric-value" style="color: ${roi > 20 ? '#10b981' : roi > 10 ? '#f59e0b' : '#ef4444'};">${roi.toFixed(1)}%</span>
                        </div>
                    </div>
                    
                    <!-- MATHEMATICAL FOUNDATION -->
                    <div style="margin-top: 1.5rem; padding: 1rem; background: rgba(245, 158, 11, 0.05); border-radius: 12px; border: 1px solid rgba(245, 158, 11, 0.2);">
                        <h5 style="color: #fbbf24; margin-bottom: 0.75rem; font-size: 0.9rem;">üî¨ ${getText('mathematicalFoundation')}</h5>
                        <div style="font-size: 0.85rem; color: #fde68a; line-height: 1.6;">
                            <div>Kombin√°lt Val√≥sz√≠n≈±s√©g: \\(P = \\prod_{i=1}^{${legs.length}} p_i = ${legs.map(l => l.prob.toFixed(3)).join(' \\times ')} = ${combinedProb.toFixed(4)}\\)</div>
                            <div>Kombin√°lt Szorz√≥k: \\(O = \\prod_{i=1}^{${legs.length}} o_i = ${legs.map(l => l.odds.toFixed(2)).join(' \\times ')} = ${combinedOdds.toFixed(2)}\\)</div>
                        </div>
                    </div>
                </div>
            `;
        }

        function calculateMath() {
            try {
                const prob = parseFloat(document.getElementById('calcProb').value) / 100;
                const odds = parseFloat(document.getElementById('calcOdds').value);
                const capital = parseFloat(document.getElementById('calcCapital').value);
                const kellyMod = parseFloat(document.getElementById('calcKellyMod').value);
                
                // Validate inputs
                if (isNaN(prob) || isNaN(odds) || isNaN(capital) || isNaN(kellyMod)) {
                    showLocalizedNotification('fillFields', 'error');
                    return;
                }
                
                if (prob <= 0 || prob >= 1) {
                    showLocalizedNotification('invalidProbability', 'error');
                    return;
                }
                
                if (odds <= 1) {
                    showLocalizedNotification('invalidOdds', 'error');
                    return;
                }
                
                if (capital <= 0) {
                    showLocalizedNotification('invalidCapital', 'error');
                    return;
                }
                
                if (kellyMod <= 0 || kellyMod > 1) {
                    showLocalizedNotification('invalidKellyModifier', 'error');
                    return;
                }
                
                // Edge calculation
                const edge = (prob * odds) - 1;
                
                // Kelly calculation - simplified
                const b = odds - 1; // Net odds
                const q = 1 - prob;
                const kellyFraction = b > 0 ? (b * prob - q) / b : 0;
                const kellyPercent = Math.max(0, kellyFraction * kellyMod * 100);
                
                // Stake calculation with realistic rounding
                const rawStake = Math.max(0, kellyFraction * kellyMod * capital);
                const maxStake = capital * 0.05; // Never risk more than 5%
                const minStake = capital * 0.005; // Minimum 0.5%
                let stake = Math.min(rawStake, maxStake);
                
                // Round to realistic amounts
                if (stake > 100) {
                    stake = Math.round(stake / 10) * 10;
                } else if (stake > 50) {
                    stake = Math.round(stake / 5) * 5;
                } else if (stake > 20) {
                    stake = Math.round(stake / 2) * 2;
                } else {
                    stake = Math.round(stake);
                }
                
                // Check minimum stake
                if (stake < minStake && edge > 0) {
                    stake = 0; // Don't bet if below minimum
                }
                
                // Expected value
                const expectedValue = stake * edge;
                
                // Potential winnings
                const potentialWinnings = stake * b;
                
                // ROI
                const roi = stake > 0 ? (expectedValue / stake) * 100 : 0;
                
                // Display results
                if (document.getElementById('calcEdge')) {
                document.getElementById('calcEdge').textContent = `${(edge * 100).toFixed(2)}%`;
                }
                if (document.getElementById('calcKelly')) {
                document.getElementById('calcKelly').textContent = `${kellyPercent.toFixed(2)}%`;
                }
                if (document.getElementById('calcStake')) {
                    document.getElementById('calcStake').textContent = `‚Ç¨${stake.toFixed(0)}`;
                }
                if (document.getElementById('calcEV')) {
                document.getElementById('calcEV').textContent = `${(expectedValue/stake * 100).toFixed(2)}%`;
                }
                if (document.getElementById('calcWinnings')) {
                    document.getElementById('calcWinnings').textContent = `‚Ç¨${potentialWinnings.toFixed(0)}`;
                }
                if (document.getElementById('calcROI')) {
                    document.getElementById('calcROI').textContent = `${roi.toFixed(1)}%`;
                }
                
                if (document.getElementById('calcResults')) {
                document.getElementById('calcResults').style.display = 'block';
                    
                    // Trigger MathJax to render any formulas
                    if (window.MathJax) {
                        MathJax.typesetPromise().catch((e) => console.log('MathJax error:', e));
                    }
                }
                
                // Color coding based on edge
                const edgeElement = document.getElementById('calcEdge');
                if (edgeElement) {
                if (edge > 0.1) {
                    edgeElement.style.color = '#10b981'; // Green for high edge
                } else if (edge > 0.05) {
                    edgeElement.style.color = '#f59e0b'; // Yellow for medium edge
                } else if (edge > 0) {
                    edgeElement.style.color = '#06b6d4'; // Blue for low edge
                } else {
                    edgeElement.style.color = '#ef4444'; // Red for negative edge
                    }
                }
                
                // Simple recommendation text
                if (stake === 0) {
                    const reason = edge <= 0 ? getText('negativeEdge') : getText('belowMinStake');
                    console.log(`No bet recommended: ${reason}`);
                } else {
                    console.log(`Recommendation: Bet ‚Ç¨${stake} for expected profit of ‚Ç¨${expectedValue.toFixed(2)}`);
                }
            } catch (error) {
                console.error('Error calculating math:', error);
                showLocalizedNotification('calculationError', 'error');
            }
        }

        // --- INPUT MODE MANAGEMENT --- //
        function initializeInputModes() {
            // Initialize with image mode
            switchInputMode('image');
            
            // Initialize auto data search checkbox state
            const autoDataSearchCheckbox = document.getElementById('enableAutoDataSearch');
            const postAnalysisSearchCheckbox = document.getElementById('enablePostAnalysisSearch');
            autoDataSearchCheckbox.disabled = true;
            autoDataSearchCheckbox.parentElement.style.opacity = '0.5';
            postAnalysisSearchCheckbox.disabled = true;
            postAnalysisSearchCheckbox.parentElement.style.opacity = '0.5';
            
            // Add event listeners for AI model selection
            document.getElementById('aiModel').addEventListener('change', function() {
                const aiApiKeyGroup = document.getElementById('aiApiKeyGroup');
                const autoDataSearchCheckbox = document.getElementById('enableAutoDataSearch');
                const postAnalysisSearchCheckbox = document.getElementById('enablePostAnalysisSearch');
                
                if (this.value !== 'none') {
                    aiApiKeyGroup.style.display = 'block';
                    
                    // Enable auto data search only for Perplexity
                    if (this.value === 'perplexity') {
                        autoDataSearchCheckbox.disabled = false;
                        autoDataSearchCheckbox.parentElement.style.opacity = '1';
                        postAnalysisSearchCheckbox.disabled = false;
                        postAnalysisSearchCheckbox.parentElement.style.opacity = '1';
                    } else {
                        autoDataSearchCheckbox.disabled = true;
                        autoDataSearchCheckbox.checked = false;
                        autoDataSearchCheckbox.parentElement.style.opacity = '0.5';
                        postAnalysisSearchCheckbox.disabled = true;
                        postAnalysisSearchCheckbox.checked = false;
                        postAnalysisSearchCheckbox.parentElement.style.opacity = '0.5';
                    }
                } else {
                    aiApiKeyGroup.style.display = 'none';
                    autoDataSearchCheckbox.disabled = true;
                    autoDataSearchCheckbox.checked = false;
                    autoDataSearchCheckbox.parentElement.style.opacity = '0.5';
                    postAnalysisSearchCheckbox.disabled = true;
                    postAnalysisSearchCheckbox.checked = false;
                    postAnalysisSearchCheckbox.parentElement.style.opacity = '0.5';
                }
            });
        }
        
        function switchInputMode(mode) {
            const imageMode = document.getElementById('imageInputMode');
            const textMode = document.getElementById('textInputMode');
            const imageBtn = document.getElementById('imageInputBtn');
            const textBtn = document.getElementById('textInputBtn');
            
            if (mode === 'image') {
                imageMode.style.display = 'block';
                textMode.style.display = 'none';
                imageBtn.classList.remove('btn-secondary');
                imageBtn.classList.add('btn-primary');
                textBtn.classList.remove('btn-primary');
                textBtn.classList.add('btn-secondary');
            } else {
                imageMode.style.display = 'none';
                textMode.style.display = 'block';
                textBtn.classList.remove('btn-secondary');
                textBtn.classList.add('btn-primary');
                imageBtn.classList.remove('btn-primary');
                imageBtn.classList.add('btn-secondary');
            }
        }
        
        async function processBettingText() {
            const textInput = document.getElementById('bettingTextInput').value.trim();
            if (!textInput) {
                showLocalizedNotification('notificationEmptyTextInput', 'warning');
                return;
            }
            
            if (!AppState.apiConnected) {
                showLocalizedNotification('notificationSetupApiFirst', 'warning');
                UIManager.switchTab('setup');
                return;
            }
            
            showLocalizedLoading('loadingTextAnalysis', 'loadingExtractingBettingData');
            
            try {
                // Create a structured prompt for text analysis
                const prompt = `Analyze the following betting information and extract all relevant data in JSON format. 
                
TEXT TO ANALYZE:
${textInput}

Please extract and return in this JSON format:
{
  "extracted_data": {
    "sport_type": "football|tennis|basketball|hockey|baseball|americanfootball|other",
    "matches_detected": [
      { "home_team": "Team/Player name", "away_team": "Team/Player name", "league": "League name or null", "date": "Date if mentioned", "additional_info": "Any extra context" }
    ],
    "odds_found": [
      { "market_type": "match_result|total_goals_over_under|total_points_over_under|corners|cards|handicap", "market_specifier": "2.5|null", "values": { "Home": 1.90, "Draw": 3.20, "Away": 4.10 }, "applies_to_match_index": 0 }
    ],
    "additional_context": {
      "weather_conditions": "Description if mentioned",
      "player_injuries": ["Player names if mentioned"],
      "team_news": "Any team news or tactical information",
      "betting_tips": "Any analysis or reasoning provided"
    }
  }
}

Be thorough and extract all betting markets, odds, and contextual information.`;
                
                // Send to OpenAI API
                const response = await fetch(CONSTANTS.API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${AppState.apiKey}` },
                    body: JSON.stringify({
                        model: CONSTANTS.API_MODEL,
                        messages: [{ role: 'user', content: prompt }],
                        response_format: { type: "json_object" }
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                const extractedData = JSON.parse(data.choices[0].message.content);
                
                // Convert extracted data to image-like format for compatibility
                const syntheticImage = {
                    id: Date.now(),
                    name: `Text_Input_${Date.now()}`,
                    size: textInput.length,
                    sport: extractedData.extracted_data.sport_type || 'unknown',
                    status: 'completed',
                    analysisResult: {
                        sport_type: extractedData.extracted_data.sport_type,
                        matches_detected: extractedData.extracted_data.matches_detected || [],
                        odds_found: extractedData.extracted_data.odds_found || [],
                        additional_context: extractedData.extracted_data.additional_context || {}
                    },
                    error: null,
                    dataUrl: null, // No image data for text input
                    isTextInput: true
                };
                
                AppState.uploadedImages.push(syntheticImage);
                UIManager.displayUploadedImages();
                UIManager.updateActionButtons();
                
                showLocalizedNotification('notificationTextProcessed', 'success');
                
                // Clear text input
                document.getElementById('bettingTextInput').value = '';
                
                // Automatically process if this is the first data
                if (AppState.uploadedImages.length === 1) {
                    setTimeout(() => {
                        processAndDisplayAnalysisResults();
                        UIManager.switchTab('analysis');
                    }, 1000);
                }
                
            } catch (error) {
                console.error('Error processing text:', error);
                showLocalizedNotification('notificationTextProcessingError', 'error', { error: error.message });
            } finally {
                UIManager.hideLoading();
            }
        }

        // --- ADVANCED MATHEMATICAL ADJUSTMENTS --- //
        // Enhanced multilingual keyword recognition system
        const KeywordMatcher = {
            // Weather-related keywords (Hungarian and English)
            weather: {
                temperature: ['h≈ëm√©rs√©klet', 'temperature', 'temp', 'celsius', 'fahrenheit', 'fok', 'degree'],
                wind: ['sz√©l', 'wind', 'sz√©lsebess√©g', 'wind_speed', 'windspeed', 'sz√©lir√°ny', 'wind_direction'],
                rain: ['es≈ë', 'rain', 'precipitation', 'csapad√©k', 'es√©ly', 'probability', 'val√≥sz√≠n≈±s√©g'],
                humidity: ['p√°ratartalom', 'humidity', 'nedvess√©g', 'moisture'],
                conditions: ['k√∂r√ºlm√©nyek', 'conditions', 'id≈ëj√°r√°s', 'weather', 'felt√©telek']
            },
            
            // Player-related keywords
            players: {
                missing: ['hi√°nyz√≥', 'missing', 'absent', 'unavailable', 's√©r√ºlt', 'injured', 'eltiltott', 'suspended'],
                injury: ['s√©r√ºl√©s', 'injury', 'hurt', 'strain', 'sprain', 'tear', 'contusion', 'inflammation'],
                suspension: ['eltilt√°s', 'suspension', 'banned', 'card', 'lap', 'yellow', 'red', 's√°rga', 'piros'],
                key_player: ['kulcsj√°t√©kos', 'key_player', 'star', 'important', 'crucial', 'essential', 'main']
            },
            
            // Motivation keywords
            motivation: {
                high: ['magas', 'high', 'strong', 'er≈ës', 'motivated', 'motiv√°lt', 'determined'],
                league_position: ['liga', 'league', 'position', 'poz√≠ci√≥', 'helyez√©s', 'standing', 'rank'],
                playoff: ['playoff', 'r√°j√°tsz√°s', 'elimination', 'kies√©s', 'qualification', 'kvalifik√°ci√≥']
            },
            
            // Numerical extractors
            extractNumber: function(text, keywords) {
                if (!text) return null;
                const textLower = text.toString().toLowerCase();
                
                // Look for numbers near keywords
                for (const keyword of keywords) {
                    const regex = new RegExp(`(${keyword})[^\\d]*([\\d\\.\\,]+)`, 'i');
                    const match = textLower.match(regex);
                    if (match) {
                        return parseFloat(match[2].replace(',', '.'));
                    }
                    
                    // Reverse pattern: number before keyword
                    const reverseRegex = new RegExp(`([\\d\\.\\,]+)[^\\d]*${keyword}`, 'i');
                    const reverseMatch = textLower.match(reverseRegex);
                    if (reverseMatch) {
                        return parseFloat(reverseMatch[1].replace(',', '.'));
                    }
                }
                
                // Fallback: direct number extraction if it's already a number
                const num = parseFloat(text);
                return isNaN(num) ? null : num;
            },
            
            // Impact scale converter (handles text to 1-100 scale)
            convertImpactScale: function(value) {
                if (typeof value === 'number') return Math.max(1, Math.min(100, value));
                if (!value) return 50; // Default neutral
                
                const textLower = value.toString().toLowerCase();
                
                // Severity keywords (Hungarian and English)
                if (textLower.match(/(s√∫lyos|severe|serious|critical|kritikus|nagy)/)) return 20;
                if (textLower.match(/(k√∂zepes|moderate|medium|√°tlagos)/)) return 50;
                if (textLower.match(/(enyhe|mild|light|kis|minor)/)) return 75;
                if (textLower.match(/(minim√°lis|minimal|negligible|elhanyagolhat√≥)/)) return 90;
                
                // Try to extract percentage
                const percentMatch = textLower.match(/(\d+)%/);
                if (percentMatch) return parseInt(percentMatch[1]);
                
                // Try to extract direct number
                const numberMatch = textLower.match(/(\d+)/);
                if (numberMatch) {
                    const num = parseInt(numberMatch[1]);
                    return num > 100 ? 50 : num; // Cap at 100, default to 50 if too high
                }
                
                return 50; // Default neutral if no match
            },
            
            // Boolean converter for yes/no, true/false in multiple languages
            convertBoolean: function(value) {
                if (typeof value === 'boolean') return value;
                if (!value) return false;
                
                const textLower = value.toString().toLowerCase();
                const trueWords = ['true', 'yes', 'igen', 'igaz', 'van', 'magas', 'high', '1'];
                const falseWords = ['false', 'no', 'nem', 'hamis', 'nincs', 'alacsony', 'low', '0'];
                
                if (trueWords.some(word => textLower.includes(word))) return true;
                if (falseWords.some(word => textLower.includes(word))) return false;
                
                return false; // Default to false if unclear
            }
        };

        function applyAdvancedAdjustments(baseProb, matchAnalysis, marketType) {
            if (!baseProb || baseProb <= 0) return baseProb;
            
            let adjustedProb = baseProb;
            
            // Enhanced weather adjustments with multilingual support
            if (matchAnalysis.weather_conditions || matchAnalysis.weather_analysis) {
                adjustedProb = applyEnhancedWeatherAnalysis(adjustedProb, matchAnalysis, marketType);
            }
            
            // Venue conditions for indoor sports (no weather impact)
            if (matchAnalysis.venue_conditions) {
                adjustedProb = applyEnhancedVenueAnalysis(adjustedProb, matchAnalysis.venue_conditions, marketType);
            }
            
            // Enhanced missing players analysis with multilingual support
            if (matchAnalysis.missing_players_analysis || matchAnalysis.team_a_missing || matchAnalysis.team_b_missing) {
                adjustedProb = applyEnhancedMissingPlayersAnalysis(adjustedProb, matchAnalysis, marketType);
            }
            
            // Enhanced motivation analysis
            if (matchAnalysis.motivation_analysis) {
                adjustedProb = applyEnhancedMotivationAnalysis(adjustedProb, matchAnalysis.motivation_analysis, marketType);
            }
            
            // Tennis-specific analysis (surface, injuries, venue)
            if (matchAnalysis.tennis_analysis) {
                adjustedProb = applyEnhancedTennisAnalysis(adjustedProb, matchAnalysis.tennis_analysis, marketType);
            }
            
            // Tactical/formation adjustments
            if (matchAnalysis.tactical_analysis) {
                adjustedProb = applyTacticalAdjustments(adjustedProb, matchAnalysis.tactical_analysis, marketType);
            }
            
            // Ensure probability remains within bounds [0.01, 0.99]
            return Math.max(0.01, Math.min(0.99, adjustedProb));
        }
        
        // Enhanced weather analysis with multilingual support
        function applyEnhancedWeatherAnalysis(prob, matchAnalysis, marketType) {
            let adjustment = 1.0;
            
            // Combine weather_conditions and weather_analysis
            const weatherData = matchAnalysis.weather_analysis || matchAnalysis.weather_conditions || {};
            
            // Extract temperature with multilingual support
            const temperature = KeywordMatcher.extractNumber(
                weatherData.temperature || weatherData.h≈ëm√©rs√©klet || weatherData.temp,
                KeywordMatcher.weather.temperature
            );
            
            // Extract wind speed
            const windSpeed = KeywordMatcher.extractNumber(
                weatherData.wind_speed || weatherData.sz√©lsebess√©g || weatherData.wind,
                KeywordMatcher.weather.wind
            );
            
            // Extract precipitation probability
            const rainProb = KeywordMatcher.extractNumber(
                weatherData.precipitation_probability || weatherData.es≈ë_val√≥sz√≠n≈±s√©g || weatherData.rain || weatherData.es√©ly,
                KeywordMatcher.weather.rain
            );
            
            // Extract humidity
            const humidity = KeywordMatcher.extractNumber(
                weatherData.humidity || weatherData.p√°ratartalom,
                KeywordMatcher.weather.humidity
            );
            
            // Weather impact scales (1-100 system)
            const teamAImpact = KeywordMatcher.convertImpactScale(
                weatherData.team_a_weather_impact || weatherData.player_a_weather_impact || 50
            );
            const teamBImpact = KeywordMatcher.convertImpactScale(
                weatherData.team_b_weather_impact || weatherData.player_b_weather_impact || 50
            );
            
            // Apply weather effects only for outdoor sports
            const venueType = matchAnalysis.venue_type || matchAnalysis.venue_conditions?.venue_type || 'outdoor';
            if (venueType.toLowerCase() === 'indoor') {
                return prob; // No weather impact for indoor sports
            }
            
            // Temperature effects (optimal around 20¬∞C)
            if (temperature !== null) {
                const tempDeviation = Math.abs(temperature - 20) / 10;
                const tempEffect = Math.min(tempDeviation * 0.03, 0.08); // Max 8% adjustment
                adjustment *= (1 - tempEffect);
            }
            
            // Wind effects (affects aerial play)
            if (windSpeed !== null && windSpeed > 5) {
                const windEffect = Math.min(windSpeed / 20, 0.12); // Max 12% adjustment
                if (marketType === 'corners' || marketType.includes('corner')) {
                    adjustment *= (1 + windEffect); // More corners in windy conditions
                } else if (marketType.includes('goals') || marketType.includes('total')) {
                    adjustment *= (1 - windEffect * 0.5); // Slightly fewer goals
                }
            }
            
            // Rain effects (affects ball control)
            if (rainProb !== null && rainProb > 30) {
                const rainEffect = Math.min(rainProb / 200, 0.1); // Max 10% adjustment
                if (marketType === 'cards' || marketType.includes('card')) {
                    adjustment *= (1 + rainEffect); // More fouls in wet conditions
                } else if (marketType.includes('total')) {
                    adjustment *= (1 - rainEffect); // Lower scoring in rain
                }
            }
            
            // Team-specific weather impact (1-100 scale)
            const avgWeatherImpact = (teamAImpact + teamBImpact) / 2;
            const weatherMultiplier = 1 + Math.max(-0.15, Math.min(0.15, (avgWeatherImpact - 50) / 100 * 0.3));
            adjustment *= weatherMultiplier;
            
            return prob * adjustment;
        }
        
        function applyWeatherAdjustments(prob, weatherData, marketType) {
            if (!weatherData || typeof weatherData !== 'object') return prob;
            
            let adjustment = 1.0;
            
            // Wind effect (primarily affects aerial play and passing accuracy)
            if (weatherData.wind_speed) {
                const windEffect = Math.min(weatherData.wind_speed / 10, 0.15); // Max 15% adjustment
                if (marketType === 'corners') {
                    adjustment *= (1 + windEffect); // More corners in windy conditions
                } else if (marketType.includes('goals') || marketType.includes('points')) {
                    adjustment *= (1 - windEffect * 0.5); // Slightly fewer goals
                }
            }
            
            // Rain effect (affects ball control and playing style)
            if (weatherData.precipitation) {
                const rainEffect = Math.min(weatherData.precipitation / 5, 0.1); // Max 10% adjustment
                if (marketType === 'cards') {
                    adjustment *= (1 + rainEffect); // More fouls in wet conditions
                } else if (marketType.includes('total')) {
                    adjustment *= (1 - rainEffect); // Lower scoring in rain
                }
            }
            
            // Temperature effect (affects player performance and ball physics)
            if (weatherData.temperature) {
                const tempDeviation = Math.abs(weatherData.temperature - 20) / 10; // Optimal at 20¬∞C
                const tempEffect = Math.min(tempDeviation * 0.05, 0.08); // Max 8% adjustment
                adjustment *= (1 - tempEffect);
            }
            
            return prob * adjustment;
        }
        
        function applyAdvancedWeatherAnalysis(prob, weatherAnalysis, marketType) {
            if (!weatherAnalysis || typeof weatherAnalysis !== 'object') return prob;
            
            let adjustment = 1.0;
            
            // Egys√©ges 1-100 sk√°l√°s id≈ëj√°r√°s hat√°s CSAK SZABADT√âRI SPORTOKRA (max 15% kiigaz√≠t√°s)
            if (weatherAnalysis.team_a_weather_impact && weatherAnalysis.team_b_weather_impact) {
                const teamAImpact = parseFloat(weatherAnalysis.team_a_weather_impact) || 50;
                const teamBImpact = parseFloat(weatherAnalysis.team_b_weather_impact) || 50;
                
                // 1-100 sk√°la -> max 15% kiigaz√≠t√°s
                // 50 = semleges (0%), 1 = -15%, 100 = +15%
                const teamAMultiplier = 1 + Math.max(-0.15, Math.min(0.15, (teamAImpact - 50) / 100 * 0.3)); // Max 15%
                const teamBMultiplier = 1 + Math.max(-0.15, Math.min(0.15, (teamBImpact - 50) / 100 * 0.3)); // Max 15%
                
                // Sportspecifikus alkalmaz√°s CSAK szabadt√©ri sportokra
                if (marketType === 'match_result') {
                    adjustment *= Math.sqrt(teamAMultiplier * teamBMultiplier); // Kiegyens√∫lyozott
                } else if (marketType === 'corners') {
                    const avgImpact = (teamAMultiplier + teamBMultiplier) / 2;
                    adjustment *= avgImpact;
                } else if (marketType === 'cards') {
                    const weatherStress = 2 - (teamAMultiplier + teamBMultiplier) / 2;
                    adjustment *= Math.min(1.15, weatherStress); // Cap at 15%
                } else if (marketType.includes('total')) {
                    const avgImpact = (teamAMultiplier + teamBMultiplier) / 2;
                    adjustment *= avgImpact;
                }
            }
            
            return prob * adjustment;
        }
        
        function applyVenueConditionsAnalysis(prob, venueConditions, marketType) {
            if (!venueConditions || typeof venueConditions !== 'object') return prob;
            
            let adjustment = 1.0;
            
            // Belt√©ri sportok eset√©n minim√°lis venue hat√°s (max 2-3%)
            // Pl. arena akusztika, p√°lya min≈ës√©g, vil√°g√≠t√°s
            if (venueConditions.arena_conditions || venueConditions.court_conditions) {
                // Csak elhanyagolhat√≥ hat√°s, mert kontroll√°lt k√∂r√ºlm√©nyek
                if (marketType === 'match_result') {
                    // Minim√°lis home court advantage pici n√∂vel√©se
                    adjustment *= 1.01; // 1% n√∂vel√©s
                } else if (marketType.includes('total')) {
                    // J√≥ arena k√∂r√ºlm√©nyek kiss√© n√∂velhetik a teljes√≠tm√©nyt
                    adjustment *= 1.005; // 0.5% n√∂vel√©s
                }
            }
            
            return prob * adjustment;
        }
        
        function applyTennisSpecificAnalysis(prob, tennisAnalysis, marketType) {
            if (!tennisAnalysis || typeof tennisAnalysis !== 'object') return prob;
            
            let adjustment = 1.0;
            
            // P√°lya t√≠pus hat√°sa (surface advantage)
            if (tennisAnalysis.surface_advantage) {
                const playerAAdvantage = parseFloat(tennisAnalysis.surface_advantage.player_a_advantage) || 50;
                const playerBAdvantage = parseFloat(tennisAnalysis.surface_advantage.player_b_advantage) || 50;
                
                // 1-100 sk√°la -> max 20% hat√°s p√°lyat√≠pusra
                const playerAMultiplier = 1 + Math.max(-0.2, Math.min(0.2, (playerAAdvantage - 50) / 100 * 0.4)); // Max 20%
                const playerBMultiplier = 1 + Math.max(-0.2, Math.min(0.2, (playerBAdvantage - 50) / 100 * 0.4)); // Max 20%
                
                if (marketType === 'match_result') {
                    adjustment *= Math.sqrt(playerAMultiplier * playerBMultiplier); // Kiegyens√∫lyozott
                }
            }
            
            // Friss s√©r√ºl√©sek hat√°sa
            if (tennisAnalysis.recent_injuries) {
                const processPlayerInjury = (injury) => {
                    if (!injury) return 1.0;
                    
                    const severity = parseFloat(injury.injury_severity) || 50;
                    const recoveryPercent = parseFloat(injury.recovery_status?.replace('%', '')) || 100;
                    
                    // S√∫lyoss√°g: 1-100 sk√°la (1=s√∫lyos, 100=enyhe)
                    // Fel√©p√ºl√©s: 0-100% (100% = teljesen fel√©p√ºlt)
                    const injuryImpact = Math.max(0, (50 - severity) / 100); // Max 50% impact
                    const recoveryFactor = recoveryPercent / 100; // 0-1 sk√°la
                    
                    const finalImpact = injuryImpact * (1 - recoveryFactor); // Fel√©p√ºl√©s cs√∂kkenti a hat√°st
                    const cappedImpact = Math.max(-0.25, Math.min(0, -finalImpact)); // Max 25% negat√≠v hat√°s
                    
                    return 1 + cappedImpact;
                };
                
                const playerAInjuryMultiplier = processPlayerInjury(tennisAnalysis.recent_injuries.player_a_injury);
                const playerBInjuryMultiplier = processPlayerInjury(tennisAnalysis.recent_injuries.player_b_injury);
                
                if (marketType === 'match_result') {
                    adjustment *= Math.sqrt(playerAInjuryMultiplier * playerBInjuryMultiplier);
                }
            }
            
            // Helysz√≠n hat√°sa (indoor vs outdoor)
            if (tennisAnalysis.venue_type === 'indoor') {
                // Belt√©ri tenisz: kontroll√°lt k√∂r√ºlm√©nyek, minim√°lis hat√°s
                adjustment *= 1.01; // 1% n√∂vel√©s stabilit√°s√©rt
            } else if (tennisAnalysis.venue_type === 'outdoor') {
                // Szabadt√©ri tenisz: id≈ëj√°r√°s hat√°s m√°r k√ºl√∂n kezelve
                // Itt csak a helysz√≠n stabilit√°s hat√°sa
                adjustment *= 0.98; // 2% cs√∂kken√©s a v√°ltoz√≥ k√∂r√ºlm√©nyek√©rt
            }
            
            return prob * adjustment;
        }
        
        // Enhanced missing players analysis with multilingual support
        function applyEnhancedMissingPlayersAnalysis(prob, matchAnalysis, marketType) {
            let adjustment = 1.0;
            
            // Collect all missing players from different sources
            const allMissingPlayers = [
                ...(matchAnalysis.missing_players_analysis?.team_a_missing || []),
                ...(matchAnalysis.missing_players_analysis?.team_b_missing || []),
                ...(matchAnalysis.team_a_missing || []),
                ...(matchAnalysis.team_b_missing || []),
                ...(matchAnalysis.missing_players_analysis?.player_a_issues || []),
                ...(matchAnalysis.missing_players_analysis?.player_b_issues || [])
            ];
            
            if (allMissingPlayers.length === 0) return prob;
            
            const processPlayerImpact = (player) => {
                if (!player) return 1.0;
                
                // Extract impact scale with multilingual support
                let impactScale = KeywordMatcher.convertImpactScale(
                    player.impact_scale || player.hat√°s || player.impact || player.severity
                );
                
                // Determine if key player with multilingual support
                const isKeyPlayer = KeywordMatcher.convertBoolean(
                    player.is_key_player || player.kulcsj√°t√©kos || player.key || player.important
                );
                
                // Extract injury/suspension type
                const injuryType = (player.injury_type || player.s√©r√ºl√©s_t√≠pus || player.type || '').toLowerCase();
                const isInjury = KeywordMatcher.players.injury.some(keyword => 
                    injuryType.includes(keyword.toLowerCase())
                );
                const isSuspension = KeywordMatcher.players.suspension.some(keyword => 
                    injuryType.includes(keyword.toLowerCase())
                );
                
                // Adjust impact based on player importance and type
                let maxImpact = isKeyPlayer ? 0.30 : 0.15; // Key players: max 30%, others: max 15%
                
                // Suspension typically has immediate full impact
                if (isSuspension) {
                    maxImpact = isKeyPlayer ? 0.35 : 0.20;
                }
                
                // Convert 1-100 scale to impact percentage
                // Lower numbers = worse impact (inverted scale)
                const rawImpact = (100 - impactScale) / 100; // 20 becomes 0.80 (80% negative impact)
                const cappedImpact = Math.max(-maxImpact, Math.min(0, -rawImpact * maxImpact));
                
                return 1 + cappedImpact; // 1 - 0.30 = 0.70 (30% weaker)
            };
            
            // Group players by team if possible
            const teamAPlayers = [
                ...(matchAnalysis.missing_players_analysis?.team_a_missing || []),
                ...(matchAnalysis.team_a_missing || [])
            ];
            const teamBPlayers = [
                ...(matchAnalysis.missing_players_analysis?.team_b_missing || []),
                ...(matchAnalysis.team_b_missing || [])
            ];
            
            // Calculate team adjustments
            let teamAAdjustment = 1.0;
            let teamBAdjustment = 1.0;
            
            teamAPlayers.forEach(player => {
                teamAAdjustment *= processPlayerImpact(player);
            });
            
            teamBPlayers.forEach(player => {
                teamBAdjustment *= processPlayerImpact(player);
            });
            
            // Apply market-specific adjustments
            if (marketType === 'match_result') {
                // For match result, balance both teams' impacts
                adjustment *= Math.sqrt(teamAAdjustment * teamBAdjustment);
            } else if (marketType.includes('total')) {
                // For totals, average both teams (missing players usually reduce scoring)
                adjustment *= (teamAAdjustment + teamBAdjustment) / 2;
            } else if (marketType === 'corners' || marketType === 'cards') {
                // Missing players can affect set pieces and aggression
                adjustment *= (teamAAdjustment + teamBAdjustment) / 2;
            } else {
                // Default: balanced impact
                adjustment *= Math.sqrt(teamAAdjustment * teamBAdjustment);
            }
            
            return prob * adjustment;
        }
        
        function applyMissingPlayersAnalysis(prob, missingPlayersAnalysis, marketType, teamContext) {
            if (!missingPlayersAnalysis || typeof missingPlayersAnalysis !== 'object') return prob;
            
            let adjustment = 1.0;
            
            // Egys√©ges hi√°nyz√≥ j√°t√©kosok hat√°sa minden sportra
            const processTeamMissing = (missingPlayers) => {
                if (!missingPlayers || !Array.isArray(missingPlayers)) return 1.0;
                
                let teamAdjustment = 1.0;
                missingPlayers.forEach(player => {
                    if (player.impact_scale !== undefined) {
                        const impact = parseFloat(player.impact_scale) || 50;
                        const isKeyPlayer = player.is_key_player === true;
                        
                        // Egys√©ges s√∫lyoz√°s: kulcsj√°t√©kos max 30%, nem kulcs max 10%
                        const maxImpact = isKeyPlayer ? 0.30 : 0.10;
                        
                        // 1-100 sk√°la -> sz√°zal√©kos hat√°s (50 = semleges)
                        const rawImpact = (50 - impact) / 100; // 25 -> 0.25 (25% gyeng√©bb)
                        const cappedImpact = Math.max(-maxImpact, Math.min(maxImpact, rawImpact));
                        
                        const playerMultiplier = 1 + cappedImpact; // 1 - 0.25 = 0.75 (25% gyeng√©bb)
                        teamAdjustment *= playerMultiplier;
                    }
                });
                return teamAdjustment;
            };
            
            // Minden sport t√≠pus√∫ missing players list√°j√°t feldolgozza
            const teamAMissing = processTeamMissing(missingPlayersAnalysis.team_a_missing || missingPlayersAnalysis.player_a_issues || []);
            const teamBMissing = processTeamMissing(missingPlayersAnalysis.team_b_missing || missingPlayersAnalysis.player_b_issues || []);
            
            // Sportspecifikus alkalmaz√°s
            if (marketType === 'match_result') {
                adjustment *= Math.sqrt(teamAMissing * teamBMissing); // Kiegyens√∫lyozott
            } else if (marketType.includes('total')) {
                adjustment *= (teamAMissing + teamBMissing) / 2; // √Åtlagos hat√°s total piacokra
            } else if (marketType === 'corners') {
                adjustment *= (teamAMissing + teamBMissing) / 2; // √Åtlagos hat√°s sz√∂gletekre
            }
            
            return prob * adjustment;
        }
        
        function applyInjuryAdjustments(prob, injuryData, marketType) {
            if (!injuryData || !Array.isArray(injuryData)) return prob;
            
            let adjustment = 1.0;
            
            injuryData.forEach(injury => {
                if (!injury.player_importance) return;
                
                // Player importance scale: 0.1 (bench) to 1.0 (star player)
                const importance = parseFloat(injury.player_importance) || 0.5;
                const injuryImpact = importance * 0.1; // Max 10% per key player
                
                if (injury.position === 'goalkeeper' && marketType.includes('total')) {
                    adjustment *= (1 + injuryImpact); // Weaker keeper = more goals
                } else if (injury.position === 'striker' && marketType.includes('goals')) {
                    adjustment *= (1 - injuryImpact); // Missing striker = fewer goals
                } else if (injury.position === 'defender' && marketType === 'corners') {
                    adjustment *= (1 + injuryImpact * 0.5); // Weaker defense = more corners
                }
            });
            
            return prob * adjustment;
        }
        
        function applyTacticalAdjustments(prob, tacticalData, marketType) {
            if (!tacticalData || typeof tacticalData !== 'object') return prob;
            
            let adjustment = 1.0;
            
            // Formation analysis (e.g., 3-5-2 vs 4-4-2)
            if (tacticalData.formation_impact) {
                const formationFactor = parseFloat(tacticalData.formation_impact) || 1.0;
                if (marketType.includes('goals') && formationFactor > 1.1) {
                    adjustment *= 1.05; // Attacking formation
                } else if (marketType.includes('goals') && formationFactor < 0.9) {
                    adjustment *= 0.95; // Defensive formation
                }
            }
            
            // Playing style (possession vs counter-attack)
            if (tacticalData.playing_style) {
                if (tacticalData.playing_style.includes('possession') && marketType === 'corners') {
                    adjustment *= 0.9; // Possession play = fewer corners
                } else if (tacticalData.playing_style.includes('counter') && marketType.includes('cards')) {
                    adjustment *= 1.1; // Counter-attacking = more fouls
                }
            }
            
            return prob * adjustment;
        }
        
        // Enhanced venue conditions analysis
        function applyEnhancedVenueAnalysis(prob, venueConditions, marketType) {
            let adjustment = 1.0;
            
            const venueType = venueConditions.venue_type || 'outdoor';
            
            if (venueType.toLowerCase() === 'indoor') {
                // Indoor venues: minimal environmental impact, focus on venue quality
                const courtConditions = venueConditions.court_conditions || venueConditions.arena_conditions || 'good';
                const homeAdvantage = KeywordMatcher.extractNumber(
                    venueConditions.home_court_advantage || venueConditions.home_advantage,
                    ['advantage', 'el≈ëny', 'benefit']
                ) || 0;
                
                // Small positive adjustment for excellent conditions
                if (courtConditions.toLowerCase().includes('excellent') || courtConditions.toLowerCase().includes('kiv√°l√≥')) {
                    adjustment *= 1.02; // 2% improvement
                }
                
                // Home advantage factor (typically small for indoor sports)
                if (homeAdvantage > 0) {
                    const homeBonus = Math.min(homeAdvantage / 100, 0.05); // Max 5% home advantage
                    if (marketType === 'match_result') {
                        adjustment *= (1 + homeBonus);
                    }
                }
            } else {
                // Outdoor venues: consider field conditions, dimensions, altitude
                const altitude = KeywordMatcher.extractNumber(
                    venueConditions.altitude || venueConditions.tengerszint,
                    ['altitude', 'elevation', 'magass√°g', 'meter', 'feet']
                );
                
                // Altitude effects (higher altitude = more offense in some sports)
                if (altitude && altitude > 1000) {
                    const altitudeEffect = Math.min((altitude - 1000) / 10000, 0.08); // Max 8% at very high altitude
                    if (marketType.includes('total') || marketType.includes('goals')) {
                        adjustment *= (1 + altitudeEffect); // More scoring at altitude
                    }
                }
            }
            
            return prob * adjustment;
        }
        
        // Enhanced motivation analysis with multilingual support
        function applyEnhancedMotivationAnalysis(prob, motivationAnalysis, marketType) {
            let adjustment = 1.0;
            
            // Extract motivation data for both teams/players
            const teamAMotivation = motivationAnalysis.home_team_motivation || motivationAnalysis.player1_motivation || {};
            const teamBMotivation = motivationAnalysis.away_team_motivation || motivationAnalysis.player2_motivation || {};
            
            const processTeamMotivation = (teamMotiv) => {
                if (!teamMotiv) return 1.0;
                
                // Extract motivation scale
                const motivationScale = KeywordMatcher.convertImpactScale(
                    teamMotiv.motivation_scale || teamMotiv.motiv√°ci√≥ || 50
                );
                
                // Extract high motivation boolean
                const isHighMotivation = KeywordMatcher.convertBoolean(
                    teamMotiv.is_high_motivation || teamMotiv.magas_motiv√°ci√≥
                );
                
                // League position impact
                const leaguePosition = KeywordMatcher.extractNumber(
                    teamMotiv.league_position || teamMotiv.division_standing || teamMotiv.poz√≠ci√≥,
                    KeywordMatcher.motivation.league_position
                );
                
                // Playoff implications
                const playoffImplications = KeywordMatcher.convertBoolean(
                    teamMotiv.playoff_race || teamMotiv.r√°j√°tsz√°s || teamMotiv.european_competition
                );
                
                let teamAdjustment = 1.0;
                
                // Base motivation scale effect (50 = neutral, 100 = max motivated)
                if (isHighMotivation && motivationScale > 50) {
                    const motivationBoost = Math.max(0, Math.min(0.15, (motivationScale - 50) / 100 * 0.3)); // Max 15%
                    teamAdjustment *= (1 + motivationBoost);
                }
                
                // League position pressure (lower position = higher desperation)
                if (leaguePosition && leaguePosition > 10) {
                    const desperationFactor = Math.min((leaguePosition - 10) / 10, 0.1); // Max 10% desperation boost
                    teamAdjustment *= (1 + desperationFactor);
                }
                
                // Playoff implications boost
                if (playoffImplications) {
                    teamAdjustment *= 1.05; // 5% boost for playoff implications
                }
                
                return teamAdjustment;
            };
            
            const teamAAdjustment = processTeamMotivation(teamAMotivation);
            const teamBAdjustment = processTeamMotivation(teamBMotivation);
            
            // Apply market-specific motivation effects
            if (marketType === 'match_result') {
                // For match results, apply balanced motivation effect
                adjustment *= Math.sqrt(teamAAdjustment * teamBAdjustment);
            } else if (marketType === 'cards' || marketType.includes('card')) {
                // High motivation can lead to more aggressive play
                const avgMotivation = (teamAAdjustment + teamBAdjustment) / 2;
                adjustment *= Math.min(1.15, avgMotivation * 1.1); // Cap at 15% increase
            } else if (marketType.includes('total') || marketType.includes('goals')) {
                // Motivation can affect scoring
                const avgMotivation = (teamAAdjustment + teamBAdjustment) / 2;
                adjustment *= avgMotivation;
            } else if (marketType === 'corners') {
                // Motivated teams attack more
                const avgMotivation = (teamAAdjustment + teamBAdjustment) / 2;
                adjustment *= Math.min(1.12, avgMotivation * 1.05); // Cap at 12% increase
            }
            
            return prob * adjustment;
        }
        
        // Enhanced tennis analysis with multilingual support
        function applyEnhancedTennisAnalysis(prob, tennisAnalysis, marketType) {
            let adjustment = 1.0;
            
            // Surface advantage analysis
            if (tennisAnalysis.surface_advantage) {
                const playerAAdvantage = KeywordMatcher.convertImpactScale(
                    tennisAnalysis.surface_advantage.player_a_advantage || 50
                );
                const playerBAdvantage = KeywordMatcher.convertImpactScale(
                    tennisAnalysis.surface_advantage.player_b_advantage || 50
                );
                
                // Surface effects (bigger impact in tennis than other sports)
                const playerAMultiplier = 1 + Math.max(-0.25, Math.min(0.25, (playerAAdvantage - 50) / 100 * 0.5));
                const playerBMultiplier = 1 + Math.max(-0.25, Math.min(0.25, (playerBAdvantage - 50) / 100 * 0.5));
                
                if (marketType === 'match_result') {
                    adjustment *= Math.sqrt(playerAMultiplier * playerBMultiplier);
                }
            }
            
            // Recent injuries analysis
            if (tennisAnalysis.recent_injuries) {
                const processPlayerInjury = (injury) => {
                    if (!injury) return 1.0;
                    
                    const severity = KeywordMatcher.convertImpactScale(injury.injury_severity || 50);
                    const recoveryPercent = KeywordMatcher.extractNumber(
                        injury.recovery_status,
                        ['percent', '%', 'sz√°zal√©k']
                    ) || 100;
                    
                    // In tennis, injuries have more direct impact
                    const injuryImpact = Math.max(0, (50 - severity) / 100); // Lower severity number = worse
                    const recoveryFactor = recoveryPercent / 100;
                    
                    const finalImpact = injuryImpact * (1 - recoveryFactor);
                    return 1 + Math.max(-0.30, Math.min(0, -finalImpact)); // Max 30% negative impact
                };
                
                const playerAInjuryMultiplier = processPlayerInjury(tennisAnalysis.recent_injuries.player_a_injury);
                const playerBInjuryMultiplier = processPlayerInjury(tennisAnalysis.recent_injuries.player_b_injury);
                
                adjustment *= Math.sqrt(playerAInjuryMultiplier * playerBInjuryMultiplier);
            }
            
            return prob * adjustment;
        }
        
        function applyMotivationAnalysis(prob, motivationAnalysis, marketType) {
            if (!motivationAnalysis || typeof motivationAnalysis !== 'object') return prob;
            
            let adjustment = 1.0;
            
            // Egys√©ges motiv√°ci√≥s hat√°s minden sportra (max 20% pozit√≠v hat√°s)
            if (motivationAnalysis.is_high_motivation && motivationAnalysis.motivation_scale) {
                const isHighMotivation = motivationAnalysis.is_high_motivation === true;
                const motivationScale = parseFloat(motivationAnalysis.motivation_scale) || 50;
                
                if (isHighMotivation && motivationScale > 50) {
                    // 1-100 sk√°la -> max 20% pozit√≠v hat√°s
                    // 50 = semleges, 100 = +20% hat√°s
                    const rawMotivationBoost = (motivationScale - 50) / 100 * 0.4; // Max 20%
                    const cappedBoost = Math.max(0, Math.min(0.2, rawMotivationBoost)); // Cap at 20%
                    
                    // Sportspecifikus alkalmaz√°s
                    if (marketType === 'match_result') {
                        adjustment *= (1 + cappedBoost); // √Åltal√°nos teljes√≠tm√©ny n√∂veked√©s
                    } else if (marketType === 'cards') {
                        adjustment *= (1 + cappedBoost * 1.5); // Motiv√°ci√≥ -> t√∂bb intenzit√°s -> t√∂bb lap
                    } else if (marketType.includes('total')) {
                        adjustment *= (1 + cappedBoost * 0.8); // Motiv√°ci√≥ -> t√∂bb g√≥l/pont
                    } else if (marketType === 'corners') {
                        adjustment *= (1 + cappedBoost * 0.6); // Motiv√°ci√≥ -> t√∂bb t√°mad√°s -> t√∂bb sz√∂glet
                    }
                }
            }
            
            return prob * adjustment;
        }
        
        function applyMotivationAdjustments(prob, motivationData, marketType) {
            if (!motivationData || typeof motivationData !== 'object') return prob;
            
            let adjustment = 1.0;
            
            // League position pressure
            if (motivationData.league_pressure) {
                const pressure = parseFloat(motivationData.league_pressure) || 1.0;
                if (pressure > 1.2 && marketType === 'cards') {
                    adjustment *= 1.1; // High pressure = more aggressive play
                } else if (pressure > 1.2 && marketType.includes('goals')) {
                    adjustment *= 1.05; // Desperation can lead to more goals
                }
            }
            
            // Cup competition importance
            if (motivationData.cup_importance) {
                const importance = parseFloat(motivationData.cup_importance) || 1.0;
                if (importance > 1.5) {
                    adjustment *= 1.03; // Cup matches tend to be more intense
                }
            }
            
            // Derby/rivalry factor
            if (motivationData.rivalry_factor) {
                const rivalry = parseFloat(motivationData.rivalry_factor) || 1.0;
                if (rivalry > 1.3) {
                    if (marketType === 'cards') adjustment *= 1.2; // Derbies = more cards
                    if (marketType.includes('goals')) adjustment *= 1.1; // Derbies = more goals
                }
            }
            
            return prob * adjustment;
        }

        // --- MATHJAX RENDERING FUNCTIONS --- //
        function renderAllMath() {
            if (window.MathJax && window.MathJax.typesetPromise) {
                console.log('Re-rendering all MathJax formulas...');
                MathJax.typesetPromise().then(() => {
                    console.log('All MathJax formulas rendered successfully!');
                }).catch((err) => console.error('MathJax global render error:', err));
            }
        }
        
        // Re-render math when switching tabs
        function switchTabAndRenderMath(tabName) {
            UIManager.switchTab(tabName);
            setTimeout(renderAllMath, 200);
        }

        // --- HELPER FUNCTIONS --- //
        function calculateDiversification(bets) {
            const matchSet = new Set(bets.map(b => b.matchIdentifier));
            const marketSet = new Set(bets.map(b => b.market));
            const matchDiv = matchSet.size / bets.length;
            const marketDiv = marketSet.size / bets.length;
            return {matchDiv, marketDiv, matchCount: matchSet.size, marketCount: marketSet.size};
        }

        function getBestTip(bets, by = 'prob') {
            if (!bets.length) return null;
            return bets.reduce((best, bet) => (bet[by] > (best?.[by] ?? -Infinity) ? bet : best), null);
        }

        function getConfidenceIcon(conf) {
            if (conf === 'high') return 'üü¢';
            if (conf === 'medium') return 'üü†';
            return 'üî¥';
        }

        function getConfidenceColor(conf) {
            if (conf === 'high') return '#10b981';
            if (conf === 'medium') return '#f59e0b';
            return '#ef4444';
        }

        // 1. Alacsony kock√°zat√∫/kiemelked≈ë EV-s tippek sz≈±r√©se
        function filterLowRiskHighEV(bets, capital) {
            return bets.filter(bet => bet.expected_return > 0 && (bet.prob > 0.6 || bet.expected_return > 0.1 * capital));
        }

        // --- AUTOMATIC PROCESSING FUNCTIONS --- //
        function checkForAutomaticProcessing(sportBreakdown) {
            const selectedAiModel = document.getElementById('aiModel').value;
            const aiApiKey = document.getElementById('aiApiKey').value.trim();
            
            if (selectedAiModel !== 'none' && aiApiKey.length > 0) {
                console.log(`Automatic processing available with ${selectedAiModel}`);
                // Auto-processing is available - user can click the button
            } else {
                console.log('Manual processing mode - user needs to paste JSON response');
            }
        }
        
        async function processPromptAutomatically() {
            const selectedAiModel = document.getElementById('aiModel').value;
            const aiApiKey = document.getElementById('aiApiKey').value.trim();
            const autoDataSearchEnabled = document.getElementById('enableAutoDataSearch').checked;
            
            if (selectedAiModel === 'none' || !aiApiKey) {
                showLocalizedNotification('notificationNoAiModelSelected', 'warning');
                return;
            }
            
            showLocalizedLoading('autoProcessingPrompt', 'autoProcessingData', { model: selectedAiModel });
            
            try {
                let response;
                
                // Check if automatic data search is enabled and we have Perplexity
                if (autoDataSearchEnabled && selectedAiModel === 'perplexity') {
                    console.log('üîç Starting automatic data search with Perplexity...');
                    response = await performAutomaticDataSearch(aiApiKey);
                } else {
                    // Use traditional prompt-based approach
                    const promptContent = document.getElementById('combinedPromptContent').textContent;
                    if (!promptContent) {
                        showLocalizedNotification('notificationNoPromptContent', 'error');
                        return;
                    }
                    
                    switch (selectedAiModel) {
                        case 'chatgpt':
                            response = await processWithChatGPT(promptContent, aiApiKey);
                            break;
                        case 'deepseek':
                            response = await processWithDeepSeek(promptContent, aiApiKey);
                            break;
                        case 'perplexity':
                            response = await processWithPerplexity(promptContent, aiApiKey);
                            break;
                        case 'gemini':
                            response = await processWithGemini(promptContent, aiApiKey);
                            break;
                        default:
                            throw new Error(`Unsupported AI model: ${selectedAiModel}`);
                    }
                }
                
                // Automatically fill the retrieved data field
                DOM.retrievedDataInput.value = response;
                DOM.processDataBtn.disabled = false;
                
                showLocalizedNotification('notificationAutoProcessingComplete', 'success');
                
                // Optionally auto-process the data
                setTimeout(() => {
                    processAllRetrievedData();
                }, 1000);
                
            } catch (error) {
                console.error('Auto processing error:', error);
                showLocalizedNotification('notificationAutoProcessingError', 'error', { error: error.message });
            } finally {
                UIManager.hideLoading();
            }
        }
        
        async function processWithChatGPT(prompt, apiKey) {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-4o',
                    messages: [{ role: 'user', content: prompt }],
                    response_format: { type: "json_object" }
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || `HTTP ${response.status}`);
            }
            
            const data = await response.json();
            return data.choices[0].message.content;
        }
        
        async function processWithDeepSeek(prompt, apiKey) {
            const response = await fetch('https://api.deepseek.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'deepseek-chat',
                    messages: [{ role: 'user', content: prompt }],
                    response_format: { type: "json_object" }
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || `HTTP ${response.status}`);
            }
            
            const data = await response.json();
            return data.choices[0].message.content;
        }
        
        async function processWithPerplexity(prompt, apiKey) {
            const response = await fetch('https://api.perplexity.ai/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'llama-3.1-sonar-large-128k-online',
                    messages: [{ role: 'user', content: prompt }]
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || `HTTP ${response.status}`);
            }
            
            const data = await response.json();
            return data.choices[0].message.content;
        }
        
        // Automatic data search using Perplexity with web search
        async function performAutomaticDataSearch(apiKey) {
            console.log('üîç Starting automatic data search...');
            
            // Extract matches from uploaded images
            const allMatches = [];
            AppState.uploadedImages.forEach(image => {
                if (image.analysisResult && image.analysisResult.matches_detected) {
                    image.analysisResult.matches_detected.forEach(match => {
                        allMatches.push({
                            home_team: match.home_team,
                            away_team: match.away_team,
                            sport: image.sport || 'football',
                            league: match.league
                        });
                    });
                }
            });
            
            if (allMatches.length === 0) {
                throw new Error('No matches found for automatic data search');
            }
            
            console.log(`Found ${allMatches.length} matches for data search`);
            
            // Group matches by sport
            const matchesBySport = {};
            allMatches.forEach(match => {
                if (!matchesBySport[match.sport]) {
                    matchesBySport[match.sport] = [];
                }
                matchesBySport[match.sport].push(match);
            });
            
            const analyses = [];
            
            // Process each sport
            for (const [sport, matches] of Object.entries(matchesBySport)) {
                console.log(`üîç Searching data for ${sport}: ${matches.length} matches`);
                
                const sportAnalysis = {
                    sport: sport,
                    matches: []
                };
                
                // Search data for each match
                for (let i = 0; i < Math.min(matches.length, 5); i++) { // Limit to 5 matches per sport
                    const match = matches[i];
                    console.log(`üîç Searching: ${match.home_team} vs ${match.away_team}`);
                    
                    try {
                        const matchData = await searchMatchDataComprehensive(match, apiKey);
                        sportAnalysis.matches.push(matchData);
                        
                        // Small delay to avoid rate limiting
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        
                    } catch (error) {
                        console.error(`Error searching data for ${match.home_team} vs ${match.away_team}:`, error);
                        
                        // Add basic fallback data
                        sportAnalysis.matches.push(createFallbackMatchData(match));
                    }
                }
                
                analyses.push(sportAnalysis);
            }
            
            const result = { analyses };
            console.log('‚úÖ Automatic data search completed:', result);
            
            return JSON.stringify(result, null, 2);
        }
        
        // Helper function to get sport-specific advanced metrics
        function getAdvancedMetricsForSport(sport) {
            const metricsMap = {
                'football': `
- Expected Goals (xG) for and against (last 10 matches)
- Shot conversion rates and shots on target %
- Possession statistics and passing accuracy
- Defensive actions per game (tackles, interceptions, clearances)
- Set piece efficiency (corners, free kicks)
- Player ratings and key performance indicators`,
                'soccer': `
- Expected Goals (xG) for and against (last 10 matches)
- Shot conversion rates and shots on target %
- Possession statistics and passing accuracy
- Defensive actions per game (tackles, interceptions, clearances)
- Set piece efficiency (corners, free kicks)
- Player ratings and key performance indicators`,
                'tennis': `
- Elo ratings and ranking positions
- Surface-specific performance (clay, grass, hard court)
- Serve statistics (first serve %, aces, double faults)
- Return game statistics and break point conversion
- Recent match times and physical condition indicators
- Head-to-head surface-specific records`,
                'basketball': `
- Offensive/Defensive efficiency ratings
- Four Factors: eFG%, TOV%, OREB%, FTR
- Pace and possessions per game
- Player efficiency ratings (PER) for key players
- Fatigue factors (back-to-back games, travel distance)
- Clutch performance statistics`,
                'hockey': `
- Corsi/Fenwick statistics and shot metrics
- Goaltender save percentages and recent form
- Power play/penalty kill efficiency
- Faceoff win percentages by zone
- Plus/minus ratings for key players
- Special teams usage and success rates`,
                'baseball': `
- Pitcher FIP, ERA, WHIP, and recent performance
- Team wOBA, wRC+, and advanced hitting metrics
- Bullpen usage and effectiveness
- Park factors and weather impact calculations
- Pitcher vs batter matchup history
- Defensive efficiency metrics (UZR, DRS)`,
                'americanfootball': `
- EPA (Expected Points Added) per play
- DVOA (Defense-adjusted Value Over Average)
- Turnover differential and red zone efficiency
- Strength of schedule and recent opponent quality
- Injury report impact on key positions
- Weather impact on passing vs rushing games`
            };
            
            return metricsMap[sport] || `
- Sport-specific performance metrics
- Key player performance indicators
- Recent statistical trends
- Situational performance data`;
        }

        // Enhanced search data for comprehensive mathematical analysis
        async function searchMatchDataComprehensive(match, apiKey) {
            const sportConfig = SportConfigs[match.sport] || SportConfigs.unknown;
            
            const searchPrompt = `üîç COMPREHENSIVE SPORTS DATA SEARCH FOR MATHEMATICAL ANALYSIS

MATCH: ${match.home_team} vs ${match.away_team}
SPORT: ${match.sport.toUpperCase()}
LEAGUE: ${match.league || 'Unknown'}

You are tasked with finding ALL necessary data for advanced mathematical sports betting models. Search the internet thoroughly for the following data categories:

üìä BASIC STATISTICAL DATA:
- Recent form (last 10 matches for each team with exact scores)
- Head-to-head record (last 10 meetings with scores and dates)
- Current league position and points
- Home/away performance splits
- Goals/points scored and conceded statistics

üéØ ADVANCED METRICS (Sport-specific):
${getAdvancedMetricsForSport(match.sport)}

üíâ INJURY & SUSPENSION DATA:
- All missing players (names, positions, importance rating 1-10)
- Expected return dates
- Replacement players and their quality
- Impact on team performance (quantify in percentages)

üèüÔ∏è VENUE & CONDITIONS:
- Stadium/arena name and capacity
- Surface type (grass, artificial, court type)
- Weather forecast (temperature, wind, precipitation)
- Altitude and climate effects on performance

üî¨ TACTICAL ANALYSIS:
- Formation and playing style for each team
- Key player dependencies
- Recent tactical changes or injuries affecting strategy
- Manager/coach impact and recent decisions

üìà MOMENTUM & PSYCHOLOGY:
- Team morale and confidence levels
- Pressure situations (relegation, promotion, titles)
- Recent media coverage and controversies
- Fan support and attendance factors

üé≤ BETTING MARKET DATA:
- Opening odds vs current odds movement
- Betting volume and public sentiment
- Sharp money indicators
- Historical closing line value

Please provide QUANTIFIED data wherever possible. Instead of "good form", provide "80% win rate in last 10 matches". Instead of "key injury", provide "reduces team strength by 15%".

Provide the response in this comprehensive JSON format:
{
  "home_team": "${match.home_team}",
  "away_team": "${match.away_team}",
  "league": "${match.league || 'Unknown'}",
  "match_date": "2024-01-15",
  "venue": {
    "name": "Stadium name",
    "capacity": 60000,
    "surface_type": "natural_grass",
    "venue_type": "outdoor",
    "altitude": 100,
    "weather_forecast": {
      "temperature": 15,
      "wind_speed": 10,
      "wind_direction": "SW",
      "precipitation_probability": 20,
      "humidity": 65
    }
  },
  "comprehensive_team_data": {
    "home_team": {
      "recent_form_detailed": [
        {"opponent": "Team A", "result": "W", "score": "2-1", "date": "2024-01-10", "xG_for": 1.8, "xG_against": 1.2},
        {"opponent": "Team B", "result": "W", "score": "3-0", "date": "2024-01-07", "xG_for": 2.1, "xG_against": 0.8}
      ],
      "league_position": 3,
      "points": 45,
      "goals_for": 58,
      "goals_against": 32,
      "home_record": {"wins": 8, "draws": 3, "losses": 1},
      "away_record": {"wins": 6, "draws": 2, "losses": 4},
      "advanced_metrics": {
        "xG_per_game": 1.85,
        "xGA_per_game": 1.12,
        "possession_avg": 62.5,
        "shot_conversion_rate": 12.8,
        "defensive_actions_per_game": 45.2
      }
    },
    "away_team": {
      "recent_form_detailed": [
        {"opponent": "Team C", "result": "L", "score": "0-2", "date": "2024-01-10", "xG_for": 0.9, "xG_against": 2.2},
        {"opponent": "Team D", "result": "W", "score": "1-0", "date": "2024-01-07", "xG_for": 1.1, "xG_against": 0.7}
      ],
      "league_position": 7,
      "points": 38,
      "goals_for": 42,
      "goals_against": 38,
      "home_record": {"wins": 7, "draws": 4, "losses": 1},
      "away_record": {"wins": 4, "draws": 3, "losses": 5},
      "advanced_metrics": {
        "xG_per_game": 1.45,
        "xGA_per_game": 1.38,
        "possession_avg": 48.2,
        "shot_conversion_rate": 10.2,
        "defensive_actions_per_game": 52.8
      }
    }
  },
  "head_to_head_detailed": {
    "overall_wins_home": 6,
    "overall_wins_away": 3,
    "overall_draws": 2,
    "last_5_meetings": [
      {"date": "2023-09-15", "result": "2-1", "venue": "home"},
      {"date": "2023-04-22", "result": "0-0", "venue": "away"},
      {"date": "2022-11-30", "result": "3-1", "venue": "home"}
    ],
    "goals_scored_home": 18,
    "goals_scored_away": 12,
    "average_goals_per_meeting": 2.73
  },
  "injury_suspension_impact": {
    "home_team_missing": [
      {"name": "Star Player", "position": "CAM", "importance": 9, "impact_percentage": 15, "expected_return": "2024-02-01"},
      {"name": "Defender", "position": "CB", "importance": 7, "impact_percentage": 8, "expected_return": "2024-01-20"}
    ],
    "away_team_missing": [
      {"name": "Striker", "position": "ST", "importance": 8, "impact_percentage": 12, "expected_return": "2024-01-25"}
    ],
    "total_impact_home": 23,
    "total_impact_away": 12
  },
  "tactical_analysis": {
    "home_team_formation": "4-3-3",
    "away_team_formation": "4-2-3-1",
    "home_team_style": "possession_based",
    "away_team_style": "counter_attacking",
    "manager_impact": {
      "home_manager_experience": 8.5,
      "away_manager_experience": 6.2,
      "tactical_flexibility": "high"
    }
  },
  "psychological_factors": {
    "home_team_morale": 78,
    "away_team_morale": 65,
    "pressure_level": {
      "home_team": 75,
      "away_team": 40
    },
    "fan_support_impact": 12,
    "media_coverage": "high_attention"
  },
  "betting_market_analysis": {
    "opening_odds": {"home": 1.90, "draw": 3.40, "away": 4.20},
    "current_odds": {"home": 1.85, "draw": 3.50, "away": 4.00},
    "odds_movement": "slight_favor_home",
    "betting_volume": "high",
    "sharp_money_indicator": "home_team"
  },
  "fair_odds_calculation": {
    "home_win_prob": 0.52,
    "draw_prob": 0.26,
    "away_win_prob": 0.22,
    "calculation_method": "Comprehensive model incorporating xG, injuries, form, H2H, weather, psychology",
    "confidence_level": 85
  },
  "total_goals_analysis": {
    "expected_total_goals": 2.78,
    "over_2_5_prob": 0.63,
    "under_2_5_prob": 0.37,
    "over_1_5_prob": 0.82,
    "under_1_5_prob": 0.18,
    "btts_prob": 0.68
  },
  "additional_markets": {
    "corners": {"expected": 11.5, "over_10_5": 0.58},
    "cards": {"expected": 4.2, "over_4_5": 0.45},
    "first_goal": {"home": 0.58, "away": 0.42}
  },
  "reasoning": "Comprehensive analysis based on xG data showing home team superior (1.85 vs 1.45), significant injury impact favoring home (23% vs 12%), strong home form (8-3-1), and weather conditions favoring possession-based play. Sharp money on home team confirms model. Sources: ESPN, FiveThirtyEight, Transfermarkt.",
  "data_sources": ["ESPN", "BBC Sport", "FiveThirtyEight", "Transfermarkt", "Official League Data", "Weather.com"],
  "last_updated": "2024-01-15T10:30:00Z"
}

Please search for real, current data and provide accurate probabilities based on your findings.`;

            const response = await fetch('https://api.perplexity.ai/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'sonar-pro',
                    messages: [{ role: 'user', content: searchPrompt }],
                    search_mode: 'web',
                    temperature: 0.1,
                    max_tokens: 2000
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || `HTTP ${response.status}`);
            }
            
            const data = await response.json();
            const content = data.choices[0].message.content;
            
            // Try to extract JSON from the response
            try {
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    return JSON.parse(jsonMatch[0]);
                } else {
                    throw new Error('No JSON found in response');
                }
            } catch (parseError) {
                console.warn('Failed to parse JSON from Perplexity response, creating fallback data');
                return createFallbackMatchData(match, content);
            }
        }
        
        // Create fallback match data when search fails
        function createFallbackMatchData(match, searchContent = '') {
            return {
                home_team: match.home_team,
                away_team: match.away_team,
                league: match.league || 'Unknown League',
                match_date: new Date().toISOString().split('T')[0],
                venue: 'Unknown Venue',
                venue_type: 'outdoor',
                fair_odds_calculation: {
                    home_win_prob: 0.40,
                    draw_prob: 0.30,
                    away_win_prob: 0.30,
                    calculation_method: 'Fallback probabilities - search data unavailable'
                },
                total_goals_prob: {
                    over_2_5: 0.50,
                    under_2_5: 0.50
                },
                both_teams_score: {
                    yes: 0.55,
                    no: 0.45
                },
                team_stats: {
                    home_team: {
                        recent_form: 'Data unavailable',
                        league_position: 'Unknown'
                    },
                    away_team: {
                        recent_form: 'Data unavailable', 
                        league_position: 'Unknown'
                    }
                },
                head_to_head: {
                    overall_record: 'Data unavailable',
                    recent_meetings: 'Data unavailable'
                },
                missing_players_analysis: {
                    team_a_missing: [],
                    team_b_missing: []
                },
                motivation_analysis: {
                    home_team_motivation: {
                        motivation_scale: 50,
                        motivation_reasoning: 'Data unavailable'
                    },
                    away_team_motivation: {
                        motivation_scale: 50,
                        motivation_reasoning: 'Data unavailable'
                    }
                },
                reasoning: `Fallback data for ${match.home_team} vs ${match.away_team}. ${searchContent ? 'Partial search results: ' + searchContent.substring(0, 200) + '...' : 'No search data available.'}`
            };
        }
        
        async function processWithGemini(prompt, apiKey) {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-latest:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{ text: prompt }]
                    }],
                    generationConfig: {
                        responseMimeType: "application/json"
                    }
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || `HTTP ${response.status}`);
            }
            
            const data = await response.json();
            return data.candidates[0].content.parts[0].text;
        }

        // --- JSON REPAIR TESTING FUNCTION --- //
        function testEmergencyJsonRepair() {
            const testData = `{
                "broken": "json with trailing comma",
                "missing_quotes": here,
                "Manchester City vs Arsenal": {
                    "odds": 1.85,
                    "league": "Premier League"
                },
                "Liverpool": "vs Chelsea 2.10",
                "oversized_object": {
                    "key1": "value1", "key2": "value2", "key3": "value3",
                    "key4": "value4", "key5": "value5", "key6": "value6"
                }
            `;
            
            try {
                console.log('üîß Testing emergency JSON repair with broken data...');
                const repairedJson = extractJsonFromText(testData);
                const parsed = JSON.parse(repairedJson);
                
                console.log('‚úÖ JSON repair test successful!');
                console.log('Repaired data:', parsed);
                
                // Show the result in the textarea for demonstration
                DOM.retrievedDataInput.value = repairedJson;
                DOM.processDataBtn.disabled = false;
                
                showLocalizedNotification('emergencyExtractionSuccess', 'success');
                
            } catch (error) {
                console.error('‚ùå JSON repair test failed:', error);
                showLocalizedNotification('jsonRepairFallback', 'warning');
            }
        }

        // --- DOWNLOAD FUNCTIONS --- //
        function downloadPortfolioSummary() {
            const portfolio = AppState.portfolio;
            const capital = parseFloat(document.getElementById('capital').value);
            const totalStake = portfolio.singles.reduce((sum, bet) => sum + bet.stake, 0) + portfolio.parlays.reduce((sum, bet) => sum + bet.stake, 0);
            const totalEV = portfolio.singles.reduce((sum, bet) => sum + bet.ev, 0) + portfolio.parlays.reduce((sum, bet) => sum + bet.ev, 0);
            
            let content = `PROFESSZION√ÅLIS SPORTFOGAD√ÅSI PORTF√ìLI√ì √ñSSZEFOGLAL√ì
Gener√°lva: ${new Date().toLocaleDateString('hu-HU')} ${new Date().toLocaleTimeString('hu-HU')}
================================================================================

PORTF√ìLI√ì √ÅTTEKINT√âS:
‚Ä¢ √ñsszes t≈ëke: ‚Ç¨${capital.toFixed(2)}
‚Ä¢ Teljes t√©t: ‚Ç¨${totalStake.toFixed(2)} (${(totalStake/capital*100).toFixed(1)}% kihaszn√°l√°s)
‚Ä¢ V√°rhat√≥ profit: ‚Ç¨${totalEV.toFixed(2)}
‚Ä¢ V√°rhat√≥ ROI: ${(totalEV/totalStake*100).toFixed(1)}%
‚Ä¢ Aj√°nl√°sok sz√°ma: ${portfolio.singles.length} egyes + ${portfolio.parlays.length} kombi

================================================================================
EGYES FOGAD√ÅSOK (${portfolio.singles.length} db):
================================================================================
`;

            portfolio.singles.forEach((bet, index) => {
                const evPercent = (bet.ev / bet.stake * 100).toFixed(2);
                content += `
${index + 1}. ${bet.home_team} vs ${bet.away_team}
   Sport√°g: ${bet.sport.toUpperCase()}
   Piac: ${bet.market_type.replace(/_/g, ' ')} ${bet.market_specifier || ''}
   Kiv√°laszt√°s: ${bet.selection}
   Szorz√≥: ${bet.odds.toFixed(2)}
   Val√≥sz√≠n≈±s√©g: ${(bet.prob * 100).toFixed(1)}%
   Edge: ${(bet.edge * 100).toFixed(2)}%
   Aj√°nlott t√©t: ‚Ç¨${bet.stake}
   EV: ${evPercent}%
   Potenci√°lis nyeres√©g: ‚Ç¨${(bet.stake * (bet.odds - 1)).toFixed(0)}
   
`;
            });

            if (portfolio.parlays.length > 0) {
                content += `
================================================================================
KOMBI FOGAD√ÅSOK (${portfolio.parlays.length} db):
================================================================================
`;

                portfolio.parlays.forEach((parlay, index) => {
                    const evPercent = (parlay.ev / parlay.stake * 100).toFixed(2);
                    content += `
${index + 1}. KOMBI (${parlay.legs.length}x)
   Kombin√°lt szorz√≥: ${parlay.combinedOdds.toFixed(2)}
   Kombin√°lt val√≥sz√≠n≈±s√©g: ${(parlay.combinedProb * 100).toFixed(1)}%
   Edge: ${(parlay.edge * 100).toFixed(2)}%
   Aj√°nlott t√©t: ‚Ç¨${parlay.stake}
   EV: ${evPercent}%
   Potenci√°lis nyeres√©g: ‚Ç¨${(parlay.stake * (parlay.combinedOdds - 1)).toFixed(0)}
   
   Meccsek:
`;
                    parlay.legs.forEach((leg, legIndex) => {
                        content += `   ${legIndex + 1}. ${leg.home_team} vs ${leg.away_team} - ${leg.selection} @ ${leg.odds.toFixed(2)}\n`;
                    });
                    content += '\n';
                });
            }

            content += `
================================================================================
KOCK√ÅZAT ELEMZ√âS:
================================================================================
‚Ä¢ T≈ëke kihaszn√°l√°s: ${(totalStake/capital*100).toFixed(1)}% (aj√°nlott: <15%)
‚Ä¢ Diverzifik√°ci√≥: ${portfolio.singles.length + portfolio.parlays.length} k√ºl√∂nb√∂z≈ë fogad√°s
‚Ä¢ √Åtlagos t√©tm√©ret: ‚Ç¨${(totalStake/(portfolio.singles.length + portfolio.parlays.length)).toFixed(0)}
‚Ä¢ Kock√°zati kateg√≥ria: ${totalStake/capital > 0.15 ? 'MAGAS' : totalStake/capital > 0.10 ? 'K√ñZEPES' : 'ALACSONY'}

FIGYELMEZTET√âS: Ez a portf√≥li√≥ matematikai sz√°m√≠t√°sokon alapul. Mindig fogadj felel≈ëss√©gteljesen!
`;

            downloadFile(content, 'portfolio_summary.txt', 'text/plain');
        }

        function downloadCalculationDetails() {
            const portfolio = AppState.portfolio;
            
            let content = `MATEMATIKAI SZ√ÅM√çT√ÅSOK R√âSZLETEI
Gener√°lva: ${new Date().toLocaleDateString('hu-HU')} ${new Date().toLocaleTimeString('hu-HU')}
================================================================================

ALKALMAZOTT MATEMATIKAI MODELLEK:
================================================================================

1. KELLY KRIT√âRIUM:
   K√©plet: f* = (bp - q) / b
   ahol: b = szorz√≥ - 1, p = val√≥sz√≠n≈±s√©g, q = 1 - p
   
2. EDGE SZ√ÅM√çT√ÅS:
   K√©plet: Edge = (p √ó odds) - 1
   
3. V√ÅRHAT√ì √âRT√âK (EV):
   K√©plet: EV = T√©t √ó Edge

================================================================================
R√âSZLETES SZ√ÅM√çT√ÅSOK FOGAD√ÅSONK√âNT:
================================================================================
`;

            portfolio.singles.forEach((bet, index) => {
                const b = bet.odds - 1;
                const p = bet.prob;
                const q = 1 - p;
                const kellyRaw = (b * p - q) / b;
                const kellyAdjusted = kellyRaw * 0.25; // Conservative modifier
                
                content += `
EGYES FOGAD√ÅS #${index + 1}: ${bet.home_team} vs ${bet.away_team}
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Alapadatok:
‚Ä¢ Szorz√≥ (odds): ${bet.odds.toFixed(3)}
‚Ä¢ Val√≥sz√≠n≈±s√©g (p): ${p.toFixed(3)} (${(p*100).toFixed(1)}%)
‚Ä¢ Nett√≥ szorz√≥ (b): ${b.toFixed(3)}
‚Ä¢ Ellent√©tes val√≥sz√≠n≈±s√©g (q): ${q.toFixed(3)}

Kelly sz√°m√≠t√°s:
‚Ä¢ Nyers Kelly: f* = (${b.toFixed(3)} √ó ${p.toFixed(3)} - ${q.toFixed(3)}) / ${b.toFixed(3)} = ${kellyRaw.toFixed(4)}
‚Ä¢ Konzervat√≠v Kelly: ${kellyRaw.toFixed(4)} √ó 0.25 = ${kellyAdjusted.toFixed(4)}
‚Ä¢ Kelly sz√°zal√©k: ${(kellyAdjusted * 100).toFixed(2)}%

Edge sz√°m√≠t√°s:
‚Ä¢ Edge = (${p.toFixed(3)} √ó ${bet.odds.toFixed(3)}) - 1 = ${bet.edge.toFixed(4)}
‚Ä¢ Edge sz√°zal√©k: ${(bet.edge * 100).toFixed(2)}%

T√©t sz√°m√≠t√°s:
‚Ä¢ Nyers t√©t: ${kellyAdjusted.toFixed(4)} √ó ‚Ç¨${parseFloat(document.getElementById('capital').value)} = ‚Ç¨${(kellyAdjusted * parseFloat(document.getElementById('capital').value)).toFixed(2)}
‚Ä¢ Kerek√≠tett t√©t: ‚Ç¨${bet.stake}

V√°rhat√≥ √©rt√©k:
‚Ä¢ EV = ‚Ç¨${bet.stake} √ó ${bet.edge.toFixed(4)} = ‚Ç¨${bet.ev.toFixed(2)}
‚Ä¢ EV sz√°zal√©k: ${(bet.ev/bet.stake*100).toFixed(2)}%

Kock√°zat metrik√°k:
‚Ä¢ Variancia: ${(p * q * b * b).toFixed(4)}
‚Ä¢ Sz√≥r√°s: ${Math.sqrt(p * q * b * b).toFixed(4)}
‚Ä¢ Sharpe r√°ta: ${(bet.edge / Math.sqrt(p * q * b * b)).toFixed(4)}

`;
            });

            portfolio.parlays.forEach((parlay, index) => {
                content += `
KOMBI FOGAD√ÅS #${index + 1}:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Kombin√°lt sz√°m√≠t√°sok:
‚Ä¢ Kombin√°lt szorz√≥: ${parlay.legs.map(l => l.odds.toFixed(2)).join(' √ó ')} = ${parlay.combinedOdds.toFixed(3)}
‚Ä¢ Kombin√°lt val√≥sz√≠n≈±s√©g: ${parlay.legs.map(l => l.prob.toFixed(3)).join(' √ó ')} = ${parlay.combinedProb.toFixed(4)}
‚Ä¢ Edge: ${parlay.edge.toFixed(4)} (${(parlay.edge * 100).toFixed(2)}%)
‚Ä¢ EV: ‚Ç¨${parlay.ev.toFixed(2)} (${(parlay.ev/parlay.stake*100).toFixed(2)}%)

Meccsek r√©szletei:
`;
                parlay.legs.forEach((leg, legIndex) => {
                    content += `${legIndex + 1}. ${leg.home_team} vs ${leg.away_team}: p=${leg.prob.toFixed(3)}, odds=${leg.odds.toFixed(2)}\n`;
                });
                content += '\n';
            });

            content += `
================================================================================
PORTF√ìLI√ì SZINT≈∞ SZ√ÅM√çT√ÅSOK:
================================================================================

Teljes portf√≥li√≥ v√°rhat√≥ √©rt√©k:
‚Ä¢ √ñsszes EV = ${portfolio.singles.map(b => `‚Ç¨${b.ev.toFixed(2)}`).join(' + ')}${portfolio.parlays.length > 0 ? ' + ' + portfolio.parlays.map(p => `‚Ç¨${p.ev.toFixed(2)}`).join(' + ') : ''}
‚Ä¢ Teljes EV = ‚Ç¨${(portfolio.singles.reduce((sum, bet) => sum + bet.ev, 0) + portfolio.parlays.reduce((sum, bet) => sum + bet.ev, 0)).toFixed(2)}

Kock√°zat diverzifik√°ci√≥:
‚Ä¢ K√ºl√∂nb√∂z≈ë meccsek sz√°ma: ${new Set([...portfolio.singles.map(b => `${b.home_team}-${b.away_team}`), ...portfolio.parlays.flatMap(p => p.legs.map(l => `${l.home_team}-${l.away_team}`))]).size}
‚Ä¢ K√ºl√∂nb√∂z≈ë sport√°gak: ${new Set([...portfolio.singles.map(b => b.sport), ...portfolio.parlays.flatMap(p => p.legs.map(l => l.sport))]).size}
`;

            downloadFile(content, 'calculation_details.txt', 'text/plain');
        }

        function downloadDataSources() {
            let content = `ADATFORR√ÅSOK √âS ELLEN≈êRZ√âSI INFORM√ÅCI√ìK
Gener√°lva: ${new Date().toLocaleDateString('hu-HU')} ${new Date().toLocaleTimeString('hu-HU')}
================================================================================

FELHASZN√ÅLT ADATOK ELLEN≈êRZ√âSE:
================================================================================

Az al√°bbi adatok alapj√°n t√∂rt√©ntek a sz√°m√≠t√°sok. K√©rj√ºk, ellen≈ërizze ezeket a 
val√≥s eredm√©nyekkel a sz√°m√≠t√°sok pontoss√°g√°nak meg√°llap√≠t√°s√°hoz.

`;

            // Include Perplexity search results if available
            if (AppState.perplexitySearchResults && AppState.perplexitySearchResults.length > 0) {
                content += `
PERPLEXITY AI AUTOMATIKUS ADATKERES√âS EREDM√âNYEI:
================================================================================

A Perplexity AI automatikusan megkereste az interneten az al√°bbi inform√°ci√≥kat:

`;
                AppState.perplexitySearchResults.forEach((searchResult, index) => {
                    content += `
${index + 1}. KERES√âSI EREDM√âNY:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Keres√©si k√©rd√©s: ${searchResult.query || 'N/A'}
Id≈ëpont: ${searchResult.timestamp || 'N/A'}

TAL√ÅLT INFORM√ÅCI√ìK:
${searchResult.content || searchResult.answer || 'Nincs el√©rhet≈ë tartalom'}

FORR√ÅSOK:
${searchResult.sources ? searchResult.sources.map(source => `‚Ä¢ ${source.title || source.url}: ${source.url}`).join('\n') : 'Nincs forr√°s inform√°ci√≥'}

MEGB√çZHAT√ìS√ÅG: ${searchResult.confidence || 'N/A'}%

`;
                });
                
                content += `
PERPLEXITY KERES√âS √ñSSZEFOGLAL√ÅSA:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
√ñsszes keres√©s: ${AppState.perplexitySearchResults.length}
√Åtlagos megb√≠zhat√≥s√°g: ${AppState.perplexitySearchResults.reduce((sum, result) => sum + (result.confidence || 0), 0) / AppState.perplexitySearchResults.length || 0}%
Legut√≥bbi friss√≠t√©s: ${AppState.perplexitySearchResults[AppState.perplexitySearchResults.length - 1]?.timestamp || 'N/A'}

FONTOS: Ezek az adatok automatikusan ker√ºltek √∂sszegy≈±jt√©sre a Perplexity AI √°ltal.
K√©rj√ºk, ellen≈ërizze a forr√°sok megb√≠zhat√≥s√°g√°t √©s az inform√°ci√≥k pontoss√°g√°t!

`;
            }

            // Extract data from retrieved data if available
            if (AppState.retrievedData && AppState.retrievedData.analyses) {
                AppState.retrievedData.analyses.forEach((analysis, sportIndex) => {
                    content += `
${analysis.sport.toUpperCase()} SPORT√ÅG:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
`;
                    
                    analysis.matches.forEach((match, matchIndex) => {
                        content += `
Meccs ${matchIndex + 1}: ${match.home_team} vs ${match.away_team}
League: ${match.league || 'Ismeretlen'}
D√°tum: ${match.match_date || 'Nincs megadva'}
Helysz√≠n: ${match.venue?.name || match.venue || 'Ismeretlen'}

ELLEN≈êRIZEND≈ê ADATOK:
`;
                        
                        // Team stats
                        if (match.comprehensive_team_data || match.team_stats) {
                            const teamData = match.comprehensive_team_data || match.team_stats;
                            content += `
Hazai csapat forma: ${teamData.home_team?.recent_form || teamData.home_team?.recent_form_detailed?.map(m => m.result).join('-') || 'Nincs adat'}
Vend√©g csapat forma: ${teamData.away_team?.recent_form || teamData.away_team?.recent_form_detailed?.map(m => m.result).join('-') || 'Nincs adat'}
Liga poz√≠ci√≥k: Hazai ${teamData.home_team?.league_position || 'N/A'}, Vend√©g ${teamData.away_team?.league_position || 'N/A'}
`;
                        }
                        
                        // Injuries
                        if (match.injury_suspension_impact || match.missing_players_analysis) {
                            const injuries = match.injury_suspension_impact || match.missing_players_analysis;
                            content += `
Hi√°nyz√≥ j√°t√©kosok (Hazai): ${injuries.home_team_missing?.map(p => p.name || p.player_name).join(', ') || 'Nincs adat'}
Hi√°nyz√≥ j√°t√©kosok (Vend√©g): ${injuries.away_team_missing?.map(p => p.name || p.player_name).join(', ') || 'Nincs adat'}
`;
                        }
                        
                        // Weather
                        if (match.venue?.weather_forecast || match.weather_analysis) {
                            const weather = match.venue?.weather_forecast || match.weather_analysis;
                            content += `
Id≈ëj√°r√°s: ${weather.temperature || 'N/A'}¬∞C, ${weather.conditions || weather.wind_speed ? `sz√©l ${weather.wind_speed}km/h` : 'Nincs adat'}
`;
                        }
                        
                        // Probabilities used
                        if (match.fair_odds_calculation) {
                            content += `
HASZN√ÅLT VAL√ìSZ√çN≈∞S√âGEK:
‚Ä¢ Hazai gy≈ëzelem: ${(match.fair_odds_calculation.home_win_prob * 100).toFixed(1)}%
‚Ä¢ D√∂ntetlen: ${(match.fair_odds_calculation.draw_prob * 100).toFixed(1)}%
‚Ä¢ Vend√©g gy≈ëzelem: ${(match.fair_odds_calculation.away_win_prob * 100).toFixed(1)}%
`;
                        }
                        
                        // Data sources
                        if (match.data_sources) {
                            content += `
Adatforr√°sok: ${match.data_sources.join(', ')}
`;
                        }
                        
                        // Reasoning
                        if (match.reasoning) {
                            content += `
Elemz√©si indokl√°s: ${match.reasoning.substring(0, 200)}${match.reasoning.length > 200 ? '...' : ''}
`;
                        }
                        
                        content += '\n';
                    });
                });
            }

            content += `
================================================================================
ELLEN≈êRZ√âSI √öTMUTAT√ì:
================================================================================

1. FORMA ELLEN≈êRZ√âSE:
   ‚Ä¢ Ellen≈ërizze a csapatok legut√≥bbi 5 meccs√©nek eredm√©nyeit
   ‚Ä¢ Hasonl√≠tsa √∂ssze a t√©nyleges eredm√©nyeket a fenti adatokkal

2. S√âR√úL√âSEK ELLEN≈êRZ√âSE:
   ‚Ä¢ N√©zze meg a hivatalos csapat honlapokat
   ‚Ä¢ Ellen≈ërizze a sportnews oldalakat a legfrissebb s√©r√ºl√©s h√≠rek√©rt

3. LIGA POZ√çCI√ìK:
   ‚Ä¢ Ellen≈ërizze a hivatalos liga tabell√°kat
   ‚Ä¢ Gy≈ëz≈ëdj√∂n meg r√≥la, hogy a pontsz√°mok aktu√°lisak

4. ID≈êJ√ÅR√ÅS (szabadt√©ri sportok):
   ‚Ä¢ Ellen≈ërizze a helyi id≈ëj√°r√°s el≈ërejelz√©st
   ‚Ä¢ Vegye figyelembe a sz√©l √©s es≈ë hat√°s√°t

5. ODDS ELLEN≈êRZ√âS:
   ‚Ä¢ Hasonl√≠tsa √∂ssze t√∂bb fogad√≥iroda szorz√≥it
   ‚Ä¢ Figyelje meg az odds mozg√°sokat

FONTOS: Ha jelent≈ës elt√©r√©seket tal√°l a fenti adatok √©s a val√≥s√°g k√∂z√∂tt,
√∫jra kell gondolni a fogad√°si d√∂nt√©seket!

================================================================================
MATEMATIKAI MODELLEK VALID√ÅCI√ìJA:
================================================================================

A program az al√°bbi matematikai modelleket haszn√°lja:
‚Ä¢ Kelly Krit√©rium optim√°lis t√©tm√©retek sz√°m√≠t√°s√°hoz
‚Ä¢ Poisson eloszl√°s g√≥lok el≈ërejelz√©s√©hez (labdar√∫g√°s)
‚Ä¢ Elo rating rendszer (tenisz)
‚Ä¢ Dixon-Coles modell (fejlett labdar√∫g√°s elemz√©s)

Ezek a modellek tudom√°nyosan megalapozottak, de a sportfogad√°s term√©szet√©n√©l
fogva mindig van kock√°zat. Soha ne fogadjon t√∂bbet, mint amit megengedhet
mag√°nak elvesz√≠teni.
`;

            downloadFile(content, 'data_sources_verification.txt', 'text/plain');
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showLocalizedNotification('downloadComplete', 'success', { filename });
        }

        // --- PROFESSIONAL MATHEMATICAL SCORING SYSTEM --- //
        function calculateProfessionalScore(bet) {
            const { prob, odds, stake, ev, confidence, sport, matchAnalysis } = bet;
            
            // 1. BASE EV SCORE (40% weight)
            const evPercent = (ev / stake) * 100;
            const evScore = Math.min(evPercent / 25, 4); // Max 4 points for 25%+ EV
            
            // 2. KELLY EFFICIENCY SCORE (25% weight)
            const b = odds - 1;
            const q = 1 - prob;
            const kellyFraction = (b * prob - q) / b;
            const kellyScore = Math.max(0, Math.min(kellyFraction * 20, 3)); // Max 3 points
            
            // 3. CONFIDENCE & RELIABILITY SCORE (20% weight)
            const confidenceScore = confidence * 2; // Max 2 points
            
            // 4. SPORT-SPECIFIC ADJUSTMENTS (10% weight)
            const sportScore = calculateSportSpecificScore(sport, matchAnalysis);
            
            // 5. RISK-ADJUSTED SCORE (5% weight)
            const riskScore = calculateRiskScore(prob, odds, stake);
            
            // TOTAL PROFESSIONAL SCORE
            const totalScore = 
                evScore * 0.4 +
                kellyScore * 0.25 + 
                confidenceScore * 0.2 +
                sportScore * 0.1 +
                riskScore * 0.05;
                
            return totalScore;
        }
        
        function calculateSportSpecificScore(sport, matchAnalysis) {
            if (!matchAnalysis) return 0.5;
            
            let score = 0.5; // Base score
            
            switch(sport) {
                case 'football':
                case 'soccer':
                    // Weather impact for outdoor sports
                    if (matchAnalysis.weather_analysis) {
                        const weatherImpact = matchAnalysis.weather_analysis.team_a_weather_impact;
                        if (weatherImpact < 40 || weatherImpact > 60) {
                            score += 0.3; // Weather advantage
                        }
                    }
                    // Key player impact
                    if (matchAnalysis.missing_players_analysis) {
                        const keyPlayerImpact = matchAnalysis.missing_players_analysis.team_a_missing?.some(p => p.is_key_player);
                        if (keyPlayerImpact) score += 0.2;
                    }
                    break;
                    
                case 'hockey':
                    // Goalie impact (most critical in hockey)
                    if (matchAnalysis.goaltender_analysis) {
                        const goalieImpact = matchAnalysis.goaltender_analysis.home_goalie?.goalie_impact_scale || 50;
                        if (goalieImpact > 70) score += 0.4; // Excellent goalie
                        else if (goalieImpact < 30) score += 0.4; // Poor goalie (fade)
                    }
                    break;
                    
                case 'baseball':
                    // Pitcher impact (most critical in baseball)
                    if (matchAnalysis.starting_pitchers) {
                        const pitcherImpact = matchAnalysis.starting_pitchers.home_pitcher?.pitcher_impact_scale || 50;
                        if (pitcherImpact > 75) score += 0.4; // Excellent pitcher
                        else if (pitcherImpact < 35) score += 0.4; // Poor pitcher (fade)
                    }
                    // Weather impact (very important in baseball)
                    if (matchAnalysis.weather_analysis) {
                        const weatherImpact = matchAnalysis.weather_analysis.team_a_weather_impact;
                        if (weatherImpact < 35 || weatherImpact > 65) {
                            score += 0.3; // Significant weather advantage
                        }
                    }
                    break;
                    
                case 'tennis':
                    // Injury impact (critical in individual sports)
                    if (matchAnalysis.tennis_analysis?.recent_injuries) {
                        const injuryImpact = matchAnalysis.tennis_analysis.recent_injuries;
                        if (injuryImpact.player_a_injury || injuryImpact.player_b_injury) {
                            score += 0.5; // Major advantage in individual sports
                        }
                    }
                    break;
                    
                case 'basketball':
                    // Schedule fatigue (important in basketball)
                    if (matchAnalysis.schedule_analysis) {
                        const backToBback = matchAnalysis.schedule_analysis.back_to_back;
                        if (backToBback) score += 0.2; // Fatigue advantage
                    }
                    break;
            }
            
            return Math.min(score, 1.0); // Cap at 1.0
        }
        
        function calculateRiskScore(prob, odds, stake) {
            // Sharpe ratio calculation
            const b = odds - 1;
            const expectedReturn = prob * b - (1 - prob);
            const variance = prob * (1 - prob) * b * b;
            const stdDev = Math.sqrt(variance);
            
            const sharpeRatio = stdDev > 0 ? expectedReturn / stdDev : 0;
            
            // Risk-adjusted score (higher Sharpe = better risk-adjusted return)
            return Math.min(sharpeRatio, 1.0);
        }
        
        // ADVANCED EV CALCULATION WITH INTEGRATED FACTORS
        function calculateAdvancedEV(bet) {
            const { prob, odds, stake, sport, matchAnalysis } = bet;
            
            // Base EV
            let adjustedProb = prob;
            let adjustedOdds = odds;
            
            // Sport-specific adjustments
            const sportAdjustments = calculateSportAdjustments(sport, matchAnalysis);
            adjustedProb *= sportAdjustments.probMultiplier;
            
            // Weather adjustments (for outdoor sports)
            if (matchAnalysis?.weather_analysis && isOutdoorSport(sport)) {
                const weatherAdj = calculateWeatherAdjustment(matchAnalysis.weather_analysis, sport);
                adjustedProb *= weatherAdj;
            }
            
            // Key player adjustments
            if (matchAnalysis?.missing_players_analysis) {
                const playerAdj = calculatePlayerAdjustment(matchAnalysis.missing_players_analysis, sport);
                adjustedProb *= playerAdj;
            }
            
            // Motivation adjustments
            if (matchAnalysis?.motivation_analysis) {
                const motivationAdj = calculateMotivationAdjustment(matchAnalysis.motivation_analysis);
                adjustedProb *= motivationAdj;
            }
            
            // Final EV calculation
            const finalEV = stake * (adjustedProb * adjustedOdds - 1);
            
            return {
                baseEV: stake * (prob * odds - 1),
                adjustedEV: finalEV,
                adjustedProb,
                adjustments: {
                    sport: sportAdjustments,
                    weather: matchAnalysis?.weather_analysis ? calculateWeatherAdjustment(matchAnalysis.weather_analysis, sport) : 1,
                    players: matchAnalysis?.missing_players_analysis ? calculatePlayerAdjustment(matchAnalysis.missing_players_analysis, sport) : 1,
                    motivation: matchAnalysis?.motivation_analysis ? calculateMotivationAdjustment(matchAnalysis.motivation_analysis) : 1
                }
            };
        }
        
        function calculateSportAdjustments(sport, matchAnalysis) {
            let probMultiplier = 1.0;
            
            switch(sport) {
                case 'hockey':
                    // Goalie impact
                    if (matchAnalysis?.goaltender_analysis) {
                        const goalieImpact = matchAnalysis.goaltender_analysis.home_goalie?.goalie_impact_scale || 50;
                        probMultiplier *= 0.7 + (goalieImpact / 100) * 0.6; // 0.7-1.3 range
                    }
                    break;
                    
                case 'baseball':
                    // Pitcher impact
                    if (matchAnalysis?.starting_pitchers) {
                        const pitcherImpact = matchAnalysis.starting_pitchers.home_pitcher?.pitcher_impact_scale || 50;
                        probMultiplier *= 0.6 + (pitcherImpact / 100) * 0.8; // 0.6-1.4 range
                    }
                    break;
                    
                case 'tennis':
                    // Surface advantage
                    if (matchAnalysis?.tennis_analysis?.surface_advantage) {
                        const surfaceAdv = matchAnalysis.tennis_analysis.surface_advantage.player_a_advantage || 50;
                        probMultiplier *= 0.8 + (surfaceAdv / 100) * 0.4; // 0.8-1.2 range
                    }
                    break;
            }
            
            return { probMultiplier };
        }
        
        function calculateWeatherAdjustment(weatherAnalysis, sport) {
            if (!isOutdoorSport(sport)) return 1.0;
            
            const weatherImpact = weatherAnalysis.team_a_weather_impact || 50;
            
            // Convert weather impact to probability adjustment
            // 50 = neutral, <50 = negative, >50 = positive
            const adjustment = 0.85 + (weatherImpact / 100) * 0.3; // 0.85-1.15 range
            
            return adjustment;
        }
        
        function calculatePlayerAdjustment(playerAnalysis, sport) {
            let adjustment = 1.0;
            
            // Home team missing players
            if (playerAnalysis.team_a_missing) {
                playerAnalysis.team_a_missing.forEach(player => {
                    const impact = player.impact_scale || 50;
                    const keyPlayerMultiplier = player.is_key_player ? 1.5 : 1.0;
                    
                    // Convert impact to probability adjustment
                    const playerAdj = 0.5 + (impact / 100) * 0.5; // 0.5-1.0 range
                    adjustment *= playerAdj * keyPlayerMultiplier;
                });
            }
            
            return Math.max(0.3, Math.min(adjustment, 1.7)); // Cap between 0.3-1.7
        }
        
        function calculateMotivationAdjustment(motivationAnalysis) {
            const homeMotivation = motivationAnalysis.home_team_motivation?.motivation_scale || 50;
            const awayMotivation = motivationAnalysis.away_team_motivation?.motivation_scale || 50;
            
            // Relative motivation advantage
            const motivationDiff = homeMotivation - awayMotivation;
            
            // Convert to probability adjustment
            const adjustment = 1.0 + (motivationDiff / 100) * 0.1; // ¬±10% max adjustment
            
            return Math.max(0.9, Math.min(adjustment, 1.1)); // Cap between 0.9-1.1
        }
        
        function isOutdoorSport(sport) {
            return ['football', 'soccer', 'tennis', 'baseball', 'americanfootball'].includes(sport);
        }
        
        // LONG-TERM PROFITABILITY CALCULATOR
        function calculateLongTermProfitability(portfolio) {
            const { singles, parlays } = portfolio;
            const allBets = [...singles, ...parlays];
            
            if (allBets.length === 0) return null;
            
            // Calculate expected outcomes over 1000 simulations
            const simulations = 1000;
            let totalProfit = 0;
            let winCount = 0;
            let maxDrawdown = 0;
            let currentDrawdown = 0;
            let peakCapital = 0;
            
            for (let sim = 0; sim < simulations; sim++) {
                let simProfit = 0;
                
                allBets.forEach(bet => {
                    const { prob, stake, odds } = bet;
                    const random = Math.random();
                    
                    if (random < prob) {
                        // Win
                        simProfit += stake * (odds - 1);
                        winCount++;
                    } else {
                        // Loss
                        simProfit -= stake;
                    }
                });
                
                totalProfit += simProfit;
                
                // Track drawdown
                if (simProfit > peakCapital) {
                    peakCapital = simProfit;
                    currentDrawdown = 0;
                } else {
                    currentDrawdown = peakCapital - simProfit;
                    if (currentDrawdown > maxDrawdown) {
                        maxDrawdown = currentDrawdown;
                    }
                }
            }
            
            const avgProfit = totalProfit / simulations;
            const winRate = winCount / (simulations * allBets.length);
            const totalStaked = allBets.reduce((sum, bet) => sum + bet.stake, 0);
            const roi = (avgProfit / totalStaked) * 100;
            
            return {
                expectedProfit: avgProfit,
                winRate,
                roi,
                maxDrawdown,
                profitability: avgProfit > 0 ? 'PROFITABLE' : 'UNPROFITABLE',
                confidence: Math.min(95, Math.max(5, 50 + roi * 2)) // Confidence based on ROI
            };
        }

        // --- HELPER FUNCTIONS --- //
        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            if (!element) {
                showLocalizedNotification('errorElementNotFound', 'error');
                return;
            }
            
            const text = element.textContent || element.innerText;
            if (!text) {
                showLocalizedNotification('errorNoTextToCopy', 'error');
                return;
            }
            
            // Modern clipboard API
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(text).then(() => {
                    showLocalizedNotification('notificationCopiedToClipboard', 'success');
                }).catch(err => {
                    console.error('Clipboard API failed:', err);
                    fallbackCopyToClipboard(text);
                });
            } else {
                fallbackCopyToClipboard(text);
            }
        }
        
        function fallbackCopyToClipboard(text) {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showLocalizedNotification('notificationCopiedToClipboard', 'success');
                } else {
                    showLocalizedNotification('errorCopyFailed', 'error');
                }
            } catch (err) {
                console.error('Fallback copy failed:', err);
                showLocalizedNotification('errorCopyFailed', 'error');
            } finally {
                document.body.removeChild(textArea);
            }
        }

    </script>
</body>
</html>
