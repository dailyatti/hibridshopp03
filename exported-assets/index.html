<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🎯</text></svg>">
    <title data-lang="title">Profi Multi-Sport & Kombi AI Betting Analyzer - GPT-4o Vision</title>
    <!-- MathJax for PhD-level mathematical formulas -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                    console.log('MathJax is loaded and ready');
                }
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0d2e 25%, #16213e 50%, #0f3460 75%, #0a0a0a 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
            line-height: 1.6;
            letter-spacing: 0.2px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem 0;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(6, 182, 212, 0.1));
            border-radius: 30px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 3.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #8b5cf6, #06b6d4, #10b981);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
            text-shadow: 0 0 30px rgba(139, 92, 246, 0.5);
            letter-spacing: -1px;
        }

        .language-selector {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
        }

        .lang-btn {
            padding: 0.5rem 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(15, 23, 42, 0.8);
            color: #64748b;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .lang-btn.active {
            background: linear-gradient(135deg, #8b5cf6, #06b6d4);
            color: white;
            border-color: rgba(139, 92, 246, 0.5);
            font-weight: 700;
        }

        .lang-btn:hover:not(.active) {
            background: rgba(139, 92, 246, 0.1);
            color: white;
            border-color: rgba(139, 92, 246, 0.3);
        }

        .nav-tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 3rem;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 20px;
            padding: 12px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            flex-wrap: wrap;
        }

        .nav-tab {
            padding: 15px 25px;
            border: none;
            background: transparent;
            color: #64748b;
            cursor: pointer;
            border-radius: 15px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
            overflow: hidden;
        }

        .nav-tab.active {
            background: linear-gradient(135deg, #8b5cf6, #06b6d4);
            color: white;
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.4);
            transform: translateY(-2px);
            font-weight: 700;
        }

        .nav-tab:hover:not(.active) {
            background: rgba(139, 92, 246, 0.1);
            color: white;
            transform: translateY(-1px);
        }

        .card {
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 25px;
            padding: 2.5rem;
            margin-bottom: 2rem;
            backdrop-filter: blur(20px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 50px rgba(139, 92, 246, 0.2);
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(139, 92, 246, 0.8), transparent);
        }

        .card h2 {
            color: #8b5cf6;
            margin-bottom: 2rem;
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 700;
        }
        
        .card h3 {
            color: #06b6d4;
            margin-bottom: 1.5rem;
            font-size: 1.5rem;
            border-left: 4px solid #06b6d4;
            padding-left: 1rem;
        }

        .upload-area {
            border: 2px dashed #8b5cf6;
            border-radius: 20px;
            padding: 4rem 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.4s ease;
            background: rgba(139, 92, 246, 0.05);
            min-height: 250px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .upload-area:hover {
            border-color: #06b6d4;
            background: rgba(6, 182, 212, 0.05);
            transform: scale(1.02);
        }

        .upload-area.drag-over {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.1);
            transform: scale(1.05);
        }

        .upload-icon {
            font-size: 5rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #8b5cf6, #06b6d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .images-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .image-item {
            position: relative;
            border-radius: 15px;
            overflow: hidden;
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid rgba(139, 92, 246, 0.3);
            transition: all 0.3s ease;
        }

        .image-item:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 30px rgba(139, 92, 246, 0.3);
        }

        .image-item img {
            width: 100%;
            height: 200px;
            object-fit: cover;
        }
        
        .image-overlay-content {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            padding: 15px;
            color: white;
            font-size: 12px;
        }

        .sport-badge {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .sport-football { background: #10b981; color: white; }
        .sport-soccer { background: #10b981; color: white; }
        .sport-tennis { background: #f59e0b; color: white; }
        .sport-basketball { background: #ef4444; color: white; }
        .sport-hockey { background: #06b6d4; color: white; }
        .sport-baseball { background: #3b82f6; color: white; }
        .sport-americanfootball { background: #8b5cf6; color: white; }
        .sport-other { background: #64748b; color: white; }
        .sport-unknown { background: #6b7280; color: white; }

        .analysis-status {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 600;
        }

        .status-pending { background: rgba(245, 158, 11, 0.8); color: white; }
        .status-analyzing { background: rgba(6, 182, 212, 0.8); color: white; }
        .status-completed { background: rgba(16, 185, 129, 0.8); color: white; }
        .status-error { background: rgba(239, 68, 68, 0.8); color: white; }

        .form-group {
            margin-bottom: 2rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.8rem;
            color: #e2e8f0;
            font-weight: 600;
            font-size: 1rem;
        }

        .form-input, .data-input-area {
            width: 100%;
            padding: 15px 20px;
            background: rgba(15, 23, 42, 0.8);
            border: 2px solid rgba(139, 92, 246, 0.2);
            border-radius: 15px;
            color: white;
            font-size: 16px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .form-input:focus, .data-input-area:focus {
            outline: none;
            border-color: #8b5cf6;
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.1);
        }

        .data-input-area {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
            min-height: 200px;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 700;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            text-decoration: none;
            font-size: 16px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #8b5cf6, #06b6d4);
            color: white;
            box-shadow: 0 10px 25px rgba(139, 92, 246, 0.3);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 35px rgba(139, 92, 246, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #b91c1c);
            color: white;
             box-shadow: 0 10px 25px rgba(239, 68, 68, 0.3);
        }
        .btn-danger:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 35px rgba(239, 68, 68, 0.4);
        }

        .btn-secondary {
            background: rgba(100, 116, 139, 0.5);
            color: #e2e8f0;
            border: 1px solid rgba(100, 116, 139, 0.7);
        }
        .btn-secondary:hover {
            background: rgba(100, 116, 139, 0.7);
        }

        .btn-large {
            padding: 20px 40px;
            font-size: 18px;
            width: 100%;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        .alert {
            padding: 1.5rem;
            border-radius: 15px;
            margin: 1.5rem 0;
            display: flex;
            align-items: flex-start;
            gap: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid;
        }

        .alert-success { background: rgba(16, 185, 129, 0.1); border-color: rgba(16, 185, 129, 0.3); color: #10b981; }
        .alert-info { background: rgba(6, 182, 212, 0.1); border-color: rgba(6, 182, 212, 0.3); color: #06b6d4; }
        .alert-warning { background: rgba(245, 158, 11, 0.1); border-color: rgba(245, 158, 11, 0.3); color: #f59e0b; }
        .alert-error { background: rgba(239, 68, 68, 0.1); border-color: rgba(239, 68, 68, 0.3); color: #ef4444; }

        .prompt-box {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(10, 185, 129, 0.4);
            border-radius: 15px;
            padding: 2rem;
            margin: 2rem 0;
            position: relative;
        }

        .prompt-content {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #10b981;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .copy-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid rgba(16, 185, 129, 0.4);
            color: #10b981;
            padding: 8px 16px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .copy-btn:hover { background: rgba(16, 185, 129, 0.3); }

        /* Enhanced Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(15px);
            transition: opacity 0.3s ease;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
            transition: opacity 0.3s ease;
        }

        .loading-content {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            padding: 3rem;
            border-radius: 25px;
            text-align: center;
            border: 2px solid #8b5cf6;
            box-shadow: 0 25px 50px rgba(0,0,0,0.7);
            max-width: 500px;
            width: 90%;
            position: relative;
            overflow: hidden;
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }

        .loading-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(139, 92, 246, 0.1), transparent);
            animation: shimmer 2s infinite;
        }

        .modal-content {
            background: rgba(15, 23, 42, 0.95);
            padding: 3rem;
            border-radius: 25px;
            text-align: center;
            border: 1px solid rgba(139, 92, 246, 0.3);
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }
        
        .modal-overlay:not(.hidden) .modal-content {
            transform: scale(1);
        }

        .loading-overlay:not(.hidden) .loading-content {
            transform: scale(1);
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .spinner {
            width: 80px;
            height: 80px;
            border: 6px solid #334155;
            border-top: 6px solid #8b5cf6;
            border-right: 6px solid #a855f7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 2rem;
            position: relative;
        }

        .spinner::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            border: 3px solid transparent;
            border-top: 3px solid #c084fc;
            border-radius: 50%;
            animation: spin 0.5s linear infinite reverse;
            transform: translate(-50%, -50%);
        }

        /* Progress Bar Container */
        .progress-container {
            width: 100%;
            margin: 2rem 0;
            position: relative;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: #334155;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #8b5cf6, #a855f7, #c084fc);
            border-radius: 10px;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
            width: 0%;
        }

        .progress-fill::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: progress-shimmer 1.5s infinite;
        }

        @keyframes progress-shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .progress-text {
            text-align: center;
            margin-top: 1rem;
            font-size: 1.2rem;
            font-weight: 600;
            color: #8b5cf6;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .progress-percentage {
            font-size: 2.5rem;
            font-weight: 700;
            color: #c084fc;
            margin: 0.5rem 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .loading-details {
            margin-top: 1.5rem;
            padding: 1rem;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 10px;
            border: 1px solid #374151;
            text-align: left;
        }

        .loading-step {
            color: #94a3b8;
            font-size: 0.9rem;
            margin: 0.5rem 0;
            display: flex;
            align-items: center;
            transition: all 0.3s ease;
        }

        .loading-step.active {
            color: #8b5cf6;
            font-weight: 600;
        }

        .loading-step.completed {
            color: #10b981;
        }

        .loading-step::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 0.5rem;
            background: #4b5563;
            flex-shrink: 0;
        }

        .loading-step.active::before {
            background: #8b5cf6;
            animation: pulse-dot 1s infinite;
        }

        .loading-step.completed::before {
            background: #10b981;
            content: '✓';
            color: white;
            font-size: 0.6rem;
            text-align: center;
            line-height: 8px;
            font-weight: bold;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulse { 
            0%, 100% { transform: scale(1); opacity: 1; } 
            50% { transform: scale(1.02); opacity: 0.8; } 
        }

        .tab-content { display: none; animation: fadeIn 0.5s ease; }
        .tab-content.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        .hidden { display: none !important; }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .stat-card {
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 2rem;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #8b5cf6, #06b6d4, #10b981);
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #8b5cf6, #06b6d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stat-label { color: #94a3b8; font-size: 1rem; font-weight: 500; }

        .bet-recommendations { display: grid; gap: 1rem; margin-top: 2rem; }
        .bet-card { background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 15px; padding: 1.5rem; position: relative; }
        .parlay-card { border-left: 5px solid #f59e0b; }
        .parlay-leg { background: rgba(0,0,0,0.2); padding: 0.75rem; border-radius: 10px; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;}
        
        .bet-confidence { position: absolute; top: 15px; right: 15px; padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: 600; }
        .confidence-high { background: #10b981; color: white; }
        .confidence-medium { background: #f59e0b; color: white; }
        .confidence-low { background: #ef4444; color: white; }

        .recommendation-section {
            margin-bottom: 3rem;
        }

        .section-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: #e2e8f0;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #8b5cf6;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .recommendation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1.5rem;
        }

        .recommendation-card {
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 1.5rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            border-left: 5px solid;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .recommendation-card.single { 
            border-left-color: #06b6d4; 
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(6, 182, 212, 0.05));
        }
        .recommendation-card.parlay { 
            border-left-color: #f59e0b; 
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(245, 158, 11, 0.05));
        }

        .recommendation-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 50px rgba(0,0,0,0.4);
            border-left-width: 8px;
        }

        .profit-display {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(16, 185, 129, 0.1));
            border: 2px solid rgba(16, 185, 129, 0.5);
            border-radius: 15px;
            padding: 1.5rem;
            margin: 1rem 0;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .profit-display::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(16, 185, 129, 0.1) 0%, transparent 70%);
            animation: pulse 3s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        .profit-amount {
            font-size: 2.5rem;
            font-weight: 900;
            color: #10b981;
            text-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
            position: relative;
        }

        .math-formula {
            background: rgba(99, 102, 241, 0.1);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 10px;
            padding: 0.75rem;
            margin: 0.5rem 0;
            font-family: 'Monaco', 'Menlo', monospace;
            color: #a5b4fc;
            overflow-x: auto;
            line-height: 1.8;
            text-align: center;
        }
        
        .math-formula .MathJax {
            color: #e2e8f0 !important;
        }
        
        .math-formula mjx-container {
            margin: 0.5rem 0 !important;
        }

        .bet-metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            margin: 0.5rem 0;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.2s ease;
        }

        .bet-metric:hover {
            background: rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .bet-metric-label {
            color: #94a3b8;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .bet-metric-value {
            font-weight: 700;
            font-size: 1.1rem;
        }

        .rec-header {
            font-weight: 600;
            color: #e2e8f0;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
        }
        
        .rec-market {
             font-weight: bold;
             color: #06b6d4;
        }
        
        .rec-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            font-size: 0.9rem;
            margin-top: 1rem;
        }
        .rec-details div {
            background: rgba(0,0,0,0.2);
            padding: 0.5rem;
            border-radius: 8px;
        }
        .rec-details strong {
            color: #94a3b8;
            margin-right: 0.5rem;
        }
        .rec-parlay-leg {
            background: rgba(0,0,0,0.3);
            padding: 0.75rem;
            border-radius: 10px;
            margin-bottom: 0.5rem;
            border-left: 3px solid #64748b;
        }

        @media (max-width: 768px) {
            .container { padding: 15px; }
            .header h1 { font-size: 2.5rem; }
            .nav-tabs { flex-wrap: wrap; gap: 8px; }
            .nav-tab { padding: 12px 16px; font-size: 14px; }
            .stats-grid { grid-template-columns: 1fr; }
            .images-container { grid-template-columns: 1fr; }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1 id="app-title" data-lang="title">🎯 Advanced Sports Betting Analyzer</h1>
            <p id="app-subtitle" data-lang="subtitle" style="color: #94a3b8; font-size: 1.2rem;">Professional Multi-Sport AI Analysis</p>
            <div class="language-selector">
                <button class="lang-btn" data-lang="en">EN</button>
                <button class="lang-btn" data-lang="hu">HU</button>
            </div>
        </header>

        <nav class="nav-tabs" role="tablist">
            <button class="nav-tab active" role="tab" aria-selected="true" aria-controls="setup" data-tab="setup" data-lang="navSettings">🔧 API Settings</button>
            <button class="nav-tab" role="tab" aria-selected="false" aria-controls="upload" data-tab="upload" data-lang="navTips">📸 Image Collection</button>
            <button class="nav-tab" role="tab" aria-selected="false" aria-controls="analysis" data-tab="analysis" data-lang="navCalculator">🔍 Analysis & Data Processing</button>
            <button class="nav-tab" role="tab" aria-selected="false" aria-controls="results" data-tab="results" data-lang="navPortfolio">💎 Results</button>
            <button class="nav-tab" role="tab" aria-selected="false" aria-controls="math" data-tab="math" data-lang="navMath">📐 Mathematics</button>
            <button class="nav-tab" role="tab" aria-selected="false" aria-controls="guide" data-tab="guide" data-lang="navGuide">📘 Guide</button>
        </nav>

        <main>
            <!-- API Setup Tab -->
            <div id="setup" role="tabpanel" class="tab-content active">
                <div class="card">
                    <h2 data-lang="apiConfigTitle">🔑 OpenAI API Configuration</h2>
                    <div class="form-group">
                        <label class="form-label" for="apiKey" data-lang="apiKeyLabel">OpenAI API Key (GPT-4o Vision)</label>
                        <input type="password" id="apiKey" class="form-input" data-lang-placeholder="apiKeyPlaceholder" onchange="validateApiKey()">
                    </div>
                    <button class="btn btn-primary" onclick="testApiConnection()" id="testApiBtn" disabled data-lang="testApiButton">
                        🔍 <span data-lang="testApiButton">Test API Connection</span>
                    </button>
                    <div id="apiStatus" class="alert alert-info hidden" role="status">
                        <span>ℹ️</span>
                        <span data-lang="apiStatusText">API status...</span>
                    </div>
                </div>

                <div class="card">
                    <h2 data-lang="aiModelTitle">🤖 AI Model Selection</h2>
                    <div class="alert alert-info">
                        <span>💡</span>
                        <div>
                            <strong data-lang="aiModelInfoTitle">Advanced AI Analysis:</strong><br>
                            <span data-lang="aiModelInfoText">Select an AI model for complex text analysis (weather conditions, player injuries, tactical analysis). This is optional and enhances the mathematical calculations.</span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="aiModel" data-lang="aiModelLabel">AI Model for Complex Analysis (Optional)</label>
                        <select id="aiModel" class="form-input">
                            <option value="none" data-lang="aiModelNone">None (Basic Analysis Only)</option>
                            <option value="chatgpt" data-lang="aiModelChatGPT">ChatGPT-4o</option>
                            <option value="deepseek" data-lang="aiModelDeepSeek">DeepSeek</option>
                            <option value="perplexity" data-lang="aiModelPerplexity">Perplexity</option>
                            <option value="gemini" data-lang="aiModelGemini">Google Gemini</option>
                        </select>
                        <small style="color: #94a3b8;" data-lang="aiModelHint">Advanced models can analyze weather, injuries, and tactical factors for more accurate predictions.</small>
                    </div>
                    <div class="form-group" id="aiApiKeyGroup" style="display: none;">
                        <label class="form-label" for="aiApiKey" data-lang="aiApiKeyLabel">AI Model API Key (Optional)</label>
                        <input type="password" id="aiApiKey" class="form-input" data-lang-placeholder="aiApiKeyPlaceholder">
                        <small style="color: #94a3b8;" data-lang="aiApiKeyHint">Required only for automated analysis. Leave empty for manual prompts.</small>
                    </div>
                    <div class="alert alert-info" style="margin-top: 1rem;">
                        <span>🤖</span>
                        <div>
                            <strong data-lang="autoProcessingTitle">Automatikus feldolgozás:</strong><br>
                            <span data-lang="autoProcessingText">Ha megadsz AI modellt és API kulcsot, a program automatikusan feldolgozza a prompt válaszát és betölti az eredményeket. Ha nincs AI modell, manuálisan kell beillesztened a JSON választ.</span>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" id="enableAutoDataSearch" style="margin-right: 0.5rem;">
                            <span data-lang="enableAutoDataSearchLabel">🔍 Automatikus Adatkeresés (Perplexity API)</span>
                        </label>
                        <small style="color: #94a3b8; display: block; margin-top: 0.5rem;" data-lang="autoDataSearchHint">Ha bekapcsolod, a program automatikusan megkeresi az interneten az összes szükséges adatot minden meccshez. Perplexity API kulcs szükséges.</small>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" id="enablePostAnalysisSearch" style="margin-right: 0.5rem;">
                            <span data-lang="enablePostAnalysisSearchLabel">🤖 GPT Elemzés Után Auto-Adatkeresés</span>
                        </label>
                        <small style="color: #94a3b8; display: block; margin-top: 0.5rem;" data-lang="postAnalysisSearchHint">Ha bekapcsolod, a GPT képelemzés befejezése után automatikusan elindul a teljes adatkeresés minden bonyolult adattal. Perplexity API kulcs szükséges.</small>
                    </div>
                </div>

                <div class="card">
                    <h2 data-lang="bankrollTitle">💰 Bankroll Management</h2>
                    <div class="form-group">
                        <label class="form-label" for="capital" data-lang="capitalLabel">Available Capital (EUR)</label>
                        <input type="number" id="capital" class="form-input" value="1000" min="100">
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="maxRisk" data-lang="maxRiskLabel">Maximum Portfolio Risk (%)</label>
                        <input type="number" id="maxRisk" class="form-input" value="15" min="5" max="20">
                        <small style="color: #94a3b8;" data-lang="maxRiskHint">Recommended: max 15% for conservative approach</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="kellyModifierSingle" data-lang="kellyModifierSingleLabel">Kelly Modifier (Single)</label>
                        <input type="number" id="kellyModifierSingle" class="form-input" value="0.25" min="0.1" max="0.5" step="0.05">
                        <small style="color: #94a3b8;" data-lang="kellyModifierSingleHint">Conservative Kelly applied to single bets</small>
                    </div>
                     <div class="form-group">
                        <label class="form-label" for="kellyModifierParlay" data-lang="kellyModifierParlayLabel">Kelly Modifier (Parlay)</label>
                        <input type="number" id="kellyModifierParlay" class="form-input" value="0.1" min="0.05" max="0.2" step="0.01">
                        <small style="color: #94a3b8;" data-lang="kellyModifierParlayHint">Extra conservative Kelly applied to parlay bets</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="comboStrategy" data-lang="comboStrategyLabel">Parlay Strategy</label>
                        <select id="comboStrategy" class="form-input">
                            <option value="prob" data-lang="comboStrategyHighProb">High Probability Parlays</option>
                            <option value="ev" data-lang="comboStrategyHighEV">High EV Parlays</option>
                        </select>
                        <small style="color: #94a3b8;" data-lang="comboStrategyHint">Choose whether probability or expected value should be the primary focus when generating parlays.</small>
                    </div>
                </div>
            </div>

            <!-- Image Upload Tab -->
            <div id="upload" role="tabpanel" class="tab-content">
                <div class="card">
                    <h2 data-lang="dataInputTitle">📊 Multi-Sport Data Collection</h2>
                    
                    <!-- Input Method Selection -->
                    <div style="margin-bottom: 2rem;">
                        <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                            <button class="btn btn-secondary" id="imageInputBtn" onclick="switchInputMode('image')" data-lang="imageInputMode">📸 Image Upload</button>
                            <button class="btn btn-secondary" id="textInputBtn" onclick="switchInputMode('text')" data-lang="textInputMode">📝 Text Input</button>
                        </div>
                    </div>
                    
                    <!-- Text Input Mode -->
                    <div id="textInputMode" style="display: none;">
                        <div class="alert alert-info">
                            <span>🎯</span>
                            <div>
                                <strong data-lang="textInputInfoTitle">Paste betting information:</strong><br>
                                <span data-lang="textInputInfoText">• Copy and paste from betting websites, forums, or tipster messages<br>
                                • Include match names, odds, markets, and any additional context<br>
                                • AI will extract all relevant information automatically</span>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="bettingTextInput" data-lang="bettingTextLabel">Betting Information (Text)</label>
                            <textarea id="bettingTextInput" class="data-input-area" rows="10" data-lang-placeholder="bettingTextPlaceholder"></textarea>
                        </div>
                        <button class="btn btn-primary" onclick="processBettingText()" id="processTextBtn" data-lang="processTextButton">
                            🔍 Process Text Data
                        </button>
                    </div>
                    
                    <!-- Image Input Mode -->
                    <div id="imageInputMode">
                        <h3 data-lang="imageUploadTitle">📸 Multi-Sport Image Collection</h3>
                    <div class="alert alert-info">
                        <span>🎯</span>
                        <div>
                            <strong data-lang="uploadInfoTitle">Upload all relevant screenshots:</strong><br>
                            <span data-lang="uploadInfoList">• Multiple sports simultaneously (football, tennis, basketball, hockey)<br>
                            • Various markets (match results, goals, points, games)<br>
                            • Multiple bookmaker images for comparison<br>
                            • Statistical page images for detailed analysis (You can also paste with Ctrl+V!)</span>
                        </div>
                    </div>
                    
                    <div class="upload-area" id="uploadArea">
                        <div class="upload-icon">🤖</div>
                        <h3 data-lang="imageUploadAreaTitle">Sports Betting Image Upload</h3>
                        <p style="color: #94a3b8; margin: 1rem 0;" data-lang="imageUploadAreaText">
                            Drag files here, click the button, or paste from clipboard (Ctrl+V)
                        </p>
                        <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()" data-lang="selectImagesButton">
                            📁 Select Images
                        </button>
                    </div>

                    <input type="file" id="fileInput" multiple accept="image/*" class="hidden">
                    <div id="imagesContainer" class="images-container"></div>
                    
                    <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                        <button class="btn btn-primary" onclick="startInitialAnalysis()" id="startAnalysisBtn" disabled style="flex-grow: 1;" data-lang="initialAnalysisButton">
                            🚀 Initial GPT-4o Analysis
                        </button>
                            <button class="btn btn-danger" onclick="confirmDeleteImages()" id="deleteAllBtn" disabled data-lang="deleteImagesButton">
                                🗑️ Delete Images Only
                            </button>
                            <button class="btn btn-danger" onclick="confirmClearAllData()" id="clearDataBtn" data-lang="clearAllDataButton">
                                💥 Clear All Data
                        </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Analysis & Data Processing Tab -->
            <div id="analysis" role="tabpanel" class="tab-content">
                 <div class="card">
                    <h2 data-lang="analysisTitle">🔍 Analysis & Data Processing</h2>
                    <div id="analysisResultsContainer">
                         <div class="alert alert-info">
                            <span>📊</span>
                            <span data-lang="analysisInfo">Image analysis results and data retrieval prompts will appear here.</span>
                        </div>
                    </div>
                    <div id="dataProcessingContainer" class="hidden">
                        <div class="form-group">
                            <label class="form-label" for="retrievedData" data-lang="retrievedDataLabel">Inserted Data (JSON response from LLM)</label>
                            <textarea id="retrievedData" class="data-input-area" data-lang-placeholder="retrievedDataPlaceholder"></textarea>
                        </div>
                        <div style="display: flex; gap: 1rem; align-items: center;">
                            <button class="btn btn-primary btn-large" onclick="processAllRetrievedData()" id="processDataBtn" disabled data-lang="processDataButton" style="flex: 1;">
                            🔄 Process All Data and Generate Recommendations
                        </button>
                            <button class="btn btn-secondary" onclick="testEmergencyJsonRepair()" data-lang="testJsonRepair" style="white-space: nowrap;">
                                🔧 Test JSON Repair
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Results Tab -->
            <div id="results" role="tabpanel" class="tab-content">
                <div class="card">
                    <h2 data-lang="resultsTitle">💎 Portfolio Results</h2>
                    
                    <div id="portfolioSummary" class="stats-grid hidden" style="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));">
                        <!-- Populated by JS -->
                    </div>

                    <div id="resultsContainer" class="hidden" style="margin-top: 2rem;">
                        <div id="recommendations-container">
                            <!-- Populated by JS -->
                        </div>
                    </div>

                    <div id="noResults" class="alert alert-info">
                        <span>📈</span>
                        <span data-lang="resultsInfo">Recommendations will appear after all data has been processed.</span>
                    </div>
                </div>
            </div>

            <!-- Math Tab -->
            <div id="math" role="tabpanel" class="tab-content">
                <div class="card">
                    <h2 data-lang="mathTitle">📐 Mathematics Behind the Scenes</h2>
                    <div style="color: #94a3b8; margin-bottom: 2rem;" data-lang="mathInfo">Below you will find all the formulas and their explanations that the program uses to calculate sports betting recommendations.</div>
                    <div style="font-size: 1.1rem; line-height: 1.7;">
                        <h3 data-lang="mathEdgeTitle">1. 📊 Professzionális Értékbecslés és Előny (Edge)</h3>
                        <div><b data-lang="mathFormulaLabel">Alapképlet:</b></div>
                        <div class="math-formula">$$\text{Edge} = p_{\text{valós}} \times o_{\text{fogadóiroda}} - 1$$</div>
                        <div><b>Részletes Edge Számítás:</b></div>
                        <div class="math-formula">$$\text{Edge}(\%) = \left(\frac{P_{\text{becsült}}}{P_{\text{implikált}}} - 1\right) \times 100$$</div>
                        <div style="margin: 0.5rem 0;">ahol $P_{\text{implikált}} = \frac{1}{\text{szorzó}}$ és $P_{\text{becsült}}$ = a saját valószínűségi becslésünk</div>
                        
                        <div><b>🔬 Fejlett EV Számítás Integrált Súlyozással:</b></div>
                        <div class="math-formula">$$\text{EV}_{fejlett} = \text{tét} \times (P_{adj} \times o - 1)$$</div>
                        <div class="math-formula">$$P_{adj} = P_{alap} \times S_{sport} \times W_{időjárás} \times J_{játékos} \times M_{motiváció}$$</div>
                        
                        <div><b>🌤️ Időjárási Kiigazítás (Szabadtéri Sportok):</b></div>
                        <div class="math-formula">$$W_{faktor} = 1 + \alpha \times |T - T_{opt}| + \beta \times v_{szél} + \gamma \times P_{eső} + \delta \times H_{pára} + \epsilon \times \text{Játékstílus}$$</div>
                        <div style="margin: 0.5rem 0;">⚽ Labdarúgás: $T_{opt} = 19°C$, ⚾ Baseball: $T_{opt} = 21°C$, 🎾 Tenisz: $T_{opt} = 22°C$</div>
                        <div style="margin: 0.5rem 0;">🏀 Kosárlabda, 🏒 Jégkorong: $W_{faktor} = 1.0$ (beltéri sportok)</div>
                        <div style="margin: 0.5rem 0;">🌧️ Csapadék hatás: $\gamma = 0.3$ (precíziós csapatoknál), $\epsilon = -0.4$ (sok kis passz)</div>
                        
                        <div><b>👤 Hiányzó Kulcsjátékosok Kritikus Hatása:</b></div>
                        <div class="math-formula">$$J_{faktor} = \prod_{i=1}^{n} (1 - I_i \times K_i \times P_i)$$</div>
                        <div style="margin: 0.5rem 0;">ahol $I_i$ = játékos fontossága (0-1), $K_i$ = kulcsjátékos súly (2.5 ha kulcs, 1.0 ha nem), $P_i$ = pozíció kritikusság</div>
                        <div style="margin: 0.5rem 0;">🎯 Pozíció súlyok: Kapus/Dobó: 3.0, Playmaker: 2.8, Csillagjátékos: 2.5, Alapember: 1.5</div>
                        
                        <div><b>🎯 Sport-specifikus Súlyozás:</b></div>
                        <div class="math-formula">$$S_{sport} = \begin{cases} 
                        0.5 + \frac{G_{impact}}{100} \times 0.8 & \text{🏒 Jégkorong (kapus)} \\
                        0.4 + \frac{P_{impact}}{100} \times 1.0 & \text{⚾ Baseball (dobó)} \\
                        0.6 + \frac{Surf_{adv}}{100} \times 0.6 & \text{🎾 Tenisz (pálya)} \\
                        0.7 + \frac{Star_{impact}}{100} \times 0.5 & \text{⚽ Labdarúgás (csillag)} \\
                        1.0 & \text{egyéb sportok}
                        \end{cases}$$</div>
                        
                        <div><b>💪 Motivációs Kiigazítás:</b></div>
                        <div class="math-formula">$$M_{faktor} = 1.0 + \frac{M_{home} - M_{away}}{100} \times 0.1$$</div>
                        <div style="margin: 0.5rem 0;">ahol $M_{home}, M_{away}$ = motivációs skála (1-100)</div>
                        
                        <div style="margin: 1rem 0;"><b data-lang="mathExplanationLabel">Magyarázat:</b> <span data-lang="mathEdgeExplanation">Az előny a valós valószínűség és a fogadóiroda által implikált valószínűség közötti különbség. A fejlett rendszer sport-specifikus faktorokkal korrigálja a valószínűségeket a pontosabb EV számításért.</span></div>
                        
                        <h3 data-lang="mathKellyTitle">2. 🎯 Fejlett Kelly Kritérium (Optimális Tétarány)</h3>
                        <div><b data-lang="mathFormulaLabel">Klasszikus Kelly Képlet:</b></div>
                        <div class="math-formula">$$f^* = \frac{bp - q}{b} = \frac{p(o-1) - (1-p)}{o-1}$$</div>
                        
                        <div><b>🔬 Fejlett Kelly Kiigazított Valószínűséggel:</b></div>
                        <div class="math-formula">$$f^*_{adj} = \frac{b \times P_{adj} - (1-P_{adj})}{b}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $P_{adj}$ = a sport-specifikus súlyozással kiigazított valószínűség</div>
                        
                        <div><b>Konzervatív Kelly Módosítás:</b></div>
                        <div class="math-formula">$$f_{\text{biztonságos}} = f^*_{adj} \times k_{\text{módosító}} \times M_{\text{piac}}$$</div>
                        <div class="math-formula">$$M_{\text{piac}} = \begin{cases} 
                        0.8 & \text{sarok/kártya piacok} \\
                        0.9 & \text{handicap piacok} \\
                        1.0 & \text{fő piacok}
                        \end{cases}$$</div>
                        
                        <div><b>🎲 Multi-Outcome Kelly (Kombik):</b></div>
                        <div class="math-formula">$$f^*_{kombi} = \frac{\sum_{i=1}^{n} p_i \times b_i - \sum_{i=1}^{n} (1-p_i)}{\prod_{i=1}^{n} b_i}$$</div>
                        <div style="margin: 0.5rem 0;">extra konzervatív módosítóval: $k_{kombi} = 0.1$</div>
                        
                        <div style="margin: 0.5rem 0;"><i data-lang="mathWhereLabel">ahol</i> $b = o - 1$ (nettó szorzó), $p$ = valószínűség, $q = 1 - p$, $k_{\text{módosító}} \in [0.1, 0.5]$</div>
                        <div style="margin: 1rem 0;"><b data-lang="mathExplanationLabel">Magyarázat:</b> <span data-lang="mathKellyExplanation">A Kelly Kritérium matematikailag optimális tétméretet számol a hosszú távú tőkenövekedés maximalizálásához. A fejlett verzió sport-specifikus kiigazításokat és piac-specifikus módosítókat alkalmaz.</span></div>
                        
                        <h3>3. 📈 Professzionális Pontozási Rendszer</h3>
                        <div><b>🏆 Multi-Faktor Pontozás:</b></div>
                        <div class="math-formula">$$\text{Score}_{total} = 0.4 \times S_{EV} + 0.25 \times S_{Kelly} + 0.2 \times S_{conf} + 0.1 \times S_{sport} + 0.05 \times S_{risk}$$</div>
                        
                        <div><b>📊 EV Pontszám (40% súly):</b></div>
                        <div class="math-formula">$$S_{EV} = \min\left(\frac{EV_{százalék}}{25}, 4\right)$$</div>
                        <div style="margin: 0.5rem 0;">Maximum 4 pont 25%+ EV-nél</div>
                        
                        <div><b>🎯 Kelly Hatékonyság (25% súly):</b></div>
                        <div class="math-formula">$$S_{Kelly} = \max\left(0, \min\left(\frac{b \times p - q}{b} \times 20, 3\right)\right)$$</div>
                        <div style="margin: 0.5rem 0;">Maximum 3 pont optimális Kelly frakciónál</div>
                        
                        <div><b>🔬 Kockázat-Hozam Pontszám (5% súly):</b></div>
                        <div class="math-formula">$$S_{risk} = \min\left(\frac{EV}{\sigma}, 1\right) \text{ ahol } \sigma = (o-1)\sqrt{p(1-p)}$$</div>
                        <div style="margin: 0.5rem 0;">Sharpe ráta alapú kockázat-hozam optimalizálás</div>
                        
                        <h3>4. 📈 Bankroll Növekedési és Túlélési Modell</h3>
                        <div><b>Logaritmikus Tőkenövekedés:</b></div>
                        <div class="math-formula">$$\log(W_n) = \log(W_0) + \sum_{i=1}^{n} \log(1 + f_i \times X_i)$$</div>
                        <div><b>Csőd Valószínűség (Ruin Probability):</b></div>
                        <div class="math-formula">$$P_{\text{csőd}} = \left(\frac{1-p}{p}\right)^{\frac{W_0}{\text{átlag tét}}}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $X_i = \begin{cases} b_i & \text{valószínűséggel } p_i \\ -1 & \text{valószínűséggel } 1-p_i \end{cases}$</div>
                        <div style="margin: 1rem 0;"><b>Gyakorlati Jelentés:</b> A logaritmikus modell biztosítja, hogy soha ne fogadjunk el olyan tétet, ami csődbe vihetne. A túlélési valószínűség fordítottan arányos a kockázatvállalással.</div>
                        
                        <h3>5. 🎲 Hosszútávú Nyereségességi Modell</h3>
                        <div><b>Monte Carlo Szimuláció (1000 iteráció):</b></div>
                        <div class="math-formula">$$E[\text{Profit}] = \frac{1}{N} \sum_{i=1}^{N} \sum_{j=1}^{M} \text{Outcome}_{i,j}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $N = 1000$ szimuláció, $M$ = fogadások száma</div>
                        
                        <div><b>Nyerési Arány:</b></div>
                        <div class="math-formula">$$\text{Win Rate} = \frac{\sum_{i=1}^{N} \sum_{j=1}^{M} \mathbb{1}[\text{Win}_{i,j}]}{N \times M}$$</div>
                        
                        <div><b>Maximum Drawdown:</b></div>
                        <div class="math-formula">$$\text{Max DD} = \max_{i} \left(\text{Peak}_{i} - \text{Current}_{i}\right)$$</div>
                        
                        <div><b>Hosszútávú ROI:</b></div>
                        <div class="math-formula">$$\text{ROI}_{long} = \frac{E[\text{Profit}]}{\text{Total Stake}} \times 100$$</div>
                        
                        <div><b>Nyereségességi Konfidencia:</b></div>
                        <div class="math-formula">$$\text{Confidence} = \min\left(95, \max\left(5, 50 + \text{ROI}_{long} \times 2\right)\right)$$</div>
                        
                        <h3 data-lang="mathEVTitle">6. 💰 Várható Érték és ROI Számítások</h3>
                        <div><b data-lang="mathFormulaLabel">Alapvető EV Képlet:</b></div>
                        <div class="math-formula">$$\text{EV} = \text{Tét} \times \text{Edge} = S \times (p \times o - 1)$$</div>
                        <div><b>Részletes EV Felbontás:</b></div>
                        <div class="math-formula">$$\text{EV} = S \times p \times (o-1) - S \times (1-p) = S \times [p \times \text{nyeremény} - (1-p) \times \text{veszteség}]$$</div>
                        <div><b>ROI (Return on Investment):</b></div>
                        <div class="math-formula">$$\text{ROI}(\%) = \frac{\text{EV}}{\text{Tét}} \times 100 = \text{Edge} \times 100$$</div>
                        <div style="margin: 1rem 0;"><b data-lang="mathExplanationLabel">Magyarázat:</b> <span data-lang="mathEVExplanation">A várható érték a fogadás hosszú távú átlagos nyereségét mutatja. Pozitív EV = nyereséges fogadás várhatóan. ROI százalékban fejezi ki a befektetés hatékonyságát.</span></div>
                        
                        <h3>5. 📊 Kockázat Mérése: Variancia és Sharpe Ráta</h3>
                        <div><b>Variancia (Szórás Négyzete):</b></div>
                        <div class="math-formula">$$\text{Var}(X) = p(1-p) \times (\text{nettó szorzó})^2 = p(1-p) \times (o-1)^2$$</div>
                        <div><b>Szórás (Standard Deviáció):</b></div>
                        <div class="math-formula">$$\sigma = \sqrt{\text{Var}(X)} = (o-1)\sqrt{p(1-p)}$$</div>
                        <div><b>Sharpe Ráta (Kockázat-Hozam Arány):</b></div>
                        <div class="math-formula">$$\text{Sharpe} = \frac{\text{EV}}{\sigma} = \frac{S \times \text{Edge}}{S \times (o-1)\sqrt{p(1-p)}} = \frac{\text{Edge}}{(o-1)\sqrt{p(1-p)}}$$</div>
                        <div style="margin: 1rem 0;"><b>Gyakorlati Használat:</b> Magas Sharpe ráta = jobb kockázat-hozam profil. Optimális fogadások: Sharpe > 0.5</div>
                        
                        <h3>7. 🏆 Sport-Specifikus Matematikai Modellek</h3>
                        
                        <div><b>⚽ Labdarúgás - Dixon-Coles Poisson Modell:</b></div>
                        <div class="math-formula">$$\lambda_{home} = \alpha \times \beta_{home} \times \gamma_{away} \times W_{weather}$$</div>
                        <div class="math-formula">$$\lambda_{away} = \alpha \times \beta_{away} \times \gamma_{home} \times W_{weather}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $\alpha$ = liga átlag, $\beta$ = támadóerő, $\gamma$ = védőerő, $W$ = időjárás hatás</div>
                        
                        <div><b>🏒 Jégkorong - Fejlett Corsi/Fenwick + Kapus Modell:</b></div>
                        <div class="math-formula">$$\text{Goals}_{expected} = \text{Corsi}\% \times \text{Shooting}\% \times (1 - \text{Save}\%)_{opponent}$$</div>
                        <div class="math-formula">$$\text{Win Prob} = \frac{\text{Goals}_{home}}{\text{Goals}_{home} + \text{Goals}_{away}} \times G_{impact}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $G_{impact}$ = kapus hatás (0.7-1.3 range)</div>
                        
                        <div><b>⚾ Baseball - Pitagorasz + Sabermetrics:</b></div>
                        <div class="math-formula">$$\text{Win}\% = \frac{\text{RS}^{1.83}}{\text{RS}^{1.83} + \text{RA}^{1.83}} \times P_{impact} \times W_{weather}$$</div>
                        <div class="math-formula">$$\text{Run Factor} = 1 + 0.1 \times \frac{T-21}{10} + 0.05 \times \text{Wind Speed}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $P_{impact}$ = dobó hatás (0.6-1.4), $W_{weather}$ = időjárás hatás</div>
                        
                        <div><b>🎾 Tenisz - Markov Lánc Modell:</b></div>
                        <div class="math-formula">$$P(\text{Match}) = P(\text{Set})^{n} \times \text{Surface}_{factor} \times I_{impact}$$</div>
                        <div class="math-formula">$$P(\text{Set}) = P(\text{Game})^{6} \times \text{Serve}_{advantage}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $I_{impact}$ = sérülés hatás (0.5-1.0), kritikus egyéni sportban</div>
                        
                        <div><b>🏀 Kosárlabda - Négy Faktor Modell:</b></div>
                        <div class="math-formula">$$\text{Efficiency} = 0.4 \times \text{eFG}\% + 0.25 \times \text{TOV}\% + 0.2 \times \text{OREB}\% + 0.15 \times \text{FT Rate}$$</div>
                        <div class="math-formula">$$\text{Points} = \text{Efficiency} \times \text{Possessions} \times \text{Pace} \times F_{fatigue}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $F_{fatigue} = e^{-\alpha \times \text{rest days}}$ (back-to-back penalty)</div>
                        
                        <h3 data-lang="mathParlayTitle">8. 🔗 Kombinált Fogadások Matematikája</h3>
                        <div><b data-lang="mathParlayProbLabel">Együttes Valószínűség (Függetlenség Feltételezés):</b></div>
                        <div class="math-formula">$$P_{\text{kombi}} = \prod_{i=1}^{n} p_i$$</div>
                        <div><b data-lang="mathParlayOddsLabel">Kombinált Szorzók:</b></div>
                        <div class="math-formula">$$O_{\text{kombi}} = \prod_{i=1}^{n} o_i$$</div>
                        <div><b>🔗 Fejlett Korreláció Kiigazítás:</b></div>
                        <div class="math-formula">$$P_{\text{kombi,korr}} = P_{\text{kombi}} \times C_{penalty}$$</div>
                        <div class="math-formula">$$C_{penalty} = \begin{cases} 
                        0.8 & \text{ha volatilis piacok (sarok/kártya)} \\
                        0.9 & \text{ha nem fő piacok} \\
                        1.0 & \text{ha független fő piacok}
                        \end{cases}$$</div>
                        
                        <div><b>Kombinált Edge Fejlett Számítás:</b></div>
                        <div class="math-formula">$$\text{Edge}_{\text{kombi}} = P_{\text{kombi,korr}} \times O_{\text{kombi}} - 1$$</div>
                        <div class="math-formula">$$\text{Kelly}_{\text{kombi}} = \frac{(O_{\text{kombi}} - 1) \times P_{\text{kombi,korr}} - (1 - P_{\text{kombi,korr}})}{O_{\text{kombi}} - 1}$$</div>
                        <div style="margin: 0.5rem 0;">Extra konzervatív módosító: $k_{kombi} = 0.1$ (max 2% tőke)</div>
                        
                        <div style="margin: 1rem 0;"><b data-lang="mathExplanationLabel">Magyarázat:</b> <span data-lang="mathParlayExplanation">A fejlett kombinált fogadási modell figyelembe veszi a piaci korrelációkat és alkalmaz extra konzervatív módosítókat a magasabb kockázat miatt.</span></div>
                        
                        <h3 data-lang="mathRiskTitle">9. 🛡️ Professzionális Kockázatkezelési Mutatók</h3>
                        <div><b>📊 Portfólió Kockázat:</b></div>
                        <div class="math-formula">$$\sigma_{\text{portfólió}} = \sqrt{\sum_{i=1}^{n} w_i^2 \sigma_i^2 + \sum_{i=1}^{n} \sum_{j \neq i} w_i w_j \sigma_i \sigma_j \rho_{ij}}$$</div>
                        
                        <div><b>🎯 Dinamikus Tét Limitek:</b></div>
                        <div class="math-formula">$$\text{Min Stake} = \max(5, 0.001 \times \text{Bankroll})$$</div>
                        <div class="math-formula">$$\text{Max Risk} = 0.05 \times \text{Bankroll} \text{ (single)}, 0.02 \times \text{Bankroll} \text{ (parlay)}$$</div>
                        
                        <div><b>📈 Portfólió Optimalizálás:</b></div>
                        <div class="math-formula">$$\text{Scale Factor} = \min\left(1, \frac{\text{Max Portfolio Risk}}{\text{Planned Total Stake}}\right)$$</div>
                        <div style="margin: 0.5rem 0;">Automatikus skálázás ha a tervezett tét túllépi a maximális kockázatot</div>
                        
                        <div><b>🏆 Nyereségességi Küszöbök:</b></div>
                        <div class="math-formula">$$\text{Minimum Kritériumok} = \begin{cases} 
                        \text{Edge} \geq 3\% & \text{singles} \\
                        \text{Edge} \geq 6\% & \text{parlays} \\
                        \text{Confidence} \geq 0.3 & \text{mind} \\
                        \text{EV} \geq 0.5 & \text{mind}
                        \end{cases}$$</div>
                        
                        <div><b>📊 Kihasználtsági Ráta:</b></div>
                        <div class="math-formula">$$\rho_{\text{kihasználás}} = \frac{\sum_{i=1}^{n} S_i}{W_{\text{teljes}}} \leq \rho_{\max} = 15\%$$</div>
                        
                        <div><b>🎲 Diverzifikációs Metrikák:</b></div>
                        <div class="math-formula">$$D = \frac{\text{Egyedi meccsek száma}}{\text{Összes fogadás}} \times \frac{\text{Sportágak száma}}{\text{Összes sportág}}$$</div>
                        <div style="margin: 1rem 0;"><b>🏅 Optimális Portfólió Kritériumok:</b> D > 0.6, max 15% kihasználás, min 3% edge, Sharpe > 0.5, Long-term ROI > 10%</div>
                        <br>
                        <!-- START SPORT-SPECIFIC MODELS -->
                        <h2 style="margin-top:2rem; color:#8b5cf6;" data-lang="sportModelsTitle">📊 Sport-Specific Mathematical Models</h2>
                        <p style="color:#94a3b8;" data-lang="sportModelsInfo">The following section details the statistical/probabilistic models applied by the system for different sports to refine probability estimates. These models provide a more accurate picture than simple statistics.</p>
                        <br>
                        <h3 data-lang="footballTitle">⚽ Labdarúgás</h3>
                        <div><b data-lang="footballDixonColes">Dixon-Coles Poisson modell gólszámokhoz</b></div>
                        <div class="math-formula">
                            $$\lambda_{hazai} = \alpha_{hazai} \times \beta_{vendég} \times \gamma_{pálya}$$
                            $$P(X=x, Y=y) = \tau(x,y) \times \frac{e^{-\lambda_{hazai}} \lambda_{hazai}^x}{x!} \times \frac{e^{-\lambda_{vendég}} \lambda_{vendég}^y}{y!}$$
                                </div>
                        <div style="margin: 0.5rem 0;">ahol $\tau$ a Dixon-Coles kiigazítás:</div>
                        <div class="math-formula">
                            $$\tau(x,y) = \begin{cases}
                                1 - \lambda_{hazai} \times \lambda_{vendég} \times \rho & \text{ha } x=y=0 \\
                                1 + \lambda_{hazai} \times \rho & \text{ha } x=0, y=1 \\
                                1 + \lambda_{vendég} \times \rho & \text{ha } x=1, y=0 \\
                                1 - \rho & \text{ha } x=y=1 \\
                                1 & \text{egyéb esetben}
                            \end{cases}$$
                            </div>
                            
                        <div><b data-lang="footballSkellam">Skellam eloszlás gólkülönbséghez</b></div>
                        <div class="math-formula">
                            $$P(D = k) = e^{-(\lambda_{hazai} + \lambda_{vendég})} \times \left(\frac{\lambda_{hazai}}{\lambda_{vendég}}\right)^{k/2} \times I_{|k|}(2\sqrt{\lambda_{hazai} \times \lambda_{vendég}})$$
                                </div>
                        <div style="margin: 0.5rem 0;">ahol $I_k$ az első típusú módosított Bessel-függvény.</div>
                        <br>
                        <div><b>Várható Gólok (xG) Modell Bayes-i Frissítéssel</b></div>
                        <div class="math-formula">
                            $$xG = \sum_{i=1}^{n} P(\text{gól}_i | \theta_i)$$
                            $$\theta_i \sim \text{Beta}(\alpha_i, \beta_i)$$
                            </div>
                            
                        <div><b data-lang="footballCornersModel">Szögletek és Lapok Matematikai Modell</b></div>
                        <div class="math-formula">
                            $$\mu_{szöglet} = \alpha_{támadás} \times \beta_{védelem} \times \gamma_{stílus} \times \delta_{időjárás}$$
                            $$\mu_{lap} = \rho_{játékvezető} \times \sigma_{agresszivitás} \times \tau_{fontosság}$$
                            $$P(\text{szöglet} > n) = 1 - F_{Poisson}(n; \mu_{szöglet})$$
                                </div>
                        <div style="margin: 0.5rem 0;">Időjárási hatás: $\delta_{időjárás} = 1 + (0.1 \times \text{szélsebesség} + 0.05 \times \text{eső intenzitás})$</div>
                        
                        <div><b data-lang="football1x2Model">1x2 Piaci Valószínűségi Modell</b></div>
                        <div class="math-formula">
                            $$P(\text{Hazai}) = \sum_{h>v} P(H=h, V=v)$$
                            $$P(\text{Döntetlen}) = \sum_{h=v} P(H=h, V=v)$$
                            $$P(\text{Vendég}) = \sum_{v>h} P(H=h, V=v)$$
                                </div>
                        <div style="margin: 0.5rem 0;">Időjárási kiigazítás: $P_{adj} = P_{alap} \times (1 + \text{időjárás faktor})$</div>
                        <br>
                        <h3 data-lang="tennisTitle">🎾 Tenisz</h3>
                        <div><b data-lang="tennisEloModel">Fejlett Elo-alapú Pont Előrejelzés</b></div>
                        <div class="math-formula">
                            $$Elo_{adj} = Elo_{alap} + \text{pálya kiigazítás} + \text{forma faktor} + \text{fáradtság faktor}$$
                            $$P(\text{pont nyerés}) = \frac{1}{1 + 10^{(Elo_{ellenfél} - Elo_{játékos})/400}}$$
                            $$P_{szolgálat} = \frac{p^4 \times (15 - 4p - 10p^2)}{1 - 2p + 2p^2}$$
                            </div>
                        <div style="margin: 0.5rem 0;">Sérülés faktor: $P_{adj} = P \times (1 - 0.2 \times \text{sérülés súlyosság})$</div>
                        
                        <div><b data-lang="tennisMarkov">Markov-lánc modell szolgálat játék/szett valószínűséghez</b></div>
                        <div class="math-formula">
                            $$p = \text{A játékos pontnyerési valószínűsége saját szolgálásnál}$$
                            $$\text{Állapottér: } (a,b) \text{ pontállás a játékban}$$
                            $$\text{Átmenetek: } (a,b) \rightarrow (a+1,b) \text{ valószínűséggel } p$$
                                </div>
                        <div style="margin: 0.5rem 0;">Időjárási hatás: $p_{adj} = p \times (1 - 0.02 \times \text{szélsebesség} - 0.01 \times \text{hőmérséklet eltérés})$</div>
                        <div style="margin: 1rem 0;" data-lang="tennisMarkovExplanation">A modell a teniszmeccset állapotok sorozataként kezeli (pontok, játékok, szettek). Az időjárási körülmények jelentősen befolyásolják a szerva pontosságát és a labda röppályáját.</div>
                        
                        <div><b data-lang="tennisSurfaceModel">Pálya-specifikus Teljesítmény Modell</b></div>
                        <div class="math-formula">
                            $$\text{Pálya faktor} = \text{salak faktor} \times (1 + \text{páratartalom hatás})$$
                            $$\text{Sebesség kiigazítás} = \frac{\text{labda sebesség pálya}}{\text{labda sebesség alapvető}}$$
                            $$\text{Pattanás faktor} = \text{pálya együttható} \times \text{hőmérséklet faktor}$$
                                </div>
                        <br>
                        <h3>🏀 Kosárlabda</h3>
                        <div><b>Fejlett Birtoklás-alapú Modell</b></div>
                        <div class="math-formula">
                            $$\text{Birtoklások} = 0.5 \times (FGA + 0.4 \times FTA - OREB + TOV)$$
                            $$\text{Támadó hatékonyság} = \frac{\text{Pontok}}{\text{Birtoklások}} \times 100$$
                            $$\text{Várható pontok} = \text{TámHat} \times \text{Birtoklások} \times \text{tempó faktor}$$
                        </div>
                        
                        <div><b>Négy Faktor Fejlett Modell</b></div>
                        <div class="math-formula">
                            $$eFG\% = \frac{FGM + 0.5 \times 3PM}{FGA}$$
                            $$TOV\% = \frac{TOV}{FGA + 0.44 \times FTA + TOV}$$
                            $$OREB\% = \frac{OREB}{OREB + Opp\_DREB}$$
                                </div>
                        
                        <div><b>Fáradtság és Menetrend Hatás Modell</b></div>
                        <div class="math-formula">
                            $$\text{Fáradtság faktor} = e^{-\alpha \times \text{pihenő napok}} \times \text{utazási távolság büntetés}$$
                            $$\text{Teljesítmény adj} = \text{Alap teljesítmény} \times (1 + \text{fáradtság faktor})$$
                                </div>
                        <br>
                        <h3>🏒 Jégkorong - Fejlett Corsi/Fenwick Modellek</h3>
                        <div><b>🎯 Advanced Corsi/Fenwick Model</b></div>
                        <div class="math-formula">$$\text{Corsi}\% = \frac{SF + BS + MS}{SF + BS + MS + SA + BA + MA}$$</div>
                        <div class="math-formula">$$xG = \sum_{i=1}^{n} Q_i \times D_i \times A_i \times S_i$$</div>
                        <div class="math-formula">$$\text{PDO} = (\text{Shooting}\% + \text{Save}\%) \times 100$$</div>
                        <div style="margin: 0.5rem 0;">ahol $SF$ = lövések, $BS$ = blokkolt, $MS$ = mellé, $Q_i$ = lövés minőség, $D_i$ = távolság faktor, $A_i$ = szög faktor, $S_i$ = helyzet típus</div>
                        
                        <div><b>🥅 Kapus Teljesítmény Modell</b></div>
                        <div class="math-formula">$$\text{Save}\% = 1 - \frac{GA}{SA}$$</div>
                        <div class="math-formula">$$\text{GSAA} = xGA - GA$$</div>
                        <div class="math-formula">$$P_{quality} = f(\text{forma}, \text{pihenő}, \text{ellenfél erő}) \times W_{fáradtság}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $GA$ = kapott gólok, $SA$ = lövések, $GSAA$ = várható fölötti védések, $W_{fáradtság}$ = fáradtság súly</div>
                        
                        <div><b>⚡ Speciális Egységek Fejlett Modell</b></div>
                        <div class="math-formula">$$PP_{eff} = \frac{PP_{goals}}{PP_{opportunities}} \times \text{időjárás faktor}$$</div>
                        <div class="math-formula">$$PK_{eff} = 1 - \frac{PP_{goals\_allowed}}{Times_{shorthanded}}$$</div>
                        <div class="math-formula">$$ST_{impact} = (PP_{opp} \times PP_{eff}) - (PK_{sit} \times PK_{eff\_opp})$$</div>
                        <div style="margin: 0.5rem 0;">Jégkorong időjárás hatás: $W_{temp} = 1 + 0.02 \times |T - (-5)|$ (optimális -5°C)</div>
                        <br>
                        <h3>⚾ Baseball - Fejlett Sabermetrics Modellek</h3>
                        <div><b>📊 Sabermetric Advanced Model</b></div>
                        <div class="math-formula">$$wOBA = \frac{0.69 \times BB + 0.72 \times HBP + 0.89 \times 1B + 1.27 \times 2B + 1.62 \times 3B + 2.10 \times HR}{AB + BB - IBB + SF + HBP}$$</div>
                        <div class="math-formula">$$wRC+ = \frac{(wOBA - lg_{wOBA})}{wOBA_{scale}} + \frac{lg_R}{PA} \times PF \times 100$$</div>
                        <div class="math-formula">$$FIP = \frac{13 \times HR + 3 \times (BB + HBP) - 2 \times K}{IP} + FIP_{constant}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $BB$ = base on balls, $HBP$ = hit by pitch, $1B/2B/3B/HR$ = egyes/kettes/hármas/hazafutás</div>
                        
                        <div><b>🏆 Pythagorean Expectation Enhanced</b></div>
                        <div class="math-formula">$$W\% = \frac{RS^k}{RS^k + RA^k}$$</div>
                        <div class="math-formula">$$RS_{adj} = RS \times PF \times WF \times AF$$</div>
                        <div class="math-formula">$$WF = f(T, v_{szél}, \text{irány}, H, h_{altitude})$$</div>
                        <div style="margin: 0.5rem 0;">ahol $k = 1.83$ (optimalizált kitevő), $RS$ = futások, $RA$ = engedett futások, $PF$ = park faktor, $WF$ = időjárás faktor, $AF$ = magasság faktor</div>
                        
                        <div><b>🎯 Kezdő Dobó Hatás Modell</b></div>
                        <div class="math-formula">$$SP_{impact} = \frac{(FIP - Liga_{FIP}) \times IP_{várható}}{9}$$</div>
                        <div class="math-formula">$$Bullpen_{használat} = f(Q_{kezdő}, S_{játék}, M_{tendencia})$$</div>
                        <div class="math-formula">$$Total_{impact} = SP_{impact} + BP_{impact} + O_{adj}$$</div>
                        <div style="margin: 0.5rem 0;">ahol $FIP$ = Fielding Independent Pitching, $IP$ = dobott innings, $Q$ = minőség, $S$ = játékhelyzet, $M$ = menedzser</div>
                        
                        <div><b>🌤️ Időjárás Hatás Komplex Modell</b></div>
                        <div class="math-formula">$$HR_{faktor} = 1 + 0.1 \times \frac{T - 21}{10} + 0.05 \times \frac{v_{segítő}}{10}$$</div>
                        <div class="math-formula">$$Run_{környezet} = PF \times WF \times AF \times H_{faktor}$$</div>
                        <div class="math-formula">$$R_{várható} = (R_A + R_B) \times Run_{környezet} \times D_{faktor}$$</div>
                        <div style="margin: 0.5rem 0;">Baseball időjárás optimum: $T_{opt} = 21°C$, $H_{opt} = 40\%$, $v_{szél} < 15$ km/h, $h_{altitude}$ hatás: $+0.01\%$/méter</div>
                    </div>
                </div>
            </div>

            <!-- Guide Tab -->
            <div id="guide" role="tabpanel" class="tab-content">
                <div class="card">
                    <h2 data-lang="guideTitle">📘 Professional User Guide</h2>
                    <div class="guide-content" style="font-size: 1.1rem; line-height: 1.8; color: #cbd5e1;">
                        <h3 data-lang="guideApiConfigTitle">1. API Configuration</h3>
                        <p data-lang="guideApiConfigText">Enter your valid OpenAI key in the 🔧 API Settings tab, then click the Test API Connection button. You can proceed once the connection is successful.</p>
                        <div style="background: #1e293b; padding: 1rem; border-radius: 8px; margin: 1rem 0; border-left: 4px solid #8b5cf6;">
                            <h4 style="color: #8b5cf6; margin: 0 0 0.5rem 0;" data-lang="guideApiKeySources">🔑 API Key Sources:</h4>
                            <ul style="margin: 0; padding-left: 1.5rem;">
                                <li><strong>OpenAI API Key:</strong> <a href="https://platform.openai.com/api-keys" target="_blank" style="color: #60a5fa;">https://platform.openai.com/api-keys</a></li>
                                <li><strong>Perplexity API Key:</strong> <a href="https://www.perplexity.ai/account/api/keys" target="_blank" style="color: #60a5fa;">https://www.perplexity.ai/account/api/keys</a></li>
                                <li><strong>ChatGPT API Key:</strong> <a href="https://platform.openai.com/api-keys" target="_blank" style="color: #60a5fa;">https://platform.openai.com/api-keys</a></li>
                                <li><strong>Google Gemini API Key:</strong> <a href="https://makersuite.google.com/app/apikey" target="_blank" style="color: #60a5fa;">https://makersuite.google.com/app/apikey</a></li>
                                <li><strong>DeepSeek API Key:</strong> <a href="https://platform.deepseek.com/api_keys" target="_blank" style="color: #60a5fa;">https://platform.deepseek.com/api_keys</a></li>
                            </ul>
                        </div>
                        
                        <div style="background: #065f46; padding: 1rem; border-radius: 8px; margin: 1rem 0; border-left: 4px solid #10b981;">
                            <h4 style="color: #10b981; margin: 0 0 0.5rem 0;" data-lang="guideAutoAnalysisTitle">🤖 Automatic Analysis Feature:</h4>
                            <p style="margin: 0; color: #d1fae5;" data-lang="guideAutoAnalysisText">If you configure the Perplexity API key, the system will automatically perform comprehensive data analysis after image processing. This eliminates the need for manual prompt copying and JSON pasting - the entire analysis process becomes fully automated!</p>
                        </div>

                        <h3 data-lang="guideImageUploadTitle">2. Image Upload</h3>
                        <p data-lang="guideImageUploadText">On the 📸 Image Collection tab, drag in or select screenshots from bookmaker and statistical pages. The system recognizes multiple sports and markets. Tip: You can paste images directly from the clipboard using Ctrl+V.</p>

                        <h3 data-lang="guideInitialAnalysisTitle">3. Initial AI Analysis</h3>
                        <p data-lang="guideInitialAnalysisText">Once at least one image is available, start the 🚀 Initial GPT-4o Analysis process. Image status (Waiting / Analyzing / Complete) updates in real-time.</p>

                        <h3 data-lang="guideDataRetrievalTitle">4. Data Retrieval Prompt</h3>
                        <p data-lang="guideDataRetrievalText">After the initial analysis, a combined prompt will appear in the 🔍 Analysis & Data Processing tab. Copy this and run it in a large language model (e.g., ChatGPT).</p>

                        <h3 data-lang="guideDataProcessingTitle">5. Data Processing</h3>
                        <p data-lang="guideDataProcessingText">Paste the full JSON response from the language model into the text area in the 🔍 Analysis & Data Processing tab, then click the 🔄 Process All Data button. This performs all calculations.</p>

                        <h3 data-lang="guideResultsTitle">6. Review Results</h3>
                        <p data-lang="guideResultsText">The recommendations appear in the 💎 Results tab. The system generates optimal single bets and high-value parlay combinations based on the selected strategy.</p>

                        <h3 data-lang="guideMathTitle">7. Understand the Math</h3>
                        <p data-lang="guideMathText">The 📐 Math tab explains all the formulas used, from calculating expected value (EV) to the Kelly criterion for staking. This ensures full transparency.</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Enhanced Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay hidden">
        <div class="loading-content">
            <div class="spinner"></div>
            <h3 style="color: #8b5cf6;" id="loadingTitle">GPT-4o Vision Analysis</h3>
            <p style="color: #94a3b8;" id="loadingMessage">Processing images...</p>
            
            <!-- Progress Bar -->
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-percentage" id="progressPercentage">0%</div>
                <div class="progress-text" id="progressText">Initializing...</div>
            </div>
            
            <!-- Loading Steps -->
            <div class="loading-details">
                <div class="loading-step" id="step1">🔍 Analyzing images</div>
                <div class="loading-step" id="step2">🤖 Processing with AI</div>
                <div class="loading-step" id="step3">📊 Extracting data</div>
                <div class="loading-step" id="step4">🧮 Calculating probabilities</div>
                <div class="loading-step" id="step5">✅ Finalizing results</div>
            </div>
        </div>
    </div>
    
    <!-- Custom Modal -->
    <div id="customModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
        <div class="modal-content">
            <h2 id="modalTitle" style="color: #8b5cf6; margin-bottom: 1rem;">Confirmation</h2>
            <p id="modalMessage" style="color: #94a3b8; margin-bottom: 2rem;">Are you sure you want to delete all images?</p>
            <div style="display: flex; justify-content: center; gap: 1rem;">
                <button id="modalConfirmBtn" class="btn btn-danger">Delete</button>
                <button id="modalCancelBtn" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Language Pack Module -->
    <script src="src/utils/languagePack.js"></script>

    <script>
        // --- CONSTANTS AND CONFIGURATION --- //
        const CONSTANTS = {
            LOCAL_STORAGE_KEY: 'sportsAI_appState_v2',
            API_URL: 'https://api.openai.com/v1/chat/completions',
            API_MODEL: 'gpt-4o',
        };

        // --- LANGUAGE PACK MODULE --- //
        // Language pack is now handled by the external module (src/utils/languagePack.js)

        const SportConfigs = {
            football: { name: 'Football', icon: '⚽', dataNeeded: ['team form (last 5 matches)', 'head-to-head', 'injuries/suspensions', 'home/away performance', 'expected goals (xG)'], models: ['Poisson', 'Dixon-Coles', 'xG'] },
            soccer: { name: 'Football', icon: '⚽', dataNeeded: ['team form (last 5 matches)', 'head-to-head', 'injuries/suspensions', 'home/away performance', 'expected goals (xG)'], models: ['Poisson', 'Dixon-Coles', 'xG'] }, // Alias
            tennis: { name: 'Tennis', icon: '🎾', dataNeeded: ['Elo rating', 'surface-specific performance', 'serve/return %', 'head-to-head', 'physical condition', 'break point conversion'], models: ['Elo Rating', 'Surface analysis'] },
            basketball: { name: 'Basketball', icon: '🏀', dataNeeded: ['pace', 'offensive/defensive efficiency', 'injury report', 'home/away splits', 'back-to-back effect'], models: ['Pace-adjusted efficiency', 'Four Factors'] },
            hockey: { name: 'Hockey', icon: '🏒', dataNeeded: ['Corsi/Fenwick', 'goalie form', 'power play/penalty kill %', 'shot quality', 'rest days'], models: ['Advanced analytics (Corsi)', 'Goaltender analysis'] },
            baseball: { name: 'Baseball', icon: '⚾', dataNeeded: ['season runs scored/allowed', 'starting pitchers FIP/ERA', 'bullpen WAR', 'park factor', 'weather impact'], models: ['Pythagorean expectation', 'Log5', 'Run distribution'] },
            americanfootball: { name: 'American Football', icon: '🏈', dataNeeded: ['offensive/defensive yards per play', 'turnover differential', 'red zone efficiency', 'strength of schedule'], models: ['EPA model', 'DVOA', 'Point spread model'] },
            unknown: { name: 'Unknown', icon: '❓', dataNeeded: [], models: [] },
            other: { name: 'Other Sport', icon: '🏆', dataNeeded: [], models: [] }
        };
        
        // --- APPLICATION STATE --- //
        const AppState = {
            apiKey: '',
            apiConnected: false,
            uploadedImages: [], // { id, dataUrl, name, size, sport, status, analysisResult, error }
            analyzedData: {},   // { sportBreakdown }
            retrievedData: null,
            portfolio: {
                singles: [],
                parlays: []
            },
            persistentData: {
                extractedMatches: [], // Persistent match data
                extractedOdds: [],    // Persistent odds data
                lastUpdated: null
            },
            perplexitySearchResults: [] // Store Perplexity AI search results
        };

        // --- DOM ELEMENT SELECTORS --- //
        const DOM = {
            apiKeyInput: document.getElementById('apiKey'),
            testApiBtn: document.getElementById('testApiBtn'),
            apiStatus: document.getElementById('apiStatus'),
            fileInput: document.getElementById('fileInput'),
            uploadArea: document.getElementById('uploadArea'),
            imagesContainer: document.getElementById('imagesContainer'),
            startAnalysisBtn: document.getElementById('startAnalysisBtn'),
            deleteAllBtn: document.getElementById('deleteAllBtn'),
            analysisResultsContainer: document.getElementById('analysisResultsContainer'),
            dataProcessingContainer: document.getElementById('dataProcessingContainer'),
            retrievedDataInput: document.getElementById('retrievedData'),
            processDataBtn: document.getElementById('processDataBtn'),
            portfolioSummary: document.getElementById('portfolioSummary'),
            resultsContainer: document.getElementById('resultsContainer'),
            noResults: document.getElementById('noResults'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            loadingTitle: document.getElementById('loadingTitle'),
            loadingMessage: document.getElementById('loadingMessage'),
            customModal: document.getElementById('customModal'),
            modalMessage: document.getElementById('modalMessage'),
            modalConfirmBtn: document.getElementById('modalConfirmBtn'),
            modalCancelBtn: document.getElementById('modalCancelBtn'),
        };

        // --- LANGUAGE MANAGEMENT --- //
        // Language functions using the external module
        function setLanguage(lang) {
            window.languagePack.applyLanguage(lang);
            updateLanguageUI();
            updateDynamicContent();

            // Re-render uploaded images
            UIManager.displayUploadedImages();

            // Re-process analysis results if exist
            if (AppState.analyzedData && AppState.analyzedData.sportBreakdown) {
                processAndDisplayAnalysisResults();
            }

            // Re-display portfolio if exists
            if (AppState.portfolio && (AppState.portfolio.singles.length || AppState.portfolio.parlays.length)) {
                displaySummary(AppState.portfolio);
                displayRecommendations(AppState.portfolio);
            }

            // Update all static elements
            document.querySelectorAll('[data-lang]').forEach(element => {
                const key = element.getAttribute('data-lang');
                element.textContent = getText(key);
            });

            document.querySelectorAll('[data-lang-placeholder]').forEach(element => {
                const key = element.getAttribute('data-lang-placeholder');
                element.setAttribute('placeholder', getText(key));
            });

            // Re-render MathJax after language change
            setTimeout(renderAllMath, 100);
        }
        
        function updateLanguageUI() {
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.lang === window.languagePack.getCurrentLanguage());
            });
        }
        
        function updateDynamicContent() {
            // Update loading messages
            const loadingTitle = document.getElementById('loadingTitle');
            const loadingMessage = document.getElementById('loadingMessage');
            if (loadingTitle) loadingTitle.textContent = getText('loadingTitle');
            if (loadingMessage) loadingMessage.textContent = getText('loadingMessage');
            
            // Update modal content
            const modalTitle = document.getElementById('modalTitle');
            const modalMessage = document.getElementById('modalMessage');
            const modalConfirmBtn = document.getElementById('modalConfirmBtn');
            const modalCancelBtn = document.getElementById('modalCancelBtn');
            
            if (modalTitle) modalTitle.textContent = getText('modalTitle');
            if (modalMessage) modalMessage.textContent = getText('modalDeleteAllImages');
            if (modalConfirmBtn) modalConfirmBtn.textContent = getText('modalDeleteButton');
            if (modalCancelBtn) modalCancelBtn.textContent = getText('modalCancelButton');
        }
        
        function getText(key) {
            return window.languagePack.getText(key);
        }

        // Update status text generation
        function getStatusText(status) {
            const statusMap = {
                'pending': 'statusWaiting',
                'analyzing': 'statusAnalyzing', 
                'completed': 'statusComplete',
                'error': 'statusError'
            };
            return getText(statusMap[status] || 'statusUnknown');
        }

        function getErrorText(error) {
            return getText('errorMessage').replace('{error}', error || getText('unknownError'));
        }

        // Update notification messages
        function showLocalizedNotification(messageKey, type = 'info', replacements = {}) {
            let message = getText(messageKey);
            Object.entries(replacements).forEach(([key, value]) => {
                message = message.replace(`{${key}}`, value);
            });
            UIManager.showNotification(message, type);
        }
        
        function showLocalizedLoading(titleKey, messageKey, replacements = {}) {
            let title = getText(titleKey);
            let message = getText(messageKey);
            Object.entries(replacements).forEach(([key, value]) => {
                title = title.replace(`{${key}}`, value);
                message = message.replace(`{${key}}`, value);
            });
            UIManager.showLoading(title, message);
        }
        
        function setLocalizedLoadingMessage(messageKey, replacements = {}) {
            let message = getText(messageKey);
            Object.entries(replacements).forEach(([key, value]) => {
                message = message.replace(`{${key}}`, value);
            });
            UIManager.setLoadingMessage(message);
        }

        // --- INITIALIZATION --- //
        document.addEventListener('DOMContentLoaded', () => {
            initializeEventListeners();
            loadStateFromLocalStorage();
            // Language pack is initialized automatically when the module loads
            updateLanguageUI();
            updateDynamicContent();
            initializeInputModes();
            console.log('🎯 Advanced Sports Betting Analyzer v2.0 initialized');
            
            // Ensure MathJax renders on page load
            if (window.MathJax) {
                MathJax.startup.defaultReady();
                // Re-render MathJax when switching to math tab
                setTimeout(() => {
                    if (window.MathJax && window.MathJax.typesetPromise) {
                        MathJax.typesetPromise().catch((e) => console.log('MathJax render error:', e));
                    }
                }, 500);
            }
        });

        function initializeEventListeners() {
            document.querySelectorAll('.nav-tab').forEach(tab => tab.addEventListener('click', (e) => switchTabAndRenderMath(e.currentTarget.dataset.tab)));
            
            // Language selector
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    setLanguage(e.currentTarget.dataset.lang);
                });
            });
            
            DOM.fileInput.addEventListener('change', handleFileSelect);
            DOM.uploadArea.addEventListener('click', () => DOM.fileInput.click());
            ['dragover', 'dragleave', 'drop'].forEach(eventName => {
                DOM.uploadArea.addEventListener(eventName, handleDragDrop);
            });
            
            document.addEventListener('paste', handlePaste);
            DOM.apiKeyInput.addEventListener('input', validateApiKey);
            DOM.retrievedDataInput.addEventListener('input', () => {
                DOM.processDataBtn.disabled = DOM.retrievedDataInput.value.trim() === '';
            });

            DOM.modalCancelBtn.addEventListener('click', () => UIManager.hideModal());
        }
        
        // --- STATE MANAGEMENT --- //
        function saveStateToLocalStorage() {
            try {
                const stateToSave = {
                    apiKey: AppState.apiKey,
                    // Only save essential data, not the full dataUrl to save space
                    uploadedImages: AppState.uploadedImages.map(({ id, name, size, sport, status, analysisResult, error }) => ({
                        id, name, size, sport, status, analysisResult, error
                    }))
                };
                // Note: dataUrl is not saved to prevent massive localStorage usage.
                // The app will not be able to restore images on reload, which is a reasonable trade-off.
                localStorage.setItem(CONSTANTS.LOCAL_STORAGE_KEY, JSON.stringify(stateToSave));
            } catch (e) {
                console.error(getText('errorSaving'), e);
                showLocalizedNotification('notificationDataSaveError', 'error');
            }
        }

        function loadStateFromLocalStorage() {
            const savedStateJSON = localStorage.getItem(CONSTANTS.LOCAL_STORAGE_KEY);
            if (savedStateJSON) {
                try {
                    const savedState = JSON.parse(savedStateJSON);
                    if (savedState.apiKey) {
                        DOM.apiKeyInput.value = savedState.apiKey;
                        validateApiKey();
                        testApiConnection();
                    }
                    // Images are not reloaded from state to save storage space.
                    // The user will start with a clean slate of images on each session.
                } catch (e) {
                    console.error(getText('errorLoading'), e);
                    localStorage.removeItem(CONSTANTS.LOCAL_STORAGE_KEY); // Clear corrupted data
                }
            }
        }
        
        // --- UI MANAGER MODULE --- //
        const UIManager = {
            switchTab(tabName) {
                document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.nav-tab').forEach(tab => {
                    const isCurrent = tab.dataset.tab === tabName;
                    tab.classList.toggle('active', isCurrent);
                    tab.setAttribute('aria-selected', isCurrent);
                });
                document.getElementById(tabName).classList.add('active');
            },
            
            showLoading(title, message, steps = []) {
                DOM.loadingTitle.textContent = title;
                DOM.loadingMessage.textContent = message;
                
                // Initialize progress
                this.currentProgress = 0;
                this.loadingSteps = steps.length > 0 ? steps : [
                    getText('loadingStep1') || '🔍 Analyzing images',
                    getText('loadingStep2') || '🤖 Processing with AI', 
                    getText('loadingStep3') || '📊 Extracting data',
                    getText('loadingStep4') || '🧮 Calculating probabilities',
                    getText('loadingStep5') || '✅ Finalizing results'
                ];
                
                this.updateProgress(0, getText('loadingInitializing') || 'Initializing...');
                this.resetLoadingSteps();
                
                DOM.loadingOverlay.classList.remove('hidden');
            },

            setLoadingMessage(message) {
                DOM.loadingMessage.textContent = message;
            },

            updateProgress(percentage, statusText = '') {
                this.currentProgress = Math.max(0, Math.min(100, percentage));
                
                const progressFill = document.getElementById('progressFill');
                const progressPercentage = document.getElementById('progressPercentage');
                const progressText = document.getElementById('progressText');
                
                if (progressFill) {
                    progressFill.style.width = `${this.currentProgress}%`;
                }
                
                if (progressPercentage) {
                    progressPercentage.textContent = `${Math.round(this.currentProgress)}%`;
                }
                
                if (progressText && statusText) {
                    progressText.textContent = statusText;
                }
                
                // Update step status based on progress
                this.updateStepStatus();
            },

            updateStepStatus() {
                const steps = document.querySelectorAll('.loading-step');
                const stepProgress = this.currentProgress / 100 * steps.length;
                
                steps.forEach((step, index) => {
                    step.classList.remove('active', 'completed');
                    
                    if (index < Math.floor(stepProgress)) {
                        step.classList.add('completed');
                    } else if (index === Math.floor(stepProgress)) {
                        step.classList.add('active');
                    }
                });
            },

            resetLoadingSteps() {
                const steps = document.querySelectorAll('.loading-step');
                steps.forEach((step, index) => {
                    step.classList.remove('active', 'completed');
                    if (this.loadingSteps && this.loadingSteps[index]) {
                        step.textContent = this.loadingSteps[index];
                    }
                });
            },

            setLoadingStep(stepIndex, completed = false) {
                const steps = document.querySelectorAll('.loading-step');
                if (steps[stepIndex]) {
                    steps[stepIndex].classList.remove('active', 'completed');
                    if (completed) {
                        steps[stepIndex].classList.add('completed');
                    } else {
                        steps[stepIndex].classList.add('active');
                    }
                }
            },

            hideLoading() {
                DOM.loadingOverlay.classList.add('hidden');
                
                // Reset progress
                this.currentProgress = 0;
                this.updateProgress(0, '');
                this.resetLoadingSteps();
            },

            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `alert alert-${type}`;
                notification.setAttribute('role', type === 'error' ? 'alert' : 'status');
                notification.style.cssText = `position: fixed; top: 20px; right: 20px; z-index: 1001; min-width: 300px; animation: slideIn 0.3s ease;`;
                const icon = type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️';
                notification.innerHTML = `<span>${icon}</span><span>${message}</span>`;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease forwards';
                    setTimeout(() => notification.remove(), 300);
                }, 5000);
            },
            
            showModal(message, onConfirm) {
                DOM.modalMessage.textContent = message;
                DOM.customModal.classList.remove('hidden');
                
                // Clone and replace the button to remove old event listeners
                const newConfirmBtn = DOM.modalConfirmBtn.cloneNode(true);
                DOM.modalConfirmBtn.parentNode.replaceChild(newConfirmBtn, DOM.modalConfirmBtn);
                DOM.modalConfirmBtn = newConfirmBtn;
                
                DOM.modalConfirmBtn.onclick = () => {
                    onConfirm();
                    this.hideModal();
                };
            },

            hideModal() {
                DOM.customModal.classList.add('hidden');
            },

            updateActionButtons() {
                const hasImages = AppState.uploadedImages.length > 0;
                DOM.startAnalysisBtn.disabled = !AppState.apiConnected || !hasImages;
                DOM.deleteAllBtn.disabled = !hasImages;
            },
            
            displayUploadedImages() {
                DOM.imagesContainer.innerHTML = AppState.uploadedImages.map((image, index) => {
                    const sportInfo = SportConfigs[image.sport] || SportConfigs.unknown;
                    const statusText = getStatusText(image.status);
                    const errorTooltip = image.status === 'error' ? `title="${getErrorText(image.error)}"` : '';

                    return `
                        <div class="image-item" id="image-${image.id}">
                            <img src="${image.dataUrl}" alt="${image.name}">
                            <div class="sport-badge sport-${image.sport}">${sportInfo.icon} ${sportInfo.name}</div>
                            <div class="analysis-status status-${image.status}" ${errorTooltip}>${statusText}</div>
                            <div class="image-overlay-content">
                                <div style="font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${image.name}</div>
                                <div>${getText('sizeLabel')}: ${(image.size / 1024).toFixed(1)} KB</div>
                            </div>
                            <button onclick="removeImage(${index})" aria-label="${getText('deleteImageLabel')}" style="position: absolute; top: 40px; right: 10px; background: rgba(239, 68, 68, 0.8); border: none; border-radius: 50%; width: 30px; height: 30px; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center;">❌</button>
                        </div>
                    `;
                }).join('');
            },
            
            updateImageDisplay(image) {
                const element = document.getElementById(`image-${image.id}`);
                if (!element) return;
                
                const sportInfo = SportConfigs[image.sport] || SportConfigs.unknown;
                const statusText = getStatusText(image.status);
                
                element.querySelector('.sport-badge').className = `sport-badge sport-${image.sport}`;
                element.querySelector('.sport-badge').innerHTML = `${sportInfo.icon} ${sportInfo.name}`;
                
                const statusElement = element.querySelector('.analysis-status');
                statusElement.className = `analysis-status status-${image.status}`;
                statusElement.textContent = statusText;
                if (image.status === 'error') {
                    statusElement.title = getErrorText(image.error);
                    statusElement.style.cursor = 'help';
                } else {
                    statusElement.title = '';
                    statusElement.style.cursor = 'default';
                }
            }
        };

        const style = document.createElement('style');
        style.textContent = `@keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } } @keyframes slideOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }`;
        document.head.appendChild(style);

        // --- API SERVICE MODULE --- //
        const ApiService = {
            async testConnection(apiKey) {
                const response = await fetch(CONSTANTS.API_URL.replace('chat/completions', 'models'), { headers: { 'Authorization': `Bearer ${apiKey}` } });
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || `HTTP ${response.status}`);
                }
                return true;
            },

            async analyzeImage(image, apiKey) {
                const prompt = `Analyze this sports betting image and return the response in the following JSON format. Be precise and detailed. Use standardized keys.

IMPORTANT: Detect ALL sports types including:
- football (soccer) - European football/soccer 
- tennis - individual tennis matches
- basketball - NBA, European leagues, etc. 
- hockey - NHL, European hockey leagues  
- baseball - MLB, etc.
- americanfootball - NFL, college football
- other - any other sport

{
  "sport_type": "football|tennis|basketball|hockey|baseball|americanfootball|other",
  "matches_detected": [
    { "home_team": "Team/Player name", "away_team": "Team/Player name", "league": "League name or null" }
  ],
  "odds_found": [
    { "market_type": "match_result|total_goals_over_under|total_points_over_under|corners|cards|handicap", "market_specifier": "2.5|null", "values": { "Home": 1.90, "Draw": 3.20, "Away": 4.10 }, "applies_to_match_index": 0 }
  ],
  "bookmaker": "Bookmaker name or null"
}

For tennis matches, use "1" and "2" instead of "Home" and "Away".
For basketball/hockey, detect total points/goals markets.
For football, also detect corners, cards, and handicap markets.`;
                const response = await fetch(CONSTANTS.API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                    body: JSON.stringify({
                        model: CONSTANTS.API_MODEL,
                        messages: [{
                            role: 'user',
                            content: [
                                { type: 'text', text: prompt },
                                { type: 'image_url', image_url: { url: image.dataUrl, detail: 'high' } }
                            ]
                        }],
                        response_format: { type: "json_object" }
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || `HTTP ${response.status}`);
                }

                const data = await response.json();
                return JSON.parse(data.choices[0].message.content);
            }
        };

        // --- EVENT HANDLERS --- //
        function handleFileSelect(event) { processFiles(Array.from(event.target.files)); }
        
        function handleDragDrop(event) {
            event.preventDefault();
            const area = event.currentTarget;
            if (event.type === 'dragover') {
                area.classList.add('drag-over');
            } else if (event.type === 'dragleave') {
                area.classList.remove('drag-over');
            } else if (event.type === 'drop') {
                area.classList.remove('drag-over');
                processFiles(Array.from(event.dataTransfer.files));
            }
        }

        function handlePaste(event) {
            const files = Array.from(event.clipboardData.files).filter(file => file.type.startsWith('image/'));
            if (files.length > 0) {
                processFiles(files);
                showLocalizedNotification('notificationImagesFromClipboard', 'success', { count: files.length });
            }
        }

        // --- CORE LOGIC --- //
        function validateApiKey() {
            const apiKey = DOM.apiKeyInput.value.trim();
            const isValid = apiKey.startsWith('sk-') && apiKey.length > 20;
            DOM.testApiBtn.disabled = !isValid;
            if (isValid) {
                AppState.apiKey = apiKey;
            }
        }

        async function testApiConnection() {
            DOM.testApiBtn.disabled = true;
            DOM.testApiBtn.innerHTML = `🔄 ${getText('testingInProgress')}`;
            DOM.apiStatus.className = 'alert alert-info';
            DOM.apiStatus.innerHTML = `<span>🔄</span><span>${getText('testingApiConnection')}</span>`;
            DOM.apiStatus.classList.remove('hidden');

            try {
                await ApiService.testConnection(AppState.apiKey);
                AppState.apiConnected = true;
                DOM.apiStatus.className = 'alert alert-success';
                DOM.apiStatus.innerHTML = `<span>✅</span><span>${getText('apiConnectionSuccess')}</span>`;
                UIManager.updateActionButtons();
                saveStateToLocalStorage();
            } catch (error) {
                AppState.apiConnected = false;
                DOM.apiStatus.className = 'alert alert-error';
                DOM.apiStatus.innerHTML = `<span>❌</span><span>${getText('apiConnectionFailed')}: ${error.message}</span>`;
            } finally {
                DOM.testApiBtn.disabled = false;
                DOM.testApiBtn.innerHTML = `🔍 ${getText('testApiButton')}`;
            }
        }

        function processFiles(files) {
            if (!AppState.apiConnected) {
                showLocalizedNotification('notificationSetupApiFirst', 'warning');
                UIManager.switchTab('setup');
                return;
            }

            files.filter(file => file.type.startsWith('image/')).forEach(file => {
                const reader = new FileReader();
                reader.onload = e => {
                    AppState.uploadedImages.push({
                        id: Date.now() + Math.random(),
                        dataUrl: e.target.result,
                        name: file.name,
                        size: file.size,
                        sport: 'unknown',
                        status: 'pending',
                        analysisResult: null,
                        error: null
                    });
                    UIManager.displayUploadedImages();
                    UIManager.updateActionButtons();
                };
                reader.readAsDataURL(file);
            });
        }
        
        function removeImage(index) {
            AppState.uploadedImages.splice(index, 1);
            UIManager.displayUploadedImages();
            UIManager.updateActionButtons();
        }

        function confirmDeleteImages() {
            UIManager.showModal(getText('modalDeleteImages'), () => {
                AppState.uploadedImages = [];
                UIManager.displayUploadedImages();
                UIManager.updateActionButtons();
                showLocalizedNotification('notificationImagesDeleted', 'info');
            });
        }
        
        function confirmClearAllData() {
            UIManager.showModal(getText('modalClearAllData'), () => {
                AppState.uploadedImages = [];
                AppState.analyzedData = {};
                AppState.retrievedData = null;
                AppState.portfolio = { singles: [], parlays: [] };
                AppState.persistentData = { extractedMatches: [], extractedOdds: [], lastUpdated: null };
                
                // Clear UI
                UIManager.displayUploadedImages();
                UIManager.updateActionButtons();
                DOM.analysisResultsContainer.innerHTML = '<div class="alert alert-info"><span>📊</span><span data-lang="analysisInfo">' + getText('analysisInfo') + '</span></div>';
                DOM.dataProcessingContainer.classList.add('hidden');
                DOM.portfolioSummary.classList.add('hidden');
                DOM.resultsContainer.classList.add('hidden');
                DOM.noResults.classList.remove('hidden');
                DOM.retrievedDataInput.value = '';
                
                showLocalizedNotification('notificationAllDataCleared', 'info');
                saveStateToLocalStorage();
            });
        }

        async function startInitialAnalysis() {
            const customSteps = [
                getText('loadingStep1') || '🔍 Analyzing images',
                getText('loadingStep2') || '🤖 Processing with AI',
                getText('loadingStep3') || '📊 Extracting data',
                getText('loadingStep4') || '🧮 Calculating probabilities',
                getText('loadingStep5') || '✅ Finalizing results'
            ];
            
            UIManager.showLoading(getText('loadingInitialAnalysis'), getText('loadingMultiSportAnalysis'), customSteps);
            
            const totalImages = AppState.uploadedImages.length;
            let completedImages = 0;
            
            const analysisPromises = AppState.uploadedImages.map(async (image, index) => {
                if (image.status === 'completed') {
                    completedImages++;
                    return;
                }
                
                try {
                    image.status = 'analyzing';
                    image.error = null;
                    UIManager.updateImageDisplay(image);
                    
                    // Update progress based on current image
                    const baseProgress = (completedImages / totalImages) * 80; // 80% for analysis
                    UIManager.updateProgress(baseProgress, getText('loadingAnalyzing') || 'Analyzing images...');
                    
                    const result = await ApiService.analyzeImage(image, AppState.apiKey);
                    image.analysisResult = result;
                    image.sport = (result?.sport_type || 'unknown').trim().toLowerCase();
                    image.status = 'completed';
                    
                    completedImages++;
                    const newProgress = (completedImages / totalImages) * 80;
                    UIManager.updateProgress(newProgress, `${getText('loadingAnalyzing') || 'Analyzing images...'} (${completedImages}/${totalImages})`);
                    
                } catch (error) {
                    console.error(`Error analyzing image ${image.name}:`, error);
                    image.status = 'error';
                    image.error = error.message;
                    completedImages++;
                } finally {
                    UIManager.updateImageDisplay(image);
                }
            });

            await Promise.all(analysisPromises);
            
            // Processing results phase
            UIManager.updateProgress(85, getText('loadingProcessing') || 'Processing with AI...');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            UIManager.updateProgress(90, getText('loadingExtracting') || 'Extracting data...');
            processAndDisplayAnalysisResults();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            UIManager.updateProgress(95, getText('loadingCalculating') || 'Calculating probabilities...');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            UIManager.updateProgress(100, getText('loadingFinalizing') || 'Finalizing results...');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            UIManager.hideLoading();
            showLocalizedNotification('notificationInitialAnalysisComplete', 'success');
            UIManager.switchTab('analysis');
            
            // Check if post-analysis automatic data search is enabled
            await checkPostAnalysisAutoSearch();
        }
        
        // Check and execute post-analysis automatic data search
        async function checkPostAnalysisAutoSearch() {
            const postAnalysisSearchEnabled = document.getElementById('enablePostAnalysisSearch').checked;
            const selectedAiModel = document.getElementById('aiModel').value;
            const aiApiKey = document.getElementById('aiApiKey').value.trim();
            
            if (postAnalysisSearchEnabled && selectedAiModel === 'perplexity' && aiApiKey) {
                console.log('🚀 Starting post-analysis automatic comprehensive data search...');
                
                // Show loading message
                showLocalizedLoading('postAnalysisSearch', 'postAnalysisSearchDescription');
                
                try {
                    // Perform comprehensive data search
                    const searchResults = await performComprehensiveDataSearch(aiApiKey);
                    
                    // Automatically fill the retrieved data field
                    DOM.retrievedDataInput.value = searchResults;
                    DOM.processDataBtn.disabled = false;
                    
                    showLocalizedNotification('notificationPostAnalysisSearchComplete', 'success');
                    
                    // Optionally auto-process the data after a short delay
                    setTimeout(() => {
                        processAllRetrievedData();
                    }, 2000);
                    
                } catch (error) {
                    console.error('Post-analysis search error:', error);
                    showLocalizedNotification('notificationPostAnalysisSearchError', 'error', { error: error.message });
                } finally {
                    UIManager.hideLoading();
                }
            }
        }
        
        // Perform comprehensive data search for all mathematical formulas
        async function performComprehensiveDataSearch(apiKey) {
            console.log('🔍 Starting comprehensive data search for all mathematical formulas...');
            
            // Extract matches from uploaded images
            const allMatches = [];
            AppState.uploadedImages.forEach(image => {
                if (image.analysisResult && image.analysisResult.matches_detected) {
                    image.analysisResult.matches_detected.forEach(match => {
                        allMatches.push({
                            home_team: match.home_team,
                            away_team: match.away_team,
                            sport: image.sport || 'football',
                            league: match.league,
                            odds: match.odds || {}
                        });
                    });
                }
            });
            
            if (allMatches.length === 0) {
                throw new Error('No matches found for comprehensive data search');
            }
            
            console.log(`Found ${allMatches.length} matches for comprehensive data search`);
            
            // Group matches by sport (limit to prevent overwhelming)
            const matchesBySport = {};
            allMatches.forEach(match => {
                if (!matchesBySport[match.sport]) {
                    matchesBySport[match.sport] = [];
                }
                matchesBySport[match.sport].push(match);
            });
            
            // Limit to max 5 sports and 5 matches per sport
            const limitedSports = Object.keys(matchesBySport).slice(0, 5);
            const analyses = [];
            
            // Process each sport with comprehensive data search
            for (const sport of limitedSports) {
                const matches = matchesBySport[sport].slice(0, 5); // Max 5 matches per sport
                console.log(`🔍 Comprehensive search for ${sport}: ${matches.length} matches`);
                
                const sportAnalysis = {
                    sport: sport,
                    matches: []
                };
                
                // Search comprehensive data for each match
                for (let i = 0; i < matches.length; i++) {
                    const match = matches[i];
                    console.log(`🔍 Comprehensive search: ${match.home_team} vs ${match.away_team}`);
                    
                    try {
                        const matchData = await searchMatchDataComprehensive(match, apiKey);
                        sportAnalysis.matches.push(matchData);
                        
                        // Extended delay for comprehensive searches
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        
                    } catch (error) {
                        console.error(`Error in comprehensive search for ${match.home_team} vs ${match.away_team}:`, error);
                        
                        // Add enhanced fallback data
                        sportAnalysis.matches.push(createComprehensiveFallbackData(match));
                    }
                }
                
                analyses.push(sportAnalysis);
            }
            
            const result = { analyses };
            console.log('✅ Comprehensive data search completed:', result);
            
            return JSON.stringify(result, null, 2);
        }
        
        // Create comprehensive fallback data when search fails
        function createComprehensiveFallbackData(match) {
            return {
                home_team: match.home_team,
                away_team: match.away_team,
                league: match.league || 'Unknown League',
                match_date: new Date().toISOString().split('T')[0],
                venue: {
                    name: 'Unknown Venue',
                    capacity: 50000,
                    surface_type: 'unknown',
                    venue_type: 'unknown',
                    altitude: 100,
                    weather_forecast: {
                        temperature: 15,
                        wind_speed: 5,
                        wind_direction: 'N',
                        precipitation_probability: 20,
                        humidity: 60
                    }
                },
                comprehensive_team_data: {
                    home_team: {
                        recent_form_detailed: [],
                        league_position: 'Unknown',
                        points: 0,
                        goals_for: 0,
                        goals_against: 0,
                        home_record: {"wins": 0, "draws": 0, "losses": 0},
                        away_record: {"wins": 0, "draws": 0, "losses": 0},
                        advanced_metrics: {
                            xG_per_game: 1.5,
                            xGA_per_game: 1.5,
                            possession_avg: 50,
                            shot_conversion_rate: 10,
                            defensive_actions_per_game: 40
                        }
                    },
                    away_team: {
                        recent_form_detailed: [],
                        league_position: 'Unknown',
                        points: 0,
                        goals_for: 0,
                        goals_against: 0,
                        home_record: {"wins": 0, "draws": 0, "losses": 0},
                        away_record: {"wins": 0, "draws": 0, "losses": 0},
                        advanced_metrics: {
                            xG_per_game: 1.5,
                            xGA_per_game: 1.5,
                            possession_avg: 50,
                            shot_conversion_rate: 10,
                            defensive_actions_per_game: 40
                        }
                    }
                },
                head_to_head_detailed: {
                    overall_wins_home: 0,
                    overall_wins_away: 0,
                    overall_draws: 0,
                    last_5_meetings: [],
                    goals_scored_home: 0,
                    goals_scored_away: 0,
                    average_goals_per_meeting: 2.5
                },
                injury_suspension_impact: {
                    home_team_missing: [],
                    away_team_missing: [],
                    total_impact_home: 0,
                    total_impact_away: 0
                },
                tactical_analysis: {
                    home_team_formation: 'Unknown',
                    away_team_formation: 'Unknown',
                    home_team_style: 'unknown',
                    away_team_style: 'unknown',
                    manager_impact: {
                        home_manager_experience: 5,
                        away_manager_experience: 5,
                        tactical_flexibility: 'medium'
                    }
                },
                psychological_factors: {
                    home_team_morale: 50,
                    away_team_morale: 50,
                    pressure_level: {
                        home_team: 50,
                        away_team: 50
                    },
                    fan_support_impact: 5,
                    media_coverage: 'normal'
                },
                betting_market_analysis: {
                    opening_odds: {"home": 2.0, "draw": 3.0, "away": 4.0},
                    current_odds: {"home": 2.0, "draw": 3.0, "away": 4.0},
                    odds_movement: 'stable',
                    betting_volume: 'medium',
                    sharp_money_indicator: 'neutral'
                },
                fair_odds_calculation: {
                    home_win_prob: 0.40,
                    draw_prob: 0.30,
                    away_win_prob: 0.30,
                    calculation_method: 'Fallback probabilities - comprehensive search failed',
                    confidence_level: 30
                },
                total_goals_analysis: {
                    expected_total_goals: 2.5,
                    over_2_5_prob: 0.50,
                    under_2_5_prob: 0.50,
                    over_1_5_prob: 0.75,
                    under_1_5_prob: 0.25,
                    btts_prob: 0.55
                },
                additional_markets: {
                    corners: {"expected": 10, "over_10_5": 0.45},
                    cards: {"expected": 4, "over_4_5": 0.40},
                    first_goal: {"home": 0.45, "away": 0.40}
                },
                reasoning: `Comprehensive fallback data for ${match.home_team} vs ${match.away_team}. Search failed or returned insufficient data. All values are neutral/baseline estimates.`,
                data_sources: ["Fallback System"],
                last_updated: new Date().toISOString()
            };
        }
        
        function processAndDisplayAnalysisResults() {
            const sportBreakdown = {};
            AppState.uploadedImages.forEach(image => {
                if (!image.analysisResult || image.status !== 'completed') return;
                
                const sport = image.sport;
                if (!sport || !SportConfigs[sport]) return;

                if (!sportBreakdown[sport]) {
                    sportBreakdown[sport] = { images: 0, matches: new Map() };
                }
                sportBreakdown[sport].images++;
                (image.analysisResult.matches_detected || []).forEach(match => {
                    const matchKey = `${match.home_team} vs ${match.away_team}`.toLowerCase();
                    if (!sportBreakdown[sport].matches.has(matchKey)) {
                        sportBreakdown[sport].matches.set(matchKey, match);
                    }
                });
            });
            AppState.analyzedData.sportBreakdown = sportBreakdown;

            DOM.analysisResultsContainer.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-card"><div class="stat-value">${AppState.uploadedImages.length}</div><div class="stat-label">${getText('uploadedImagesLabel')}</div></div>
                    <div class="stat-card"><div class="stat-value">${Object.keys(sportBreakdown).length}</div><div class="stat-label">${getText('recognizedSportsLabel')}</div></div>
                </div>
                ${generateCombinedPromptHTML()}
            `;
            
            DOM.dataProcessingContainer.classList.remove('hidden');
            
            // Check for automatic processing
            checkForAutomaticProcessing(sportBreakdown);
        }

        function generateCombinedPromptHTML() {
            const { sportBreakdown } = AppState.analyzedData;
            if (!sportBreakdown || Object.keys(sportBreakdown).length === 0) {
                return `<div class="alert alert-warning"><span>⚠️</span><span>${getText('errorNoSportsDetected')}</span></div>`;
            }

            // MINDIG csak 1 nagy prompt - függetlenül a meccsek számától
            const promptContent = generateSingleMasterPrompt(sportBreakdown);
            
            // Check if automatic processing is available
            const selectedAiModel = document.getElementById('aiModel').value;
            const aiApiKey = document.getElementById('aiApiKey').value.trim();
            const canAutoProcess = selectedAiModel !== 'none' && aiApiKey.length > 0;
            
            let autoProcessButton = '';
            if (canAutoProcess) {
                autoProcessButton = `
                    <button class="btn btn-primary" onclick="processPromptAutomatically()" style="margin-left: 1rem;">
                        🤖 ${getText('autoProcessButton')}
                    </button>
                `;
            }
            
            return `
                <div class="prompt-box">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <h3 style="color: #8b5cf6; margin: 0;">⚙️ ${getText('promptTitle')}</h3>
                        <div>
                            <button class="copy-btn" onclick="copyToClipboard('combinedPromptContent')">📋 ${getText('promptCopyButton')}</button>
                            ${autoProcessButton}
                        </div>
                    </div>
                    <p style="color: #94a3b8; margin-bottom: 1rem;">${getText('promptDescription')}</p>
                    <pre id="combinedPromptContent" class="prompt-content" style="white-space: pre-wrap; word-wrap: break-word; max-height: 600px; overflow-y: auto;">${promptContent}</pre>
                </div>
            `;
        }

        function generateSingleMasterPrompt(sportBreakdown) {
            let combinedPrompt = '';
            
            // Számoljuk össze az összes meccset
            let totalMatches = 0;
            let allSports = [];
            Object.entries(sportBreakdown).forEach(([sport, data]) => {
                if (data.matches && data.matches.size > 0) {
                    totalMatches += data.matches.size;
                    allSports.push(sport);
                }
            });
            
            // === PROFESSZIONÁLIS FEJLÉC === //
            combinedPrompt += `# 🎯 PROFESSZIONÁLIS SPORTFOGADÁSI ELEMZÉS\n\n`;
            combinedPrompt += `Szia! Te egy világszínvonalú sportfogadási elemző vagy. Kérlek, végezd el az alábbi ${totalMatches} meccs részletes elemzését kizárólag valós, friss internetes adatok alapján.\n\n`;
            combinedPrompt += `**FONTOS:** Te magad kell megkeresned az internetről minden szükséges adatot a megadott meccsek alapján. Ne várj további információt - használd a csapatneveket/játékosneveket és keress rá minden releváns adatra!\n\n`;
            
            // === ADATFORRÁSOK === //
            combinedPrompt += `## 🌐 ADATGYŰJTÉS - TE KERESED MEG!\n\n`;
            combinedPrompt += `**A te feladatod:** Minden meccshez keress ki az internetről az alábbi adatokat:\n`;
            combinedPrompt += `• **Csapatnevek/játékosnevek alapján** keress rá a legfrissebb információkra\n`;
            combinedPrompt += `• **Használható források:** ESPN, BBC Sport, hivatalos ligák, Wikipedia, transfermarkt\n`;
            combinedPrompt += `• **Keresési módszer:** Gépeld be a csapat/játékos neveket + "recent form" / "injuries" / "head to head"\n`;
            combinedPrompt += `• **Ha nem találsz adatot:** Írj "nincs adat" - ne találj ki semmit!\n`;
            combinedPrompt += `• **Forrás megjelölés:** "ESPN szerint" / "BBC Sport alapján" / "logikus becslés"\n\n`;
            
            // === KUTATÁSI ÚTMUTATÓ === //
            combinedPrompt += `## 🔍 KONKRÉT KERESÉSI FELADATOK MECCSENKÉT\n\n`;
            combinedPrompt += `**MINDEN MECCSHEZ KÖTELEZŐEN KERESS KI:**\n\n`;
            combinedPrompt += `### 1️⃣ ALAPADATOK (kötelező keresés)\n`;
            combinedPrompt += `• **Csapatnevek ellenőrzése:** Keress rá hogy helyesen írtad-e\n`;
            combinedPrompt += `• **Liga/bajnokság:** Melyik ligában játszanak jelenleg\n`;
            combinedPrompt += `• **Meccs dátuma:** Mikor lesz/volt a meccs\n`;
            combinedPrompt += `• **Helyszín:** Stadion/arena neve és típusa (indoor/outdoor)\n\n`;
            combinedPrompt += `### 2️⃣ FORMA ADATOK (keresés: "team name recent results")\n`;
            combinedPrompt += `• **Utolsó 5 meccs:** Eredmények W-L-D formában\n`;
            combinedPrompt += `• **Hazai/vendég forma:** Külön keresés otthon és idegenben\n`;
            combinedPrompt += `• **Liga pozíció:** Aktuális tabellahely\n\n`;
            combinedPrompt += `### 3️⃣ EGYMÁS ELLENI MÉRLEG (keresés: "Team A vs Team B head to head")\n`;
            combinedPrompt += `• **Utolsó találkozók:** Legutóbbi 3-5 meccs eredménye\n`;
            combinedPrompt += `• **Összesített mérleg:** Ki vezet történelmileg\n\n`;
            combinedPrompt += `### 4️⃣ HIÁNYZÓ JÁTÉKOSOK (keresés: "team name injuries suspensions")\n`;
            combinedPrompt += `• **Sérültek listája:** Nevek, pozíciók, visszatérés várható ideje\n`;
            combinedPrompt += `• **Eltiltottak:** Lapok, fegyelmi ügyek\n`;
            combinedPrompt += `• **Kulcsjátékosok:** Kik a legfontosabb hiányzók\n\n`;
            combinedPrompt += `### 5️⃣ IDŐJÁRÁS (csak szabadtéri sportok, keresés: "city name weather forecast")\n`;
            combinedPrompt += `• **Hőmérséklet:** Celsius fokban\n`;
            combinedPrompt += `• **Szél:** Irány és sebesség\n`;
            combinedPrompt += `• **Csapadék:** Eső valószínűsége\n`;
            combinedPrompt += `• **Általános körülmények:** Napsütés/felhős/viharos\n\n`;
            combinedPrompt += `### 6️⃣ MOTIVÁCIÓ (keresés: "team name league position goals")\n`;
            combinedPrompt += `• **Szezon célok:** Bajnokság/rájátszás/kiesés elkerülése\n`;
            combinedPrompt += `• **Aktuális helyzet:** Mennyire fontos a meccs\n`;
            combinedPrompt += `• **Nyomás:** Van-e extra motiváció/nyomás\n\n`;
            combinedPrompt += `**FONTOS EMLÉKEZTETŐ:** Ha bármelyik adatot nem találod meg 2-3 keresés után, írj "nincs adat" és menj tovább!\n\n`;
            
            // === MATEMATIKAI MODELLEK === //
            combinedPrompt += `## 🧮 ALKALMAZANDÓ MATEMATIKAI MODELLEK\n\n`;
            combinedPrompt += `Használd ezeket a modelleket a valószínűségek kiszámításához:\n\n`;
            
            // Minden sport modelljét hozzáadjuk
            allSports.forEach(sport => {
                combinedPrompt += generateDetailedSportModel(sport);
            });
            
            // === ELEMZENDŐ MECCSEK === //
            combinedPrompt += `## 🏆 ELEMZENDŐ MECCSEK (${totalMatches} DB)\n\n`;

            Object.entries(sportBreakdown).forEach(([sport, data]) => {
                if (data.matches && data.matches.size > 0) {
                    const config = SportConfigs[sport] || SportConfigs.unknown;
                    const matchesList = Array.from(data.matches.values()).map(m => `- ${m.home_team} vs ${m.away_team}`).join('\n');
                    combinedPrompt += `### ${config.icon} ${config.name.toUpperCase()}\n`;
                    combinedPrompt += `${matchesList}\n\n`;
                    
                    // Sport-specifikus követelmények
                    combinedPrompt += generateEnhancedSportRequirements(sport);
                }
            });
            
            // === JSON VÁLASZ FORMÁTUM === //
            combinedPrompt += `## 📋 VÁLASZ FORMÁTUM\n\n`;
            combinedPrompt += `**KRITIKUS KÖVETELMÉNYEK:**\n`;
            combinedPrompt += `1. ✅ Csak tiszta JSON objektumot küldj vissza\n`;
            combinedPrompt += `2. ❌ Ne írj semmit a JSON elé vagy mögé\n`;
            combinedPrompt += `3. ❌ Ne használj \`\`\`json vagy \`\`\` jelöléseket\n`;
            combinedPrompt += `4. ✅ Minden adat valós internetről származzon\n`;
            combinedPrompt += `5. ✅ A reasoning mezőben kötelező a forrás megadása\n`;
            combinedPrompt += `6. ✅ Minden meccshez töltsd ki az összes kötelező mezőt\n\n`;
            
            // === JSON PÉLDA === //
            combinedPrompt += `**JSON STRUKTÚRA PÉLDA:**\n`;
            combinedPrompt += `{\n  "analyses": [\n`;
            
            // Minden sporthoz generálunk példát
            allSports.forEach((sport, index) => {
                combinedPrompt += generateComprehensiveJsonExample(sport);
                if (index < allSports.length - 1) {
                    combinedPrompt += `    },\n`;
                }
            });
            
            combinedPrompt += `  ]\n}\n\n`;
            
            // === VÉGSŐ UTASÍTÁSOK === //
            combinedPrompt += `## 🚀 VÉGSŐ UTASÍTÁSOK\n\n`;
            combinedPrompt += `**KERESÉSI FOLYAMAT:**\n\n`;
            combinedPrompt += `1. **KEZDJ EL KERESNI MOST!** Minden meccshez külön-külön keress adatokat\n`;
            combinedPrompt += `2. **Használd a csapatneveket** keresőszavakként az interneten\n`;
            combinedPrompt += `3. **2-3 keresés meccsenkét** - ha nincs adat, írj "nincs adat"\n`;
            combinedPrompt += `4. **Reasoning mezőben** írd le milyen forrásból származik az adat\n`;
            combinedPrompt += `5. **Matematikai modelleket** alkalmazd a megtalált adatokra\n`;
            combinedPrompt += `6. **50 (semleges) értékeket** használj ahol nincs konkrét info\n`;
            combinedPrompt += `7. **Tiszta JSON** - semmi extra szöveg előtte/utána\n\n`;
            combinedPrompt += `**EMLÉKEZTETŐ:** Te vagy felelős az adatok megkeresésért! Ne várj többet - kezdj el keresni a csapatnevek alapján!\n\n`;
            
            // === KERESÉSI PÉLDA === //
            combinedPrompt += `## 💡 KERESÉSI PÉLDA\n\n`;
            combinedPrompt += `**Ha van egy "Manchester City vs Arsenal" meccs:**\n`;
            combinedPrompt += `1. Keresés: "Manchester City recent results 2024"\n`;
            combinedPrompt += `2. Keresés: "Arsenal recent results 2024"\n`;
            combinedPrompt += `3. Keresés: "Manchester City vs Arsenal head to head"\n`;
            combinedPrompt += `4. Keresés: "Manchester City injuries suspensions"\n`;
            combinedPrompt += `5. Keresés: "Arsenal injuries suspensions"\n`;
            combinedPrompt += `6. Keresés: "Manchester weather forecast" (ha szabadtéri)\n\n`;
            combinedPrompt += `**Reasoning példa:** "ESPN szerint Man City utolsó 5: WWDWL, Arsenal: LWWDW. BBC Sport alapján H2H: City vezet 3-1. Transfermarkt szerint De Bruyne sérült."\n\n`;
            
            combinedPrompt += `**Cél:** Valós adatokon alapuló pontos valószínűségek, nem kitalált információk!\n\n`;
            
            // === SÚLYOZÁSI ÚTMUTATÓ === //
            combinedPrompt += `## ⚖️ KRITIKUS SÚLYOZÁSI ÚTMUTATÓ\n\n`;
            combinedPrompt += `**SPORTSPECIFIKUS PRIORITÁSOK:**\n\n`;
            combinedPrompt += `### 🌤️ IDŐJÁRÁS SÚLYOZÁS:\n`;
            combinedPrompt += `• **SZABADTÉRI SPORTOK** (labdarúgás, tenisz, baseball, amerikai futball):\n`;
            combinedPrompt += `  - Időjárás hatás: 1-100 skála (50 = semleges)\n`;
            combinedPrompt += `  - Optimális hőmérséklet: Labdarúgás 15°C, Tenisz 22°C, Baseball 21°C\n`;
            combinedPrompt += `  - Szél/Eső hatás: Jelentős befolyás a játékra\n`;
            combinedPrompt += `• **BELTÉRI SPORTOK** (kosárlabda, jégkorong):\n`;
            combinedPrompt += `  - Időjárás hatás: MINDIG 50 (semleges) - nincs hatás!\n`;
            combinedPrompt += `  - Ne keress időjárási adatokat beltéri sportokhoz\n\n`;
            
            combinedPrompt += `### 👥 KULCSJÁTÉKOS SÚLYOZÁS:\n`;
            combinedPrompt += `• **EGYÉNI SPORTOK** (tenisz):\n`;
            combinedPrompt += `  - Játékos sérülés: 20-80 skála (kritikus hatás!)\n`;
            combinedPrompt += `  - Nincs cserepad - minden sérülés kritikus\n`;
            combinedPrompt += `• **CSAPAT SPORTOK**:\n`;
            combinedPrompt += `  - Kulcsjátékos: 20-80 skála + is_key_player: true\n`;
            combinedPrompt += `  - Normál játékos: 40-60 skála + is_key_player: false\n\n`;
            
            combinedPrompt += `### 🎯 POZÍCIÓ SPECIFIKUS SÚLYOZÁS:\n`;
            combinedPrompt += `• **JÉGKORONG**: Kapus >> minden más (70-80 vs 20-30)\n`;
            combinedPrompt += `• **BASEBALL**: Dobó >> minden más (70-90 vs 10-30)\n`;
            combinedPrompt += `• **AMERIKAI FUTBALL**: QB >> RB >> WR >> Defense\n`;
            combinedPrompt += `• **LABDARÚGÁS**: Kapus > Védő > Középpályás > Támadó\n`;
            combinedPrompt += `• **KOSÁRLABDA**: Sztárok > Rotáció > Kisebb szerepek\n\n`;
            
            combinedPrompt += `### 📊 SKÁLA HASZNÁLAT:\n`;
            combinedPrompt += `• **1-20**: Nagyon rossz hatás/forma\n`;
            combinedPrompt += `• **20-40**: Rossz hatás/forma\n`;
            combinedPrompt += `• **40-60**: Semleges/átlagos (50 = tökéletesen semleges)\n`;
            combinedPrompt += `• **60-80**: Jó hatás/forma\n`;
            combinedPrompt += `• **80-100**: Kiváló hatás/forma\n\n`;
            
            combinedPrompt += `**EMLÉKEZTETŐ:** A súlyozás sportspecifikus! Jégkorongnál a kapus, baseballnál a dobó, tenisznél minden sérülés kritikus!`;
            
            return combinedPrompt;
        }

        function generateDetailedSportModel(sport) {
            let modelText = '';
            
            switch(sport) {
                case 'football':
                case 'soccer':
                    modelText += "### ⚽ LABDARÚGÁS MATEMATIKAI MODELLEK:\n";
                    modelText += "• **Dixon-Coles Poisson**: Gólok előrejelzése λ = támadás × védelem × hazai előny × időjárás\n";
                    modelText += "• **Skellam Eloszlás**: Gólkülönbség valószínűség\n";
                    modelText += "• **xG Model**: Várható gólok pozíció és lövés minőség alapján\n";
                    modelText += "• **Időjárás Súlyozás**: W_faktor = 1 + α×|T-15°| + β×szél + γ×eső (max 15% hatás)\n";
                    modelText += "• **Hiányzó Játékos**: Edge_adj = Edge × ∏(1 - I_i × K_i), ahol K_i = 1.5 ha kulcs\n";
                    modelText += "• **Hazai Előny**: 1.15x szorzó + szurkolói támogatás\n\n";
                    break;
                case 'tennis':
                    modelText += "### 🎾 TENISZ MATEMATIKAI MODELLEK:\n";
                    modelText += "• **Markov Lánc**: P(pont) → P(game) → P(set) → P(match)\n";
                    modelText += "• **Elo Rating**: Dinamikus erősség számítás pálya-specifikusan\n";
                    modelText += "• **Pálya Faktor**: Clay (0.9), Hard (1.0), Grass (1.15) szerva szorzók\n";
                    modelText += "• **Időjárás (szabadtéri)**: Szél hatás max 20%, hőmérséklet optimum 22°C\n";
                    modelText += "• **Sérülés Hatás**: P_adj = P × (1 - 0.5 × sérülés_súlyosság) - egyéni sportban kritikus!\n";
                    modelText += "• **Fáradtság**: Előző meccs hossza és pihenő napok\n\n";
                    break;
                case 'basketball':
                    modelText += "### 🏀 KOSÁRLABDA MATEMATIKAI MODELLEK:\n";
                    modelText += "• **Négy Faktor**: Súlyozott kombináció: 40% lövés, 25% labdavesztés, 20% lepattanó, 15% büntetők\n";
                    modelText += "• **Tempó Elemzés**: Pontok = Hatékonyság × Birtoklások × Tempó_faktor\n";
                    modelText += "• **Pitagorasz**: Win% = Pontok^k / (Pontok^k + Engedett^k), k=14\n";
                    modelText += "• **Időjárás**: NINCS HATÁS (beltéri sport) - mindig 50 (semleges)\n";
                    modelText += "• **Fáradtság**: e^(-α × pihenő_napok) × utazási_távolság_büntetés\n";
                    modelText += "• **Kulcsjátékos**: Max 25% hatás (kevésbé kritikus mint egyéni sportban)\n\n";
                    break;
                case 'hockey':
                    modelText += "### 🏒 JÉGKORONG MATEMATIKAI MODELLEK:\n";
                    modelText += "• **Corsi/Fenwick**: Lövés minőség × távolság × szög × helyzet típus\n";
                    modelText += "• **KAPUS KRITIKUS**: 50-70% hatás! Save% = 1 - (GA/SA), GSAA = xGA - GA\n";
                    modelText += "• **PDO Regresszió**: (Shooting% + Save%) × 100, visszatérés 100-hoz\n";
                    modelText += "• **Időjárás**: NINCS HATÁS (beltéri sport) - mindig 50 (semleges)\n";
                    modelText += "• **Speciális Egységek**: PP_eff × lehetőségek - PK_hatékonyság\n";
                    modelText += "• **Kapus vs Mezőnyjátékos**: Kapus >> minden más pozíció!\n\n";
                    break;
                case 'baseball':
                    modelText += "### ⚾ BASEBALL MATEMATIKAI MODELLEK:\n";
                    modelText += "• **Pitagorasz Enhanced**: Win% = RS^1.83 / (RS^1.83 + RA^1.83)\n";
                    modelText += "• **DOBÓ KRITIKUS**: 60-80% hatás! FIP, ERA, WHIP alapú teljesítmény\n";
                    modelText += "• **Időjárás MAXIMÁLIS**: Legérzékenyebb sport! HR_faktor = 1 + 0.1×(T-21)/10 + 0.05×szél\n";
                    modelText += "• **Park Faktor**: Stadion méret × magasság × szél irány kombinációja\n";
                    modelText += "• **Sabermetrics**: wOBA, wRC+, FIP kombinált elemzés\n";
                    modelText += "• **Dobó vs Ütők**: Dobó >> minden más pozíció!\n\n";
                    break;
                case 'americanfootball':
                    modelText += "### 🏈 AMERIKAI FUTBALL MATEMATIKAI MODELLEK:\n";
                    modelText += "• **EPA Model**: Expected Points Added per play\n";
                    modelText += "• **DVOA**: Defense-adjusted Value Over Average\n";
                    modelText += "• **Quarterback Kritikus**: 40-50% hatás (legfontosabb pozíció)\n";
                    modelText += "• **Időjárás (szabadtéri)**: Szél hatás passing vs rushing game arányra\n";
                    modelText += "• **Turnover Differential**: Labdavesztés/szerzés hatás pontokra\n";
                    modelText += "• **Pozíció Súlyozás**: QB >> RB >> WR >> Defense\n\n";
                    break;
                default:
                    modelText += `### ${sport.toUpperCase()} ÁLTALÁNOS MODELLEK:\n`;
                    modelText += "• Sport-specifikus statisztikai modellek\n";
                    modelText += "• Teljesítmény elemzés\n";
                    modelText += "• Történeti adatok kiértékelése\n";
                    modelText += "• Időjárás hatás sport függően\n\n";
            }
            
            return modelText;
        }

        function generateEnhancedSportRequirements(sport) {
            let requirements = '';
            
            switch(sport) {
                case 'football':
                case 'soccer':
                    requirements += "### ⚽ LABDARÚGÁS - KRITIKUS ADATOK SÚLYOZÁSSAL:\n\n";
                    requirements += "#### 🏟️ HELYSZÍN ÉS KÖRNYEZET (SZABADTÉRI SPORT!):\n";
                    requirements += "• **Stadion típus**: Szabadtéri (időjárás KRITIKUS!)\n";
                    requirements += "• **Füves pálya**: Természetes/mesterséges\n";
                    requirements += "• **Stadion méret**: Befolyásolja a játékstílust\n\n";
                    requirements += "#### 🌤️ IDŐJÁRÁS - MAXIMÁLIS PRIORITÁS (15% HATÁS!):\n";
                    requirements += "• **Hőmérséklet**: Optimális 15°C, ±10°C eltérés = teljesítménycsökkenés\n";
                    requirements += "• **Szél**: >5 km/h = labda röppálya változás, max 12% hatás\n";
                    requirements += "• **Eső**: >30% valószínűség = csúszós pálya, max 10% hatás\n";
                    requirements += "• **Páratartalom**: Optimális 50%, ±20% = játékos komfort\n";
                    requirements += "• **SÚLYOZÁS**: Időjárás hatás 1-100 skálán mindkét csapathoz!\n\n";
                    requirements += "#### 👥 JÁTÉKOSOK - KULCSJÁTÉKOS DIFFERENCIÁLÁS:\n";
                    requirements += "• **Kulcsjátékosok**: Max 30% hatás (csapatkapitány, gólkirály, playmaker)\n";
                    requirements += "• **Normál játékosok**: Max 10% hatás\n";
                    requirements += "• **Pozíció fontosság**: Kapus > Védő > Középpályás > Támadó\n";
                    requirements += "• **SÚLYOZÁS**: 1-100 skála + kulcsjátékos boolean!\n\n";
                    break;
                    
                case 'tennis':
                    requirements += "### 🎾 TENISZ - KRITIKUS ADATOK SÚLYOZÁSSAL:\n\n";
                    requirements += "#### 🏟️ HELYSZÍN TÍPUS MEGHATÁROZÁSA:\n";
                    requirements += "• **Szabadtéri**: Időjárás KRITIKUS hatás!\n";
                    requirements += "• **Fedett**: Időjárás NINCS hatás!\n";
                    requirements += "• **Pálya típus**: Clay/Hard/Grass - játékos specifikus teljesítmény\n\n";
                    requirements += "#### 🌤️ IDŐJÁRÁS (CSAK SZABADTÉRI!):\n";
                    requirements += "• **Hőmérséklet**: Optimális 22°C, ±8°C eltérés = teljesítménycsökkenés\n";
                    requirements += "• **Szél**: >5 km/h = szerva pontosság csökkenés, max 20% hatás\n";
                    requirements += "• **Napfény/Árnyék**: Látási viszonyok befolyásolása\n";
                    requirements += "• **SÚLYOZÁS**: Csak szabadtéri tenisznél számít!\n\n";
                    requirements += "#### 👤 JÁTÉKOS ÁLLAPOT - EGYÉNI SPORT SÚLYOZÁS:\n";
                    requirements += "• **Fizikai állapot**: 100% kritikus (nincs cserepad!)\n";
                    requirements += "• **Sérülések**: Bármilyen sérülés = 50%+ teljesítménycsökkenés\n";
                    requirements += "• **Fáradtság**: Előző meccsek hossza és ideje\n";
                    requirements += "• **SÚLYOZÁS**: Egyéni sportban minden sérülés kritikus!\n\n";
                    break;
                    
                case 'basketball':
                    requirements += "### 🏀 KOSÁRLABDA - KRITIKUS ADATOK SÚLYOZÁSSAL:\n\n";
                    requirements += "#### 🏟️ HELYSZÍN TÍPUS (BELTÉRI SPORT!):\n";
                    requirements += "• **Arena típus**: Beltéri (időjárás NINCS HATÁS!)\n";
                    requirements += "• **Hazai pálya**: Szurkolói támogatás, ismerős környezet\n";
                    requirements += "• **Utazási távolság**: Fáradtság hatás\n\n";
                    requirements += "#### 🌤️ IDŐJÁRÁS - NINCS KÖZVETLEN HATÁS:\n";
                    requirements += "• **Beltéri sport**: Időjárás nem befolyásolja a játékot\n";
                    requirements += "• **Utazási körülmények**: Csak közvetett hatás\n";
                    requirements += "• **SÚLYOZÁS**: Időjárás hatás = 50 (semleges) minden esetben!\n\n";
                    requirements += "#### 👥 JÁTÉKOSOK - CSAPATJÁTÉK SÚLYOZÁS:\n";
                    requirements += "• **Kulcsjátékosok**: Max 25% hatás (sztárok, playmaker)\n";
                    requirements += "• **Rotáció**: Cserepad mélysége fontos\n";
                    requirements += "• **Fáradtság**: Back-to-back meccsek hatása\n";
                    requirements += "• **SÚLYOZÁS**: Csapatjátékban kevésbé kritikus mint egyéni sportban!\n\n";
                    break;
                    
                case 'hockey':
                    requirements += "### 🏒 JÉGKORONG - KRITIKUS ADATOK SÚLYOZÁSSAL:\n\n";
                    requirements += "#### 🏟️ HELYSZÍN TÍPUS (BELTÉRI SPORT!):\n";
                    requirements += "• **Jégcsarnok**: Beltéri (időjárás NINCS HATÁS!)\n";
                    requirements += "• **Jég minőség**: Hőmérséklet csak a jég állapotára\n";
                    requirements += "• **Hazai pálya**: Utolsó cserepad előny\n\n";
                    requirements += "#### 🌤️ IDŐJÁRÁS - NINCS KÖZVETLEN HATÁS:\n";
                    requirements += "• **Beltéri sport**: Időjárás nem befolyásolja a játékot\n";
                    requirements += "• **Jég hőmérséklet**: Optimális -5°C (belső hőmérséklet)\n";
                    requirements += "• **SÚLYOZÁS**: Időjárás hatás = 50 (semleges) minden esetben!\n\n";
                    requirements += "#### 🥅 KAPUS - KULCSFONTOSSÁGÚ POZÍCIÓ (50%+ HATÁS!):\n";
                    requirements += "• **Kapus személye**: KRITIKUS! 50-70% hatás a meccsen!\n";
                    requirements += "• **Kapus forma**: Save%, GAA, recent performance\n";
                    requirements += "• **Kapus sérülés**: Cserekapus = 30-50% teljesítménycsökkenés\n";
                    requirements += "• **Kapus pihenő**: Fáradtság hatás kritikus\n";
                    requirements += "• **SÚLYOZÁS**: Kapus = 70-80 ha jó forma, 20-30 ha rossz!\n\n";
                    requirements += "#### 👥 EGYÉB JÁTÉKOSOK:\n";
                    requirements += "• **Kulcs védők**: Max 20% hatás\n";
                    requirements += "• **Támadók**: Max 15% hatás\n";
                    requirements += "• **SÚLYOZÁS**: Kapus >> minden más játékos!\n\n";
                    break;
                    
                case 'baseball':
                    requirements += "### ⚾ BASEBALL - KRITIKUS ADATOK SÚLYOZÁSSAL:\n\n";
                    requirements += "#### 🏟️ HELYSZÍN TÍPUS (SZABADTÉRI SPORT!):\n";
                    requirements += "• **Stadion típus**: Szabadtéri (időjárás KRITIKUS!)\n";
                    requirements += "• **Park faktor**: Stadion méret és jellemzők\n";
                    requirements += "• **Magasság**: Altitude hatás labda röppályára\n\n";
                    requirements += "#### 🌤️ IDŐJÁRÁS - MAXIMÁLIS PRIORITÁS (25% HATÁS!):\n";
                    requirements += "• **Hőmérséklet**: Optimális 21°C, ±12°C = labda távolság változás\n";
                    requirements += "• **Szél**: KRITIKUS! Segítő/gátló szél = home run különbség\n";
                    requirements += "• **Páratartalom**: Optimális 40%, ±25% = labda viselkedés\n";
                    requirements += "• **Magasság**: +0.01%/méter hatás (Denver = +6% home run)\n";
                    requirements += "• **SÚLYOZÁS**: Baseball legérzékenyebb az időjárásra!\n\n";
                    requirements += "#### ⚾ DOBÓ - KULCSFONTOSSÁGÚ POZÍCIÓ (60%+ HATÁS!):\n";
                    requirements += "• **Kezdő dobó**: KRITIKUS! 60-80% hatás a meccsen!\n";
                    requirements += "• **Dobó forma**: FIP, ERA, WHIP, recent starts\n";
                    requirements += "• **Dobó fáradtság**: Pihenő napok száma\n";
                    requirements += "• **Bullpen minőség**: Késői innings hatás\n";
                    requirements += "• **SÚLYOZÁS**: Dobó = 70-90 ha jó forma, 10-30 ha rossz!\n\n";
                    requirements += "#### 👥 EGYÉB JÁTÉKOSOK:\n";
                    requirements += "• **Kulcs ütők**: Max 20% hatás\n";
                    requirements += "• **Védők**: Max 10% hatás\n";
                    requirements += "• **SÚLYOZÁS**: Dobó >> minden más játékos!\n\n";
                    break;
                    
                case 'americanfootball':
                    requirements += "### 🏈 AMERIKAI FUTBALL - KRITIKUS ADATOK SÚLYOZÁSSAL:\n\n";
                    requirements += "#### 🏟️ HELYSZÍN TÍPUS (SZABADTÉRI/BELTÉRI):\n";
                    requirements += "• **Stadion típus**: Ellenőrizd szabadtéri/fedett!\n";
                    requirements += "• **Műfű/Természetes**: Sérülés kockázat\n";
                    requirements += "• **Hazai pálya**: Crowd noise hatás\n\n";
                    requirements += "#### 🌤️ IDŐJÁRÁS (SZABADTÉRI STADIONOKBAN!):\n";
                    requirements += "• **Hőmérséklet**: Extrém hideg/meleg = teljesítménycsökkenés\n";
                    requirements += "• **Szél**: Passing game vs rushing game\n";
                    requirements += "• **Eső/Hó**: Labda kontroll nehézségek\n";
                    requirements += "• **SÚLYOZÁS**: Csak szabadtéri stadionokban számít!\n\n";
                    requirements += "#### 👥 JÁTÉKOSOK - POZÍCIÓ SPECIFIKUS SÚLYOZÁS:\n";
                    requirements += "• **Quarterback**: 40-50% hatás (legfontosabb pozíció)\n";
                    requirements += "• **Running Back**: 20-25% hatás\n";
                    requirements += "• **Wide Receiver**: 15-20% hatás\n";
                    requirements += "• **Védelem**: Pozíciónként 10-15% hatás\n\n";
                    break;
                    
                case 'tennis':
                    requirements += "### 🎾 TENISZ - REÁLIS ADATOK:\n\n";
                    requirements += "#### 🏟️ Alapadatok:\n";
                    requirements += "• **Játékosok**: Pontos nevek\n";
                    requirements += "• **Tornament**: Név, kategória (ha ismert)\n";
                    requirements += "• **Helyszín**: Indoor/outdoor (FONTOS!)\n";
                    requirements += "• **Pálya**: Clay/hard/grass (ha ismert)\n\n";
                    requirements += "#### 📊 Egyszerű adatok:\n";
                    requirements += "• **Rangsor**: Ha könnyen elérhető\n";
                    requirements += "• **Forma**: Ha van friss adat\n";
                    requirements += "• **Sérülések**: Ha nyilvános\n\n";
                    requirements += "#### 🌤️ Időjárás (csak outdoor):\n";
                    requirements += "• **Hőmérséklet**: Általános előrejelzés\n";
                    requirements += "• **Szél**: Ha jelentős\n";
                    requirements += "• **Hatás**: 50 (semleges) alapértelmezés\n\n";
                    break;
                    
                case 'basketball':
                    requirements += "### 🏀 KOSÁRLABDA - REÁLIS ADATOK:\n\n";
                    requirements += "#### 🏟️ Alapadatok:\n";
                    requirements += "• **Csapatok**: Pontos nevek, liga\n";
                    requirements += "• **Helyszín**: Arena neve (indoor)\n";
                    requirements += "• **Liga pozíció**: Ha elérhető\n\n";
                    requirements += "#### 📊 Egyszerű adatok:\n";
                    requirements += "• **Forma**: Ha van friss adat\n";
                    requirements += "• **Sérülések**: Ha nyilvános\n";
                    requirements += "• **Alapértelmezés**: 50 (semleges) értékek\n\n";
                    break;
                    
                case 'hockey':
                    requirements += "### 🏒 JÉGKORONG - REÁLIS ADATOK:\n\n";
                    requirements += "#### 🏟️ Alapadatok:\n";
                    requirements += "• **Csapatok**: Pontos nevek, liga\n";
                    requirements += "• **Helyszín**: Arena neve (indoor)\n";
                    requirements += "• **Liga pozíció**: Ha elérhető\n\n";
                    requirements += "#### 📊 Egyszerű adatok:\n";
                    requirements += "• **Forma**: Ha van friss adat\n";
                    requirements += "• **Kapus**: Ha ismert a kezdő\n";
                    requirements += "• **Alapértelmezés**: 50 (semleges) értékek\n\n";
                    break;
                    
                case 'baseball':
                    requirements += "### ⚾ BASEBALL - REÁLIS ADATOK:\n\n";
                    requirements += "#### 🏟️ Alapadatok:\n";
                    requirements += "• **Csapatok**: Pontos nevek, liga\n";
                    requirements += "• **Helyszín**: Stadion neve (outdoor)\n";
                    requirements += "• **Liga pozíció**: Ha elérhető\n\n";
                    requirements += "#### 🌤️ Időjárás (szabadtéri):\n";
                    requirements += "• **Hőmérséklet**: Általános előrejelzés\n";
                    requirements += "• **Szél**: Ha jelentős\n";
                    requirements += "• **Eső**: Ha várható\n\n";
                    requirements += "#### 📊 Egyszerű adatok:\n";
                    requirements += "• **Forma**: Ha van friss adat\n";
                    requirements += "• **Dobók**: Ha ismert a kezdő\n";
                    requirements += "• **Alapértelmezés**: 50 (semleges) értékek\n\n";
                    break;
                    
                default:
                    requirements += `### ${sport.toUpperCase()} - GENERAL REQUIREMENTS:\n\n`;
                    requirements += "• Recent form and performance data\n";
                    requirements += "• Head-to-head records\n";
                    requirements += "• Player availability and injuries\n";
                    requirements += "• Venue conditions and advantages\n";
                    requirements += "• Motivational factors\n\n";
            }
            
            return requirements;
        }

        function generateComprehensiveJsonExample(sport) {
            if (sport === 'football') {
                return `    {
      "sport": "football",
      "matches": [
        {
          "home_team": "Manchester City",
          "away_team": "Arsenal",
          "league": "Premier League",
          "match_date": "2024-01-15",
          "venue": "Etihad Stadium",
          "venue_type": "outdoor",
          
          "fair_odds_calculation": {
            "home_win_prob": 0.52,
            "draw_prob": 0.28,
            "away_win_prob": 0.20,
            "calculation_method": "Dixon-Coles modell és logikus becslés alapján"
          },
          
          "total_goals_prob": {
            "over_2_5": 0.58, "under_2_5": 0.42,
            "over_3_5": 0.32, "under_3_5": 0.68
          },
          
          "both_teams_score": { "yes": 0.65, "no": 0.35 },
          
          "team_stats": {
            "home_team": {
              "recent_form": "W-W-D-W-L",
              "league_position": 2
            },
            "away_team": {
              "recent_form": "W-L-W-W-D", 
              "league_position": 4
            }
          },
          
          "head_to_head": {
            "overall_record": "City leads slightly",
            "recent_meetings": "nincs adat"
          },
          
          "weather_analysis": {
            "temperature": 8,
            "conditions": "Partly cloudy",
            "venue_type": "outdoor",
            "team_a_weather_impact": 48,
            "team_b_weather_impact": 52,
            "weather_impact_reasoning": "SZABADTÉRI labdarúgás - 8°C hűvös, optimális 15°C, enyhe hatás"
          },
          
          "missing_players_analysis": {
            "team_a_missing": [
              {
                "player_name": "Kevin De Bruyne",
                "position": "Midfielder",
                "is_key_player": true,
                "impact_scale": 25,
                "injury_reasoning": "KULCSJÁTÉKOS labdarúgásban - playmaker hiánya jelentős"
              }
            ],
            "team_b_missing": [
              {
                "player_name": "Martin Odegaard",
                "position": "Midfielder", 
                "is_key_player": false,
                "impact_scale": 45,
                "injury_reasoning": "Normál játékos - mérsékelt hatás"
              }
            ]
          },
          
          "motivation_analysis": {
            "home_team_motivation": {
              "league_position": 2,
              "is_high_motivation": true,
              "motivation_scale": 85,
              "motivation_reasoning": "Címvédés fontos"
            },
            "away_team_motivation": {
              "league_position": 4,
              "is_high_motivation": true,
              "motivation_scale": 75,
              "motivation_reasoning": "Top 4 helyért küzd"
            }
          },
          
          "reasoning": "Manchester City enyhe esélyes otthon. Arsenal jó formában, de City hazai rekordja erős. De Bruyne hiánya befolyásolja City játékát. Mindkét csapat motivált - forrás: Premier League tabella és forma adatok."
        }
      ]
    },
`;
            } else if (sport === 'tennis') {
                return `    {
      "sport": "tennis",
      "matches": [
        {
          "home_team": "Novak Djokovic",
          "away_team": "Carlos Alcaraz",
          "tournament": "Australian Open",
          "match_date": "2024-01-26",
          "venue": "Rod Laver Arena",
          "venue_type": "outdoor",
          "surface_type": "hard",
          
          "fair_odds_calculation": {
            "player1_win_prob": 0.48,
            "player2_win_prob": 0.52,
            "calculation_method": "Elo rating és pálya típus alapján"
          },
          
          "total_games": {
            "over_22_5": 0.58, "under_22_5": 0.42
          },
          
          "tennis_analysis": {
            "player1_stats": {
              "current_ranking": 1,
              "recent_form": "jó"
            },
            "player2_stats": {
              "current_ranking": 2,
              "recent_form": "jó"
            },
            "surface_advantage": {
              "player_a_advantage": 75,
              "player_b_advantage": 82,
              "surface_reasoning": "Alcaraz jobb hard pályán"
            },
            "recent_injuries": {
              "player_a_injury": null,
              "player_b_injury": null
            }
          },
          
          "weather_analysis": {
            "temperature": 28,
            "conditions": "Sunny",
            "player_a_weather_impact": 50,
            "player_b_weather_impact": 50,
            "weather_impact_reasoning": "Semleges időjárási hatás"
          },
          
          "venue_conditions": {
            "venue_type": "outdoor",
            "court_surface": "hard"
          },
          
          "head_to_head": {
            "overall_record": "Djokovic leads 3-2",
            "recent_meetings": "változó eredmények"
          },
          
          "motivation_analysis": {
            "player1_motivation": {
              "is_high_motivation": true,
              "motivation_scale": 95,
              "motivation_reasoning": "Grand Slam cím"
            },
            "player2_motivation": {
              "is_high_motivation": true,
              "motivation_scale": 92,
              "motivation_reasoning": "Fiatal, bizonyítani akar"
            }
          },
          
          "reasoning": "Szoros meccs várható. Alcaraz enyhe esélyes a hard pályán mutatott jobb forma miatt. Djokovic tapasztalata vs Alcaraz lendülete. Mindketten motiváltak - forrás: ATP rangsor és forma."
        }
      ]
    },
`;
            } else if (sport === 'basketball') {
                return `    {
      "sport": "basketball",
      "matches": [
        {
          "home_team": "Los Angeles Lakers",
          "away_team": "Boston Celtics",
          "league": "NBA",
          "match_date": "2024-01-15",
          "venue": "Crypto.com Arena",
          "venue_type": "indoor",
          "tipoff_time": "22:00",
          
          "fair_odds_calculation": {
            "home_win_prob": 0.45,
            "away_win_prob": 0.55,
            "calculation_method": "Four Factors + Pace + Efficiency + Injuries"
          },
          
          "total_points_prob": {
            "specifier": "225.5",
            "over": 0.52,
            "under": 0.48,
            "over_220_5": 0.62, "under_220_5": 0.38,
            "over_230_5": 0.38, "under_230_5": 0.62
          },
          
          "handicap_prob": {
            "home_+3": 0.52, "away_-3": 0.48,
            "home_+2.5": 0.50, "away_-2.5": 0.50
          },
          
          "team_stats": {
            "home_team": {
              "offensive_efficiency": 115.2,
              "defensive_efficiency": 112.8,
              "pace": 99.5,
              "effective_fg_percentage": 54.2,
              "turnover_rate": 13.8,
              "offensive_rebound_rate": 24.5,
              "free_throw_rate": 22.1,
              "home_record": "15-8",
              "recent_form": "W-L-W-W-L"
            },
            "away_team": {
              "offensive_efficiency": 118.5,
              "defensive_efficiency": 110.2,
              "pace": 97.8,
              "effective_fg_percentage": 56.8,
              "turnover_rate": 12.2,
              "offensive_rebound_rate": 22.8,
              "free_throw_rate": 20.5,
              "away_record": "18-5",
              "recent_form": "W-W-W-L-W"
            }
          },
          
          "venue_conditions": {
            "venue_type": "indoor",
            "arena_capacity": 20000,
            "court_conditions": "Excellent",
            "home_court_advantage": 3.2,
            "arena_atmosphere": "Electric for rivalry game"
          },
          
          "missing_players_analysis": {
            "team_a_missing": [
              {
                "player_name": "Anthony Davis",
                "position": "PF/C",
                "injury_type": "Knee soreness",
                "is_key_player": true,
                "impact_scale": 20,
                "expected_return": "Game time decision"
              }
            ],
            "team_b_missing": [
              {
                "player_name": "Kristaps Porzingis",
                "position": "C",
                "injury_type": "Ankle sprain",
                "is_key_player": false,
                "impact_scale": 40,
                "expected_return": "2-3 weeks"
              }
            ]
          },
          
          "schedule_analysis": {
            "home_team_rest": 2,
            "away_team_rest": 1,
            "back_to_back": false,
            "travel_distance": 2500,
            "time_zone_change": 3,
            "fatigue_impact": "Moderate for away team"
          },
          
          "motivation_analysis": {
            "home_team_motivation": {
              "conference_standing": 9,
              "playoff_race": "Fighting for play-in",
              "is_high_motivation": true,
              "motivation_scale": 78,
              "motivation_reasoning": "Must-win game for playoff hopes"
            },
            "away_team_motivation": {
              "conference_standing": 1,
              "playoff_race": "Securing top seed",
              "is_high_motivation": false,
              "motivation_scale": 65,
              "motivation_reasoning": "Comfortable lead, can rest players"
            }
          },
          
          "reasoning": "Celtics favored despite road game due to superior efficiency and health. Lakers desperate for win but missing AD hurts interior defense. Expect high-scoring game given both teams' pace. Celtics' better shooting should overcome Lakers' home court advantage."
        }
      ]
    },
`;
            } else if (sport === 'hockey') {
                return `    {
      "sport": "hockey",
      "matches": [
        {
          "home_team": "Toronto Maple Leafs",
          "away_team": "Boston Bruins",
          "league": "NHL",
          "match_date": "2024-01-15",
          "venue": "Scotiabank Arena",
          "venue_type": "indoor",
          
          "fair_odds_calculation": {
            "home_win_prob": 0.42,
            "away_win_prob": 0.58,
            "calculation_method": "Corsi/Fenwick + Kapus teljesítmény + Speciális egységek"
          },
          
          "total_goals_prob": {
            "over_5_5": 0.55, "under_5_5": 0.45,
            "over_6_5": 0.35, "under_6_5": 0.65
          },
          
          "team_stats": {
            "home_team": {
              "corsi_for_percentage": 52.3,
              "expected_goals_for": 3.1,
              "power_play_percentage": 22.5,
              "penalty_kill_percentage": 81.2,
              "recent_form": "W-L-W-L-W"
            },
            "away_team": {
              "corsi_for_percentage": 54.8,
              "expected_goals_for": 3.4,
              "power_play_percentage": 25.1,
              "penalty_kill_percentage": 84.7,
              "recent_form": "W-W-W-L-W"
            }
          },
          
          "weather_analysis": {
            "venue_type": "indoor",
            "team_a_weather_impact": 50,
            "team_b_weather_impact": 50,
            "weather_impact_reasoning": "BELTÉRI jégkorong - időjárás NINCS HATÁS!"
          },
          
          "goaltender_analysis": {
            "home_goalie": {
              "name": "Joseph Woll",
              "save_percentage": 0.912,
              "goals_against_average": 2.85,
              "recent_form": "3-1-0 utolsó 4 meccs",
              "is_starting": true,
              "goalie_impact_scale": 75,
              "goalie_reasoning": "KRITIKUS POZÍCIÓ - jó forma, 75/100 teljesítmény"
            },
            "away_goalie": {
              "name": "Jeremy Swayman", 
              "save_percentage": 0.924,
              "goals_against_average": 2.41,
              "recent_form": "4-0-1 utolsó 5 meccs",
              "is_starting": true,
              "goalie_impact_scale": 85,
              "goalie_reasoning": "KRITIKUS POZÍCIÓ - kiváló forma, 85/100 teljesítmény"
            }
          },
          
          "missing_players_analysis": {
            "team_a_missing": [
              {
                "player_name": "Auston Matthews",
                "position": "Center",
                "is_key_player": true,
                "impact_scale": 30,
                "injury_reasoning": "Kulcs támadó - jégkorongban kevésbé kritikus mint kapus"
              }
            ],
            "team_b_missing": [
              {
                "player_name": "David Pastrnak",
                "position": "Right Wing",
                "is_key_player": true,
                "impact_scale": 25,
                "injury_reasoning": "Kulcs támadó - mérsékelt hatás, kapus fontosabb"
              }
            ]
          },
          
          "motivation_analysis": {
            "home_team_motivation": {
              "conference_standing": 3,
              "is_high_motivation": true,
              "motivation_scale": 80,
              "motivation_reasoning": "Playoff pozíció védelme"
            },
            "away_team_motivation": {
              "conference_standing": 1,
              "is_high_motivation": false,
              "motivation_scale": 70,
              "motivation_reasoning": "Vezető pozíció, kevésbé sürgős"
            }
          },
          
          "reasoning": "Boston esélyes a kiváló kapus teljesítmény (Swayman 92.4% vs Woll 91.2%) és jobb Corsi% miatt. JÉGKORONGBAN A KAPUS A LEGFONTOSABB - Swayman 85/100 vs Woll 75/100 hatás. Időjárás nincs hatás (beltéri). Hiányzó támadók kevésbé kritikusak."
        }
      ]
    },
`;
            } else if (sport === 'baseball') {
                    return `    {
      "sport": "baseball",
      "matches": [
        {
          "home_team": "Detroit Tigers",
          "away_team": "Seattle Mariners",
          "league": "MLB",
          "match_date": "2025-07-11",
          "venue": "Comerica Park",
          "venue_type": "outdoor",
          
          "fair_odds_calculation": {
            "home_win_prob": 0.602,
            "away_win_prob": 0.398,
            "draw_prob": 0.0,
            "calculation_method": "Pythagorean expectation model applied with Detroit expected winning percentage 0.617 based on runs scored 468 and runs allowed 360, Seattle expected 0.516 with 416 runs scored and 405 allowed. Log5 method for head-to-head probability calculation accounting for home field advantage."
          },
          
          "total_runs_prob": {
            "over_7_5": 0.58, "under_7_5": 0.42,
            "over_8_5": 0.45, "under_8_5": 0.55,
            "over_9_5": 0.32, "under_9_5": 0.68,
            "over_10_5": 0.22, "under_10_5": 0.78
          },
          
          "team_stats": {
            "home_team": {
              "runs_scored_season": 468,
              "runs_allowed_season": 360,
              "home_ops": 0.766,
              "home_era": 3.42,
              "home_record": "28-15",
              "bullpen_era": 3.18,
              "team_batting_avg": 0.254
            },
            "away_team": {
              "runs_scored_season": 416,
              "runs_allowed_season": 405,
              "away_ops": 0.769,
              "away_era": 4.01,
              "away_record": "22-21",
              "bullpen_era": 3.95,
              "team_batting_avg": 0.248
            }
          },
          
          "starting_pitchers": {
            "home_pitcher": {
              "name": "Tarik Skubal",
              "record": "10-2",
              "era": 2.02,
              "whip": 0.95,
              "strikeouts_per_9": 11.2,
              "recent_form": "3 consecutive quality starts",
              "pitcher_impact_scale": 85,
              "pitcher_reasoning": "KRITIKUS POZÍCIÓ - kiváló forma, 85/100 teljesítmény"
            },
            "away_pitcher": {
              "name": "Luis Castillo",
              "record": "5-5",
              "era": 3.31,
              "whip": 1.18,
              "strikeouts_per_9": 9.8,
              "recent_form": "scoreless last start",
              "pitcher_impact_scale": 65,
              "pitcher_reasoning": "KRITIKUS POZÍCIÓ - átlagos forma, 65/100 teljesítmény"
            }
          },
          
          "weather_analysis": {
            "temperature": 30,
            "wind_direction": "SSW",
            "wind_speed": 12,
            "humidity": 50,
            "precipitation_probability": 70,
            "conditions": "Thunderstorms late, partly cloudy",
            "venue_type": "outdoor",
            "team_a_weather_impact": 35,
            "team_b_weather_impact": 35,
            "weather_impact_reasoning": "SZABADTÉRI baseball - MAXIMÁLIS IDŐJÁRÁS HATÁS! 30°C meleg (opt. 21°C), SSW szél 12km/h = home run távolság növekedés, 70% eső valószínűség"
          },
          
          "venue_conditions": {
            "park_factor": {
              "runs": 100,
              "home_runs": 98,
              "batting": 100,
              "pitching": 98
            },
            "dimensions": {
              "left_field": 342,
              "left_center": 370,
              "center_field": 412,
              "right_center": 365,
              "right_field": 330,
              "foul_territory": "average"
            },
            "altitude": 620
          },
          
          "missing_players_analysis": {
            "team_a_missing": [
              {
                "player_name": "Gleyber Torres",
                "position": "2B",
                "injury_type": "neck contusion",
                "is_key_player": false,
                "impact_scale": 40,
                "expected_return": "day-to-day"
              }
            ],
            "team_b_missing": [
              {
                "player_name": "Alex Cobb",
                "position": "SP",
                "injury_type": "hip inflammation",
                "is_key_player": true,
                "impact_scale": 30,
                "expected_return": "2 weeks"
              }
            ]
          },
          
          "head_to_head": {
            "season_series": "Detroit leads 4-2",
            "last_5_meetings": [
              {"date": "2024-06-15", "result": "7-4", "winner": "Detroit"},
              {"date": "2024-06-14", "result": "3-8", "winner": "Seattle"},
              {"date": "2024-06-13", "result": "5-2", "winner": "Detroit"},
              {"date": "2024-05-20", "result": "1-6", "winner": "Seattle"},
              {"date": "2024-05-19", "result": "9-3", "winner": "Detroit"}
            ],
            "historical_record": "Detroit leads overall series 81-80 since 1993"
          },
          
          "motivation_analysis": {
            "home_team_motivation": {
              "division_standing": 1,
              "games_ahead": 3.5,
              "playoff_probability": 85,
              "is_high_motivation": true,
              "motivation_scale": 75,
              "motivation_reasoning": "Leading AL Central division, seeking to maintain momentum before All-Star break"
            },
            "away_team_motivation": {
              "division_standing": 3,
              "games_behind": 8.5,
              "playoff_probability": 45,
              "is_high_motivation": true,
              "motivation_scale": 80,
              "motivation_reasoning": "Fighting for wild card position in competitive AL West race"
            }
          },
          
          "reasoning": "Detroit jelentős előnyben Pythagorean expectation alapján (0.617 vs 0.516). DOBÓ KRITIKUS POZÍCIÓ - Skubal 85/100 vs Castillo 65/100 teljesítmény. Időjárás MAXIMÁLIS hatás baseballban - 30°C + SSW szél = home run növekedés. H2H Detroit vezet 4-2. Mindkét csapat motivált. Detroit 60.2% valószínűség."
        }
      ]
    },
`;
            } else {
                    // Generic example for all sports or unknown sports
                    return `    {
      "sport": "SPORT_NAME",
      "matches": [
        {
          "home_team": "Team/Player A",
          "away_team": "Team/Player B",
          "league": "League Name",
          "match_date": "2024-XX-XX",
          "venue": "Venue Name",
          "venue_type": "indoor/outdoor",
          
          "fair_odds_calculation": {
            "home_win_prob": 0.XX,
            "away_win_prob": 0.XX,
            "draw_prob": 0.XX,
            "calculation_method": "Detailed method explanation with specific models and data sources used"
          },
          
          "SPORT_SPECIFIC_MARKETS": {
            "market_name": { "option1": 0.XX, "option2": 0.XX }
          },
          
          "team_stats": { "detailed_statistics": "Complete statistical breakdown" },
          "head_to_head": { "historical_data": "Recent meetings and historical record" },
          "weather_analysis": { "IF_OUTDOOR_ONLY": "Temperature, wind, precipitation with impact analysis" },
          "venue_conditions": { "IF_INDOOR_ONLY": "Arena conditions and advantages" },
          "missing_players_analysis": { "injuries_and_impact": "Player availability with impact scale 1-100" },
          "motivation_analysis": { "stakes_and_motivation": "League position, playoff implications, motivation scale 1-100" },
          
          "reasoning": "Comprehensive analysis explanation incorporating all researched factors with specific data points and source justification"
        }
      ]
    },
`;
            }
        }
        
        function extractJsonFromText(text) {
            console.log('🔧 Starting intelligent JSON extraction...');
            
            // Enhanced cleaning for LLM artifacts and escaped characters
            let cleanedText = text
                .replace(/```json\s*/gi, '') // Remove json code block markers
                .replace(/```\s*/g, '') // Remove closing code block markers
                .replace(/:contentReference\[[^\]]+\]\{[^}]+\}/g, '') // Remove contentReference citations
                .replace(/::contentReference\[[^\]]+\]\{[^}]+\}/g, '') // Remove double colon contentReference
                .replace(/\s*:contentReference\[[^\]]+\]\{[^}]+\}\s*/g, ' ') // Remove with whitespace cleanup
                .replace(/contentReference\[[^\]]+\]\{[^}]+\}/g, '') // Remove without colon
                .replace(/\\\"/g, '"') // Fix escaped quotes (improved regex)
                .replace(/\\\[/g, '[') // Fix escaped brackets
                .replace(/\\\]/g, ']') // Fix escaped brackets
                .replace(/\\\\/g, '\\') // Fix double escapes
                .replace(/\s+/g, ' ') // Normalize whitespace
                .trim();
            
            // Try to find JSON object boundaries
            let startIndex = cleanedText.indexOf('{');
            let endIndex = cleanedText.lastIndexOf('}');
            
            if (startIndex === -1 || endIndex === -1 || startIndex >= endIndex) {
                console.warn('❌ No valid JSON structure found, trying emergency fallback...');
                return tryEmergencyJsonExtraction(text);
            }
            
            const jsonText = cleanedText.substring(startIndex, endIndex + 1);
            
            try {
                // Test parse to validate JSON
                const parsed = JSON.parse(jsonText);
                
                // Validate structure - handle both direct analyses array and nested structure
                let analysesArray;
                if (parsed.analyses && Array.isArray(parsed.analyses)) {
                    analysesArray = parsed.analyses;
                } else if (Array.isArray(parsed)) {
                    // Handle case where JSON is directly an array
                    analysesArray = parsed;
                } else {
                    console.warn('⚠️ Invalid structure detected, trying intelligent repair...');
                    return tryIntelligentJsonRepair(parsed, text);
                }
                
                // Ensure we have the correct structure
                if (!analysesArray || analysesArray.length === 0) {
                    console.warn('⚠️ Empty analyses array, trying data extraction...');
                    return tryDataExtraction(text);
                }
                
                // Normalize the structure
                if (!parsed.analyses) {
                    parsed = { analyses: analysesArray };
                }
                
                // Intelligent data validation and repair
                const repairedData = intelligentDataRepair(parsed);
                
                // Count total matches across all analyses
                let totalMatches = 0;
                let analysisDetails = [];
                
                // Check each analysis has required fields
                for (const analysis of repairedData.analyses) {
                    if (!analysis.sport || !analysis.matches || !Array.isArray(analysis.matches)) {
                        console.warn(`⚠️ Repairing analysis structure for sport: ${analysis.sport || 'unknown'}`);
                        analysis.sport = analysis.sport || 'football';
                        analysis.matches = analysis.matches || [];
                    }
                    
                    totalMatches += analysis.matches.length;
                    analysisDetails.push(`${analysis.sport}: ${analysis.matches.length} matches`);
                    
                    // Repair each match with minimum required fields
                    for (const match of analysis.matches) {
                        repairMatchData(match);
                    }
                }
                
                // Log analysis summary
                console.log(`✅ JSON Analysis Summary: ${totalMatches} total matches found`);
                console.log('Details:', analysisDetails.join('; '));
                
                return JSON.stringify(repairedData);
                
            } catch (parseError) {
                console.error('❌ JSON parse error:', parseError);
                console.warn('🔧 Trying emergency repair methods...');
                
                return tryEmergencyJsonRepair(jsonText, text);
            }
        }
        
        // Emergency JSON extraction when structure is completely broken
        function tryEmergencyJsonExtraction(text) {
            console.log('🚨 Emergency JSON extraction activated');
            
            try {
                // Try to extract any team names and basic data
                const teamMatches = text.match(/([A-Za-z\s]+)\s+vs?\s+([A-Za-z\s]+)/gi) || [];
                const oddsMatches = text.match(/\d+\.\d+/g) || [];
                
                if (teamMatches.length === 0) {
                    throw new Error('No team matches found in emergency extraction');
                }
                
                const emergencyData = {
                    analyses: [{
                        sport: 'football',
                        matches: teamMatches.slice(0, 5).map((match, index) => {
                            const teams = match.split(/\s+vs?\s+/i);
                            const homeTeam = teams[0]?.trim() || `Team A${index + 1}`;
                            const awayTeam = teams[1]?.trim() || `Team B${index + 1}`;
                            
                            return {
                                home_team: homeTeam,
                                away_team: awayTeam,
                                league: "Unknown League",
                                match_date: new Date().toISOString().split('T')[0],
                                venue: "Unknown Venue",
                                venue_type: "outdoor",
                                
                                fair_odds_calculation: {
                                    home_win_prob: 0.40,
                                    draw_prob: 0.30,
                                    away_win_prob: 0.30,
                                    calculation_method: "Emergency fallback - equal probabilities with slight home advantage"
                                },
                                
                                total_goals_prob: {
                                    over_2_5: 0.50,
                                    under_2_5: 0.50
                                },
                                
                                both_teams_score: {
                                    yes: 0.55,
                                    no: 0.45
                                },
                                
                                reasoning: `Emergency data extraction for ${homeTeam} vs ${awayTeam}. No detailed analysis available - using conservative estimates.`
                            };
                        })
                    }]
                };
                
                console.log('✅ Emergency extraction successful:', emergencyData.analyses[0].matches.length, 'matches created');
                return JSON.stringify(emergencyData);
                
            } catch (error) {
                console.error('❌ Emergency extraction failed:', error);
                throw new Error('Nem sikerült semmilyen adatot kinyerni a szövegből. Kérlek, ellenőrizd a JSON formátumot!');
            }
        }
        
        // Intelligent JSON repair for complex/oversized data
        function tryIntelligentJsonRepair(parsed, originalText) {
            console.log('🔧 Intelligent JSON repair starting...');
            
            try {
                const repairedData = { analyses: [] };
                
                // Try to find sport and match data in various possible structures
                const possibleKeys = Object.keys(parsed);
                console.log('Available keys:', possibleKeys);
                
                // Look for sport-related data
                for (const key of possibleKeys) {
                    const value = parsed[key];
                    
                    if (typeof value === 'object' && value !== null) {
                        // Check if this could be a sport analysis
                        if (value.sport || value.matches || Array.isArray(value)) {
                            const sportData = extractSportDataFromObject(value, key);
                            if (sportData) {
                                repairedData.analyses.push(sportData);
                            }
                        }
                    }
                }
                
                // If no analyses found, create a basic structure
                if (repairedData.analyses.length === 0) {
                    console.warn('⚠️ No valid sport data found, creating basic structure...');
                    repairedData.analyses.push(createBasicSportAnalysis(parsed));
                }
                
                console.log('✅ Intelligent repair successful:', repairedData.analyses.length, 'analyses created');
                return JSON.stringify(repairedData);
                
            } catch (error) {
                console.error('❌ Intelligent repair failed:', error);
                return tryDataExtraction(originalText);
            }
        }
        
        // Extract sport data from complex objects
        function extractSportDataFromObject(obj, fallbackSport = 'football') {
            try {
                const sport = obj.sport || fallbackSport.toLowerCase();
                let matches = [];
                
                if (obj.matches && Array.isArray(obj.matches)) {
                    matches = obj.matches;
                } else if (Array.isArray(obj)) {
                    matches = obj;
                } else {
                    // Try to create a match from the object itself
                    if (obj.home_team || obj.away_team || obj.team_a || obj.team_b) {
                        matches = [obj];
                    }
                }
                
                // Repair each match
                matches = matches.map(match => repairMatchData(match)).filter(match => match !== null);
                
                if (matches.length === 0) {
                    return null;
                }
                
                return {
                    sport: sport,
                    matches: matches
                };
                
            } catch (error) {
                console.error('Error extracting sport data:', error);
                return null;
            }
        }
        
        // Create basic sport analysis from any object
        function createBasicSportAnalysis(obj) {
            const analysis = {
                sport: 'football',
                matches: []
            };
            
            // Try to extract any team-like data
            const possibleMatch = {
                home_team: obj.home_team || obj.team_a || obj.team1 || 'Team A',
                away_team: obj.away_team || obj.team_b || obj.team2 || 'Team B',
                league: obj.league || obj.tournament || 'Unknown League',
                match_date: obj.match_date || obj.date || new Date().toISOString().split('T')[0],
                venue: obj.venue || obj.stadium || 'Unknown Venue',
                venue_type: obj.venue_type || 'outdoor'
            };
            
            analysis.matches.push(repairMatchData(possibleMatch));
            
            return analysis;
        }
        
        // Repair individual match data
        function repairMatchData(match) {
            if (!match || typeof match !== 'object') {
                return null;
            }
            
            // Ensure basic team names
            if (!match.home_team && !match.away_team) {
                return null;
            }
            
            match.home_team = match.home_team || match.team_a || match.team1 || 'Team A';
            match.away_team = match.away_team || match.team_b || match.team2 || 'Team B';
            match.league = match.league || match.tournament || 'Unknown League';
            match.match_date = match.match_date || match.date || new Date().toISOString().split('T')[0];
            match.venue = match.venue || match.stadium || 'Unknown Venue';
            match.venue_type = match.venue_type || 'outdoor';
            
            // Ensure fair_odds_calculation exists
            if (!match.fair_odds_calculation) {
                match.fair_odds_calculation = {
                    home_win_prob: 0.40,
                    draw_prob: 0.30,
                    away_win_prob: 0.30,
                    calculation_method: "Auto-generated fallback probabilities"
                };
            }
            
            // Ensure basic market probabilities for football
            if (!match.total_goals_prob) {
                match.total_goals_prob = {
                    over_2_5: 0.50,
                    under_2_5: 0.50
                };
            }
            
            if (!match.both_teams_score) {
                match.both_teams_score = {
                    yes: 0.55,
                    no: 0.45
                };
            }
            
            // Ensure reasoning exists
            if (!match.reasoning) {
                match.reasoning = `Auto-repaired data for ${match.home_team} vs ${match.away_team}. Limited analysis available.`;
            }
            
            return match;
        }
        
        // Try simple data extraction from text
        function tryDataExtraction(text) {
            console.log('🔧 Trying simple data extraction...');
            
            try {
                // Extract team names using various patterns
                const teamPatterns = [
                    /([A-Za-z\s]+)\s+vs?\s+([A-Za-z\s]+)/gi,
                    /([A-Za-z\s]+)\s+-\s+([A-Za-z\s]+)/gi,
                    /"home_team":\s*"([^"]+)"/gi,
                    /"away_team":\s*"([^"]+)"/gi
                ];
                
                const matches = [];
                const foundTeams = new Set();
                
                for (const pattern of teamPatterns) {
                    let match;
                    while ((match = pattern.exec(text)) !== null) {
                        const homeTeam = match[1]?.trim();
                        const awayTeam = match[2]?.trim();
                        
                        if (homeTeam && awayTeam && homeTeam !== awayTeam) {
                            const matchKey = `${homeTeam}_vs_${awayTeam}`;
                            if (!foundTeams.has(matchKey)) {
                                foundTeams.add(matchKey);
                                matches.push({
                                    home_team: homeTeam,
                                    away_team: awayTeam,
                                    league: "Extracted League",
                                    match_date: new Date().toISOString().split('T')[0],
                                    venue: "Extracted Venue",
                                    venue_type: "outdoor",
                                    fair_odds_calculation: {
                                        home_win_prob: 0.40,
                                        draw_prob: 0.30,
                                        away_win_prob: 0.30,
                                        calculation_method: "Text extraction fallback"
                                    },
                                    total_goals_prob: { over_2_5: 0.50, under_2_5: 0.50 },
                                    both_teams_score: { yes: 0.55, no: 0.45 },
                                    reasoning: `Extracted from text: ${homeTeam} vs ${awayTeam}`
                                });
                            }
                        }
                    }
                }
                
                if (matches.length === 0) {
                    throw new Error('No matches found in text extraction');
                }
                
                const extractedData = {
                    analyses: [{
                        sport: 'football',
                        matches: matches.slice(0, 10) // Limit to 10 matches
                    }]
                };
                
                console.log('✅ Data extraction successful:', matches.length, 'matches found');
                return JSON.stringify(extractedData);
                
            } catch (error) {
                console.error('❌ Data extraction failed:', error);
                throw new Error('Nem sikerült semmilyen használható adatot kinyerni a szövegből!');
            }
        }
        
        // Emergency JSON repair for broken syntax
        function tryEmergencyJsonRepair(brokenJson, originalText) {
            console.log('🚨 Emergency JSON repair activated');
            
            try {
                // Try to fix common JSON syntax errors
                let repairedJson = brokenJson
                    .replace(/,\s*}/g, '}') // Remove trailing commas
                    .replace(/,\s*]/g, ']') // Remove trailing commas in arrays
                    .replace(/:\s*,/g, ': null,') // Fix empty values
                    .replace(/}\s*{/g, '}, {') // Fix missing commas between objects
                    .replace(/]\s*\[/g, '], [') // Fix missing commas between arrays
                    .replace(/([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '"$1":') // Quote unquoted keys
                    .replace(/:\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*([,}])/g, ': "$1"$2'); // Quote unquoted string values
                
                // Try to parse the repaired JSON
                const parsed = JSON.parse(repairedJson);
                
                // If successful, process normally
                return tryIntelligentJsonRepair(parsed, originalText);
                
            } catch (error) {
                console.error('❌ Emergency JSON repair failed:', error);
                
                // Last resort: try data extraction
                return tryDataExtraction(originalText);
            }
        }
        
        // Intelligent data repair for oversized or complex data
        function intelligentDataRepair(data) {
            try {
                console.log('🔧 Intelligent data repair starting...');
                
                // Limit the size of data to prevent performance issues
                if (data.analyses && Array.isArray(data.analyses)) {
                    // Limit to 5 sports maximum
                    data.analyses = data.analyses.slice(0, 5);
                    
                    data.analyses.forEach(analysis => {
                        if (analysis.matches && Array.isArray(analysis.matches)) {
                            // Limit to 10 matches per sport
                            analysis.matches = analysis.matches.slice(0, 10);
                            
                            // Clean up oversized objects
                            analysis.matches.forEach(match => {
                                // Remove overly complex nested objects
                                Object.keys(match).forEach(key => {
                                    if (typeof match[key] === 'object' && match[key] !== null) {
                                        const obj = match[key];
                                        const objKeys = Object.keys(obj);
                                        
                                        // If object has too many keys, simplify it
                                        if (objKeys.length > 20) {
                                            console.warn(`⚠️ Simplifying oversized object: ${key}`);
                                            match[key] = simplifyComplexObject(obj);
                                        }
                                    }
                                });
                                
                                // Ensure essential fields exist
                                repairMatchData(match);
                            });
                        }
                    });
                }
                
                console.log('✅ Intelligent data repair completed');
                return data;
                
            } catch (error) {
                console.error('❌ Intelligent data repair failed:', error);
                return data; // Return original data if repair fails
            }
        }
        
        // Simplify complex objects to essential data only
        function simplifyComplexObject(obj) {
            const essential = {};
            const importantKeys = [
                'home_win_prob', 'draw_prob', 'away_win_prob', 'player1_win_prob', 'player2_win_prob',
                'over_2_5', 'under_2_5', 'over_3_5', 'under_3_5',
                'yes', 'no', 'home', 'away', 'draw',
                'calculation_method', 'reasoning', 'impact_scale', 'motivation_scale'
            ];
            
            importantKeys.forEach(key => {
                if (obj.hasOwnProperty(key)) {
                    essential[key] = obj[key];
                }
            });
            
            // If no important keys found, keep first 5 keys
            if (Object.keys(essential).length === 0) {
                const keys = Object.keys(obj).slice(0, 5);
                keys.forEach(key => {
                    essential[key] = obj[key];
                });
            }
            
            return essential;
        }

        function processAllRetrievedData() {
            showLocalizedLoading('loadingPortfolioBuilder', 'loadingGeneratingRecommendations');
            
            try {
                const rawData = DOM.retrievedDataInput.value.trim();
                if (!rawData) {
                    showLocalizedNotification('notificationEmptyDataField', 'warning');
                    UIManager.hideLoading();
                    return;
                }

                let parsedData;
                try {
                    const jsonText = extractJsonFromText(rawData);
                    parsedData = JSON.parse(jsonText);
                    
                    // Ellenőrizzük a JSON struktúrát - támogatjuk mindkét formátumot
                    if (!parsedData.analyses || !Array.isArray(parsedData.analyses)) {
                        throw new Error(getText('errorInvalidJsonStructure') + '. Expected: {"analyses": [...]}');
                    }
                    
                    // Validáljuk hogy minden analysis tartalmaz sportot és meccseket
                    parsedData.analyses.forEach((analysis, index) => {
                        if (!analysis.sport) {
                            throw new Error(`Analysis ${index + 1}: Missing sport field`);
                        }
                        if (!analysis.matches || !Array.isArray(analysis.matches)) {
                            throw new Error(`Analysis ${index + 1}: Missing or invalid matches array`);
                        }
                        if (analysis.matches.length === 0) {
                            console.warn(`Analysis ${index + 1}: Empty matches array for sport ${analysis.sport}`);
                        }
                    });
                    
                } catch (e) {
                    console.error('JSON parsing error:', e);
                    showLocalizedNotification('notificationJsonError', 'error', { error: e.message });
                    UIManager.hideLoading();
                    return;
                }
                
                // Tároljuk az adatokat és generáljuk a portfóliót
                AppState.retrievedData = parsedData;
                console.log(`Successfully processed ${parsedData.analyses.length} sport analyses with ${parsedData.analyses.reduce((total, a) => total + a.matches.length, 0)} total matches`);
                
                showLocalizedNotification('notificationDataLoaded', 'success');
                
                // Generáljuk a portfóliót az összes matematikai modellel
                const portfolio = generatePortfolio(AppState.retrievedData.analyses, AppState.uploadedImages);
                AppState.portfolio = portfolio;

                // Megjeleníítjük az eredményeket
                displayPortfolio(portfolio);
                UIManager.switchTab('results');
                
                showLocalizedNotification('notificationAllPromptsComplete', 'success');

            } catch (error) {
                console.error("Error processing retrieved data:", error);
                showLocalizedNotification('notificationDataLoadError', 'error', { error: error.message });
            } finally {
                UIManager.hideLoading();
            }
        }
        
        // Prompt completion functions removed - now we always have only one prompt
        
        function generatePortfolio(llmAnalyses, imageAnalyses) {
            const capital = parseFloat(document.getElementById('capital').value);
            const maxRiskPct = parseFloat(document.getElementById('maxRisk').value) / 100;
            const kellyModifierSingle = parseFloat(document.getElementById('kellyModifierSingle').value);
            const kellyModifierParlay = parseFloat(document.getElementById('kellyModifierParlay').value);

            // Életszerű minimum tétek
            const MIN_STAKE_SINGLE = capital * 0.005; // Minimum 0.5% of capital (5 EUR for 1000 EUR)
            const MIN_STAKE_PARLAY = capital * 0.002; // Minimum 0.2% for parlays (2 EUR for 1000 EUR)
            const MIN_EDGE = 0.03; // Minimum 3% edge required
            const MIN_EV = capital * 0.001; // Minimum expected value 0.1% of capital

            // 1. Create a flat list of all odds found in the uploaded images.
            const allFoundOdds = imageAnalyses.flatMap(image => {
                if (!image.analysisResult || image.status !== 'completed') return [];
                return (image.analysisResult.odds_found || []).map(odd => ({
                    ...odd,
                    match: (image.analysisResult.matches_detected || [])[odd.applies_to_match_index],
                    sport: (image.analysisResult.sport_type || 'unknown').toLowerCase(),
                }));
            });

            const bestBetsMap = new Map();
            
            console.log('Processing odds for portfolio generation...');
            console.log('Found odds by sport:', allFoundOdds.reduce((acc, odd) => {
                acc[odd.sport] = (acc[odd.sport] || 0) + 1;
                return acc;
            }, {}));

            // 2. Enhanced odds matching with detailed probability extraction
            allFoundOdds.forEach(oddInfo => {
                if (!oddInfo.match) return;

                const normalizeSport = (sport) => {
                    const sportLower = sport.toLowerCase();
                    if (sportLower === 'soccer') return 'football';
                    if (sportLower === 'americanfootball') return 'americanfootball';
                    return sportLower;
                };

                const normalizedOddSport = normalizeSport(oddInfo.sport);
                const llmAnalysisForSport = llmAnalyses.find(a => 
                    normalizeSport(a.sport) === normalizedOddSport
                );
                
                if (!llmAnalysisForSport) {
                    console.warn(`No LLM analysis found for sport: ${oddInfo.sport}`);
                    return;
                }

                const llmMatchAnalysis = llmAnalysisForSport.matches.find(m =>
                    m.home_team.toLowerCase().includes(oddInfo.match.home_team.toLowerCase().split(' ')[0]) ||
                    m.away_team.toLowerCase().includes(oddInfo.match.away_team.toLowerCase().split(' ')[0]) ||
                    oddInfo.match.home_team.toLowerCase().includes(m.home_team.toLowerCase().split(' ')[0]) ||
                    oddInfo.match.away_team.toLowerCase().includes(m.away_team.toLowerCase().split(' ')[0])
                );
                
                if (!llmMatchAnalysis) {
                    console.warn(`No LLM match analysis found for: ${oddInfo.match.home_team} vs ${oddInfo.match.away_team}`);
                    return;
                }

                // Enhanced probability extraction for multiple markets
                for (const [selection, odds] of Object.entries(oddInfo.values)) {
                    let prob = 0;
                    let marketAnalysis = null;

                    // Match Result Markets
                    if (oddInfo.market_type === 'match_result' && llmMatchAnalysis.fair_odds_calculation) {
                        const probCalc = llmMatchAnalysis.fair_odds_calculation;
                        const selLower = selection.toLowerCase();
                        
                        if (oddInfo.sport === 'tennis') {
                            if (selLower.includes(llmMatchAnalysis.home_team.toLowerCase()) || selLower === '1') {
                                prob = probCalc.player1_win_prob || 0;
                            } else if (selLower.includes(llmMatchAnalysis.away_team.toLowerCase()) || selLower === '2') {
                                prob = probCalc.player2_win_prob || 0;
                            }
                        } else {
                            if (selLower.includes('home') || selLower === '1') prob = probCalc.home_win_prob || 0;
                            else if (selLower.includes('away') || selLower === '2') prob = probCalc.away_win_prob || 0;
                            else if (selLower.includes('draw') || selLower === 'x') prob = probCalc.draw_prob || 0;
                        }
                        marketAnalysis = llmMatchAnalysis.fair_odds_calculation;
                    }
                    
                    // Total Goals/Points Markets
                    else if (oddInfo.market_type.includes('total') || oddInfo.market_type.includes('over_under')) {
                        const totalProbKeys = ['total_goals_prob', 'total_points_prob', 'total_runs_prob'];
                        let probCalc = totalProbKeys.map(key => llmMatchAnalysis[key]).find(p => p);
                        
                        if (probCalc) {
                            const selLower = selection.toLowerCase();
                            // Try to match the specifier (e.g., 2.5, 218.5)
                            const specifier = oddInfo.market_specifier;
                            
                            // Look for matching over/under in detailed breakdown
                            if (specifier) {
                                const overKey = `over_${specifier.replace('.', '_')}`;
                                const underKey = `under_${specifier.replace('.', '_')}`;
                                
                                if (selLower.includes('over') && probCalc[overKey]) {
                                    prob = probCalc[overKey];
                                } else if (selLower.includes('under') && probCalc[underKey]) {
                                    prob = probCalc[underKey];
                                }
                            }
                            
                            // Fallback to basic over/under if detailed not found
                            if (prob === 0) {
                                if (selLower.includes('over')) prob = probCalc.over || 0;
                                else if (selLower.includes('under')) prob = probCalc.under || 0;
                            }
                            marketAnalysis = probCalc;
                        }
                    }
                    
                    // Corner Markets
                    else if (oddInfo.market_type.includes('corner')) {
                        if (llmMatchAnalysis.corners_prob) {
                            const selLower = selection.toLowerCase();
                            const specifier = oddInfo.market_specifier;
                            
                            if (specifier) {
                                const overKey = `over_${specifier.replace('.', '_')}`;
                                const underKey = `under_${specifier.replace('.', '_')}`;
                                
                                if (selLower.includes('over') && llmMatchAnalysis.corners_prob[overKey]) {
                                    prob = llmMatchAnalysis.corners_prob[overKey];
                                } else if (selLower.includes('under') && llmMatchAnalysis.corners_prob[underKey]) {
                                    prob = llmMatchAnalysis.corners_prob[underKey];
                                }
                            }
                            marketAnalysis = llmMatchAnalysis.corners_prob;
                        }
                    }
                    
                    // Card Markets
                    else if (oddInfo.market_type.includes('card')) {
                        if (llmMatchAnalysis.cards_prob) {
                            const selLower = selection.toLowerCase();
                            const specifier = oddInfo.market_specifier;
                            
                            if (specifier) {
                                const overKey = `over_${specifier.replace('.', '_')}`;
                                const underKey = `under_${specifier.replace('.', '_')}`;
                                
                                if (selLower.includes('over') && llmMatchAnalysis.cards_prob[overKey]) {
                                    prob = llmMatchAnalysis.cards_prob[overKey];
                                } else if (selLower.includes('under') && llmMatchAnalysis.cards_prob[underKey]) {
                                    prob = llmMatchAnalysis.cards_prob[underKey];
                                }
                            }
                            marketAnalysis = llmMatchAnalysis.cards_prob;
                        }
                    }
                    
                    // Handicap Markets
                    else if (oddInfo.market_type.includes('handicap')) {
                        if (llmMatchAnalysis.handicap_prob) {
                            const selLower = selection.toLowerCase();
                            const specifier = oddInfo.market_specifier;
                            
                            // Try to match handicap selection
                            Object.entries(llmMatchAnalysis.handicap_prob).forEach(([key, value]) => {
                                if (key.toLowerCase().includes(selLower) || selLower.includes(key.toLowerCase())) {
                                    prob = value;
                                }
                            });
                            marketAnalysis = llmMatchAnalysis.handicap_prob;
                        }
                    }
                    
                    // Both Teams to Score
                    else if (oddInfo.market_type.includes('both') || oddInfo.market_type.includes('btts')) {
                        if (llmMatchAnalysis.both_teams_score) {
                            const selLower = selection.toLowerCase();
                            if (selLower.includes('yes') || selLower.includes('both')) {
                                prob = llmMatchAnalysis.both_teams_score.yes || 0;
                            } else if (selLower.includes('no')) {
                                prob = llmMatchAnalysis.both_teams_score.no || 0;
                            }
                            marketAnalysis = llmMatchAnalysis.both_teams_score;
                        }
                    }

                    // Apply advanced adjustments if we found a probability
                    if (prob > 0) {
                        prob = applyAdvancedAdjustments(prob, llmMatchAnalysis, oddInfo.market_type);
                        
                        const edge = (prob * odds) - 1;

                        if (edge > MIN_EDGE) {
                            console.log(`Found valuable bet: ${oddInfo.sport} - ${oddInfo.match.home_team} vs ${oddInfo.match.away_team}, ${oddInfo.market_type} ${selection}, edge: ${(edge * 100).toFixed(2)}%`);
                            
                            const uniqueBetKey = `${oddInfo.sport}-${oddInfo.match.home_team}-${oddInfo.match.away_team}-${oddInfo.market_type}-${oddInfo.market_specifier}-${selection}`;
                            const currentBet = { 
                                sport: oddInfo.sport, 
                                home_team: oddInfo.match.home_team, 
                                away_team: oddInfo.match.away_team, 
                                market_type: oddInfo.market_type, 
                                market_specifier: oddInfo.market_specifier, 
                                selection, 
                                odds, 
                                prob,
                                edge,
                                marketAnalysis,
                                llmAnalysis: llmMatchAnalysis
                            };
                            
                            const existingBet = bestBetsMap.get(uniqueBetKey);
                            if (!existingBet || currentBet.odds > existingBet.odds) {
                                bestBetsMap.set(uniqueBetKey, currentBet);
                            }
                        }
                    }
                }
            });

            // 3. Enhanced stake calculation with detailed Kelly
            const finalBets = Array.from(bestBetsMap.values());
            finalBets.forEach(bet => {
                const b = bet.odds - 1; // Net odds
                const p = bet.prob;
                const q = 1 - p;
                
                // PROFESSIONAL INTEGRATED EV CALCULATION
                const advancedEV = calculateAdvancedEV({
                    prob: p, odds: bet.odds, stake: 100, sport: bet.sport, matchAnalysis: bet.matchAnalysis
                });
                
                // Update probability and edge with advanced calculations
                const adjustedProb = advancedEV.adjustedProb;
                const adjustedEdge = adjustedProb * bet.odds - 1;
                
                // Kelly fraction with enhanced calculation using adjusted probability
                const kellyFraction = b > 0 ? (b * adjustedProb - (1 - adjustedProb)) / b : 0;
                
                // Apply sport-specific and market-specific modifiers
                let modifier = kellyModifierSingle;
                if (bet.market_type.includes('corner') || bet.market_type.includes('card')) {
                    modifier *= 0.8; // More conservative for volatile markets
                } else if (bet.market_type.includes('handicap')) {
                    modifier *= 0.9; // Slightly more conservative for handicaps
                }
                
                const adjustedFraction = Math.max(0, Math.min(kellyFraction * modifier, 0.05)); // Cap at 5%
                let stake = adjustedFraction * capital;
                
                // Update bet with advanced calculations
                bet.adjustedProb = adjustedProb;
                bet.adjustedEdge = adjustedEdge;
                bet.advancedEV = advancedEV;
                
                // Enhanced stake rounding with market considerations
                if (stake > 100) {
                    stake = Math.round(stake / 10) * 10;
                } else if (stake > 50) {
                    stake = Math.round(stake / 5) * 5;
                } else if (stake > 20) {
                    stake = Math.round(stake / 2) * 2;
                } else {
                    stake = Math.round(stake);
                }
                
                bet.stake = stake;
                bet.ev = bet.stake * bet.adjustedEdge; // Use adjusted edge for EV
                bet.kellyFraction = kellyFraction;
                bet.adjustedFraction = adjustedFraction;
                bet.modifier = modifier;
                
                // Enhanced confidence calculation
                let confidenceFactors = {
                    edge: Math.min(bet.edge * 10, 1), // Edge contribution
                    probability: bet.prob, // Probability contribution
                    market: bet.market_type === 'match_result' ? 1 : 0.8, // Market type
                    dataQuality: bet.marketAnalysis ? 1 : 0.7 // Data quality
                };
                
                bet.confidence = Object.values(confidenceFactors).reduce((a, b) => a * b, 1);
            });

            // Enhanced filtering with multiple criteria
            const valuableBets = finalBets.filter(bet => 
                bet.stake >= MIN_STAKE_SINGLE && 
                bet.ev >= MIN_EV &&
                bet.edge >= MIN_EDGE &&
                bet.confidence > 0.3 // Minimum confidence threshold
            );

            // PROFESSIONAL INTEGRATED MATHEMATICAL SORTING
        // Comprehensive scoring system for long-term profitability
        valuableBets.sort((a, b) => {
            // Multi-factor scoring system
            const scoreA = calculateProfessionalScore(a);
            const scoreB = calculateProfessionalScore(b);
            return scoreB - scoreA;
        });

            // Portfolio risk management
            let totalStakePlanned = valuableBets.reduce((sum, bet) => sum + bet.stake, 0);
            const maxPortfolioStake = capital * maxRiskPct;
            
            if (totalStakePlanned > maxPortfolioStake && totalStakePlanned > 0) {
                const scale = maxPortfolioStake / totalStakePlanned;
                valuableBets.forEach(bet => {
                    bet.stake = Math.max(MIN_STAKE_SINGLE, Math.round(bet.stake * scale));
                    bet.ev = bet.stake * bet.edge;
                });
            }

            const singles = valuableBets;
            const parlays = generateEnhancedParlays(valuableBets, capital, kellyModifierParlay, MIN_STAKE_PARLAY, MIN_EDGE);

            console.log(`Generated portfolio: ${singles.length} singles, ${parlays.length} parlays`);

            return { singles, parlays };
        }
        
        function generateEnhancedParlays(bets, capital, kellyModifier, minStake, minEdge) {
            const comboStrategy = document.getElementById('comboStrategy').value;

            // Enhanced parlay generation with better filtering
            const uniqueBets = [];
            const seenMatches = new Set();
            const seenMarkets = new Set();
            
            for (const bet of bets) {
                const matchIdentifier = `${bet.home_team}-${bet.away_team}`;
                const marketIdentifier = `${matchIdentifier}-${bet.market_type}`;
                
                // Avoid same match and correlated markets
                if (!seenMatches.has(matchIdentifier) && !seenMarkets.has(marketIdentifier)) {
                    // Avoid highly correlated markets (e.g., match result + handicap)
                    const isCorrelated = bet.market_type === 'handicap' && 
                        uniqueBets.some(existing => 
                            existing.home_team === bet.home_team && 
                            existing.away_team === bet.away_team && 
                            existing.market_type === 'match_result'
                        );
                    
                    if (!isCorrelated) {
                    uniqueBets.push(bet);
                    seenMatches.add(matchIdentifier);
                        seenMarkets.add(marketIdentifier);
                    }
                }
            }

            if (uniqueBets.length < 3) return [];

            let selectedLegs;

            if (comboStrategy === 'ev') {
                // High EV Parlay Strategy: combine the top 3 EV bets
                selectedLegs = uniqueBets.sort((a, b) => b.ev - a.ev).slice(0, 3);
            } else {
                // High Probability Parlay Strategy: combine the top 3 highest probability bets
                selectedLegs = uniqueBets.sort((a, b) => b.prob - a.prob).slice(0, 3);
            }
            
            if (selectedLegs.length < 3) return [];

            const combinedOdds = selectedLegs.reduce((acc, leg) => acc * leg.odds, 1);
            const combinedProb = selectedLegs.reduce((acc, leg) => acc * leg.prob, 1);
            const edge = (combinedProb * combinedOdds) - 1;

            // Enhanced parlay filtering with correlation penalty
            const correlationPenalty = selectedLegs.some(leg => 
                leg.market_type.includes('corner') || leg.market_type.includes('card')
            ) ? 0.8 : 1.0; // Reduce edge if volatile markets included
            
            const adjustedEdge = edge * correlationPenalty;

            if (adjustedEdge > minEdge * 2) { // Parlays need higher edge
                const b = combinedOdds - 1;
                const p = combinedProb;
                const q = 1 - p;
                
                const kellyFraction = b > 0 ? (b * p - q) / b : 0;
                
                // Extra conservative for parlays with market-specific adjustments
                let parlayModifier = kellyModifier;
                if (selectedLegs.some(leg => leg.market_type !== 'match_result')) {
                    parlayModifier *= 0.8; // Even more conservative for non-main markets
                }
                
                const adjustedFraction = Math.max(0, Math.min(kellyFraction * parlayModifier, 0.02)); // Cap at 2%
                let stake = adjustedFraction * capital;
                
                // Enhanced parlay stake rounding
                if (stake > 50) {
                    stake = Math.round(stake / 5) * 5;
                } else if (stake > 20) {
                    stake = Math.round(stake / 2) * 2;
                } else {
                    stake = Math.round(stake);
                }
                
                if (stake >= minStake) {
                    // Enhanced confidence calculation for parlays
                    const avgConfidence = selectedLegs.reduce((sum, leg) => sum + leg.confidence, 0) / selectedLegs.length;
                    const parlayConfidence = avgConfidence * correlationPenalty * 0.8; // Parlay penalty
                    
                     return [{
                        legs: selectedLegs,
                        combinedOdds,
                        combinedProb,
                        edge: adjustedEdge,
                        stake,
                        ev: stake * adjustedEdge,
                        confidence: parlayConfidence,
                        kellyFraction: kellyFraction,
                        correlationPenalty,
                        strategy: comboStrategy
                    }];
                }
            }
            return [];
        }

        function displayPortfolio(portfolio) {
            DOM.noResults.classList.add('hidden');
            DOM.resultsContainer.classList.remove('hidden');
            DOM.portfolioSummary.classList.remove('hidden');

            displaySummary(portfolio);
            displayRecommendations(portfolio);
        }

        function displaySummary(portfolio) {
            const capital = parseFloat(document.getElementById('capital').value);
            const totalStake = portfolio.singles.reduce((sum, bet) => sum + bet.stake, 0) + portfolio.parlays.reduce((sum, bet) => sum + bet.stake, 0);
            const totalEV = portfolio.singles.reduce((sum, bet) => sum + bet.ev, 0) + portfolio.parlays.reduce((sum, bet) => sum + bet.ev, 0);
            
            // Enhanced profit calculations
            const totalPotentialWinnings = portfolio.singles.reduce((sum, bet) => sum + (bet.stake * (bet.odds - 1)), 0) + 
                                          portfolio.parlays.reduce((sum, bet) => sum + (bet.stake * (bet.combinedOdds - 1)), 0);
            const portfolioROI = totalStake > 0 ? (totalEV / totalStake) * 100 : 0;
            const utilizationRate = (totalStake / capital) * 100;
            const expectedProfitMargin = totalStake > 0 ? ((totalEV / totalStake) * 100) : 0;

            DOM.portfolioSummary.innerHTML = `
                <div class="stat-card" style="background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(30,41,59,0.9)); border: 2px solid rgba(16,185,129,0.4);">
                    <div class="stat-value" style="color: #10b981;">€${capital.toFixed(2)}</div>
                    <div class="stat-label" data-lang="totalCapital">${getText('totalCapital')}</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(30,41,59,0.9)); border: 2px solid rgba(139,92,246,0.4);">
                    <div class="stat-value" style="color: #8b5cf6;">€${totalStake.toFixed(2)}</div>
                    <div class="stat-label" data-lang="totalStake">${getText('totalStake')}</div>
                    <div style="font-size: 0.8rem; color: #94a3b8; margin-top: 0.5rem;">${utilizationRate.toFixed(1)}% ${getText('capitalUtilization')}</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(30,41,59,0.9)); border: 2px solid rgba(6,182,212,0.4);">
                    <div class="stat-value" style="color: #06b6d4;">€${(capital - totalStake).toFixed(2)}</div>
                    <div class="stat-label" data-lang="remainingCapital">${getText('remainingCapital')}</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(30,41,59,0.9)); border: 2px solid rgba(16,185,129,0.6); box-shadow: 0 10px 30px rgba(16,185,129,0.3);">
                    <div class="stat-value" style="color: #10b981; font-size: 2.8rem; font-weight: 900;">€${totalEV.toFixed(2)}</div>
                    <div class="stat-label" style="color: #10b981; font-weight: 700;">${getText('expectedProfit')}</div>
                    <div style="font-size: 0.9rem; color: #10b981; margin-top: 0.5rem; font-weight: 600;">+${expectedProfitMargin.toFixed(1)}% margin</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(30,41,59,0.9)); border: 2px solid rgba(6,182,212,0.4);">
                    <div class="stat-value" style="color: #06b6d4;">€${totalPotentialWinnings.toFixed(2)}</div>
                    <div class="stat-label">${getText('potentialWinnings')}</div>
                    <div style="font-size: 0.8rem; color: #94a3b8; margin-top: 0.5rem;">${getText('ifAllWin')}</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(30,41,59,0.9)); border: 2px solid rgba(245,158,11,0.4);">
                    <div class="stat-value" style="color: ${portfolioROI > 15 ? '#10b981' : portfolioROI > 8 ? '#f59e0b' : '#ef4444'};">${portfolioROI.toFixed(1)}%</div>
                    <div class="stat-label">${getText('expectedROI')}</div>
                </div>
            `;

            // Egyszerűsített portfólió összegzés
            const betCount = portfolio.singles.length + portfolio.parlays.length;
            const avgBetSize = betCount > 0 ? totalStake / betCount : 0;
            const singlesBetCount = portfolio.singles.length;
            const parlaysBetCount = portfolio.parlays.length;
            
            DOM.portfolioSummary.innerHTML += `
                <div class="stat-card" style="background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(30,41,59,0.9)); border: 2px solid rgba(16,185,129,0.4);">
                    <div class="stat-value" style="color: #10b981;">€${(capital + totalPotentialWinnings).toFixed(2)}</div>
                    <div class="stat-label" data-lang="potentialMaxCapital">${getText('potentialMaxCapital')}</div>
                    <div style="font-size: 0.8rem; color: #94a3b8; margin-top: 0.5rem;">${getText('potentialMaxCapitalHint')}</div>
                </div>
            `;
            
            // PROFESSIONAL LONG-TERM PROFITABILITY ANALYSIS
            const longTermAnalysis = calculateLongTermProfitability(portfolio);
            
            // Add professional portfolio insights
            DOM.portfolioSummary.innerHTML += `
                <div style="grid-column: 1 / -1; background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(6,182,212,0.1)); border: 1px solid rgba(139,92,246,0.3); border-radius: 20px; padding: 2rem; margin-top: 1rem;">
                    <h4 style="color: #8b5cf6; margin-bottom: 1rem; font-size: 1.3rem;">📊 ${getText('portfolioAnalysis')}</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                        <div><strong>${getText('totalBets')}:</strong> ${betCount} (${singlesBetCount} ${getText('singles')}, ${parlaysBetCount} ${getText('parlays')})</div>
                        <div><strong>${getText('avgBetSize')}:</strong> €${avgBetSize.toFixed(2)}</div>
                        <div><strong>${getText('expectedProfitMargin')}:</strong> <span style="color: #10b981; font-weight: bold;">${expectedProfitMargin.toFixed(1)}%</span></div>
                        <div><strong>${getText('riskCategory')}:</strong> <span style="color: ${utilizationRate > 15 ? '#ef4444' : utilizationRate > 10 ? '#f59e0b' : '#10b981'};">${getText(utilizationRate > 15 ? 'riskHigh' : utilizationRate > 10 ? 'riskMedium' : 'riskLow')}</span></div>
                    </div>
                    ${longTermAnalysis ? `
                        <div style="margin-top: 1.5rem; padding: 1rem; background: rgba(16,185,129,0.1); border: 1px solid rgba(16,185,129,0.3); border-radius: 10px;">
                            <h5 style="color: #10b981; margin-bottom: 0.75rem; font-size: 1.1rem;">🎯 Hosszútávú Nyereségességi Elemzés</h5>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                                <div><strong>Várható Nyereség:</strong> <span style="color: ${longTermAnalysis.expectedProfit > 0 ? '#10b981' : '#ef4444'};">€${longTermAnalysis.expectedProfit.toFixed(2)}</span></div>
                                <div><strong>Nyerési Arány:</strong> <span style="color: #06b6d4;">${(longTermAnalysis.winRate * 100).toFixed(1)}%</span></div>
                                <div><strong>Hosszútávú ROI:</strong> <span style="color: ${longTermAnalysis.roi > 0 ? '#10b981' : '#ef4444'};">${longTermAnalysis.roi.toFixed(1)}%</span></div>
                                <div><strong>Max Drawdown:</strong> <span style="color: #f59e0b;">€${longTermAnalysis.maxDrawdown.toFixed(2)}</span></div>
                            </div>
                            <div style="padding: 0.75rem; background: rgba(0,0,0,0.2); border-radius: 8px; text-align: center;">
                                <strong style="color: ${longTermAnalysis.profitability === 'PROFITABLE' ? '#10b981' : '#ef4444'}; font-size: 1.1rem;">
                                    ${longTermAnalysis.profitability === 'PROFITABLE' ? '✅ HOSSZÚTÁVON NYERESÉGES' : '❌ HOSSZÚTÁVON VESZTESÉGES'}
                                </strong>
                                <div style="margin-top: 0.5rem; color: #94a3b8;">
                                    Megbízhatóság: ${longTermAnalysis.confidence.toFixed(0)}%
                                </div>
                            </div>
                        </div>
                    ` : ''}
                    <div style="margin-top: 1rem; padding: 1rem; background: rgba(0,0,0,0.2); border-radius: 10px;">
                        <strong style="color: #10b981;">💡 ${getText('professionalAdvice')}:</strong> 
                        ${getText(portfolioROI > 20 ? 'excellentPortfolio' : portfolioROI > 10 ? 'goodPortfolio' : 'conservativePortfolio')}
                        ${utilizationRate > 15 ? ' ' + getText('considerReducingRisk') : ''}
                        ${longTermAnalysis && longTermAnalysis.profitability === 'PROFITABLE' ? 
                            ' A matematikai modellek alapján ez a portfólió hosszútávon nyereséges.' : 
                            longTermAnalysis ? ' Figyelem: A modellek szerint ez a portfólió hosszútávon veszteséges lehet.' : ''}
                    </div>
                </div>
            `;
        }

        // --- PROFESSIONAL MONTE CARLO SIMULATION MODULE --- //
        // REMOVED - Not needed for simpler, more practical approach

        function displayRecommendations(portfolio) {
            const container = document.getElementById('recommendations-container');
            
            // Add download summary buttons
            const downloadButtonHTML = `
                <div style="text-align: center; margin: 2rem 0; padding: 1.5rem; background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(6,182,212,0.1)); border: 1px solid rgba(139,92,246,0.3); border-radius: 20px;">
                    <h3 style="color: #8b5cf6; margin-bottom: 1rem;">📄 Letölthető Összefoglalók</h3>
                    <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="downloadPortfolioSummary()" style="display: flex; align-items: center; gap: 0.5rem;">
                            📊 <span data-lang="downloadPortfolioSummary">Portfólió Összefoglaló</span>
                        </button>
                        <button class="btn btn-secondary" onclick="downloadCalculationDetails()" style="display: flex; align-items: center; gap: 0.5rem;">
                            🧮 <span data-lang="downloadCalculationDetails">Matematikai Számítások</span>
                        </button>
                        <button class="btn btn-secondary" onclick="downloadDataSources()" style="display: flex; align-items: center; gap: 0.5rem;">
                            🔍 <span data-lang="downloadDataSources">Adatforrások & Ellenőrzés</span>
                        </button>
                    </div>
                </div>
            `;
            
            container.innerHTML = `
                ${downloadButtonHTML}
                ${generateSectionHTML('single', portfolio.singles)}
                ${generateSectionHTML('parlay', portfolio.parlays)}
            `;
            
            // Trigger MathJax to render the formulas
            setTimeout(() => {
                if (window.MathJax && window.MathJax.typesetPromise) {
                    MathJax.typesetPromise([container]).then(() => {
                        console.log('MathJax recommendations rendered successfully');
                    }).catch((e) => console.error('MathJax error:', e));
                }
            }, 100);
        }

        function generateSectionHTML(type, bets) {
            if (!bets || bets.length === 0) return '';
            
            const title = type === 'single' ? getText('singleRecommendations') : getText('parlayRecommendations');
            const icon = type === 'single' ? '🎯' : '🔗';

            const cardsHTML = bets.map(bet => type === 'single' ? generateSingleCardHTML(bet) : generateParlayCardHTML(bet)).join('');

            return `
                <div class="recommendation-section">
                    <h3 class="section-title">${icon} ${title}</h3>
                    <div class="recommendation-grid">
                        ${cardsHTML}
                    </div>
                </div>
            `;
        }

        function generateSingleCardHTML(bet) {
            const { sport, home_team, away_team, market_type, market_specifier, selection, odds, prob, edge, stake, ev } = bet;
            const sportConfig = SportConfigs[sport] || SportConfigs.unknown;
            const capital = parseFloat(document.getElementById('capital').value);

            const prettyMarketType = market_type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            const marketDisplay = `${prettyMarketType} ${market_specifier || ''}`.trim();
            
            // Accurate profit calculations
            const netOdds = odds - 1; // b in Kelly formula
            const grossWinnings = stake * odds; // Total return if win
            const netProfit = stake * netOdds; // Pure profit if win
            const impliedProb = 1 / odds; // Bookmaker's implied probability
            const roi = ((ev / stake) * 100);
            
            // PhD-level metrics
            const kellyPercentage = (bet.kellyFraction * 100).toFixed(2);
            const adjustedKellyPercentage = (bet.adjustedFraction * 100).toFixed(2);
            
            // Confidence level based on edge and probability
            let confidenceLevel = 'low';
            let confidenceColor = '#ef4444';
            if (edge > 0.15 && prob > 0.6) {
                confidenceLevel = 'high';
                confidenceColor = '#10b981';
            } else if (edge > 0.08 && prob > 0.45) {
                confidenceLevel = 'medium';
                confidenceColor = '#f59e0b';
            }

            return `
                <div class="recommendation-card single">
                    <div class="rec-header">
                        <div class="bet-confidence confidence-${confidenceLevel}" style="background: ${confidenceColor}; padding: 0.5rem 1rem; border-radius: 20px; font-weight: 700;">
                            ${getText('confidence')}: ${confidenceLevel.toUpperCase()} (${(prob * 100).toFixed(1)}%)
                    </div>
                    </div>
                    
                    <!-- MATCH INFORMATION -->
                    <div style="background: linear-gradient(135deg, rgba(6,182,212,0.15), rgba(6,182,212,0.05)); border: 1px solid rgba(6,182,212,0.3); border-radius: 15px; padding: 1.2rem; margin-bottom: 1rem;">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span style="font-size: 2rem;">${sportConfig.icon}</span>
                    <div>
                                <div style="color: #06b6d4; font-weight: 600; font-size: 0.9rem; margin-bottom: 0.3rem;">${getText('matchInfo')}</div>
                                <div style="font-size: 1.2rem; font-weight: 700; color: #e2e8f0;">${home_team} ${getText('vs')} ${away_team}</div>
                    </div>
                        </div>
                    </div>
                    
                    <!-- BETTING DETAILS -->
                    <div style="background: linear-gradient(135deg, rgba(139,92,246,0.15), rgba(139,92,246,0.05)); border: 1px solid rgba(139,92,246,0.3); border-radius: 15px; padding: 1.2rem; margin-bottom: 1rem;">
                        <div style="margin-bottom: 0.8rem;">
                            <span style="color: #8b5cf6; font-weight: 600;">${getText('betType')}:</span>
                            <span style="color: #e2e8f0; margin-left: 0.5rem;">${marketDisplay}</span>
                        </div>
                        <div>
                            <span style="color: #8b5cf6; font-weight: 600;">${getText('selection')}:</span>
                            <span style="font-size: 1.2rem; font-weight: 700; color: #10b981; margin-left: 0.5rem;">${selection}</span>
                        </div>
                    </div>
                    
                    <!-- STAKE DISPLAY (PROMINENT) -->
                    <div class="stake-display" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(139, 92, 246, 0.1)); border: 2px solid rgba(139, 92, 246, 0.5); border-radius: 15px; padding: 1.5rem; margin: 1rem 0; text-align: center; position: relative; overflow: hidden;">
                        <div style="color: #8b5cf6; font-weight: 600; margin-bottom: 0.5rem;">💎 ${getText('recommendedStake')}</div>
                        <div class="stake-amount" style="font-size: 3rem; font-weight: 900; color: #8b5cf6; text-shadow: 0 0 20px rgba(139, 92, 246, 0.5); position: relative;">€${stake}</div>
                        <div class="math-formula">
                            Kelly: ${(bet.kellyFraction * 100).toFixed(2)}% × €${capital.toFixed(0)} = €${stake}
                        </div>
                    </div>
                    
                    <!-- PROFIT DISPLAY (SECONDARY) -->
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.05)); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 12px; padding: 1rem; margin: 1rem 0; text-align: center;">
                        <div style="color: #059669; font-weight: 600; margin-bottom: 0.5rem;">💰 ${getText('profitIfWin')}</div>
                        <div style="font-size: 1.8rem; font-weight: 700; color: #10b981;">€${netProfit.toFixed(0)}</div>
                        <div class="math-formula">
                            €${stake} × (${odds} - 1) = €${stake} × ${netOdds.toFixed(2)} = €${netProfit.toFixed(0)}
                        </div>
                    </div>
                    
                    <!-- DETAILED METRICS -->
                    <div style="margin-top: 1.5rem;">
                        <h4 style="color: #8b5cf6; margin-bottom: 1rem; font-size: 1.1rem;">📊 ${getText('detailedAnalysis')}</h4>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('tipOdds')} (Decimal)</span>
                            <span class="bet-metric-value" style="color: #06b6d4;">${odds.toFixed(2)}</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('ourProbability')}</span>
                            <span class="bet-metric-value" style="color: #10b981;">${(prob * 100).toFixed(1)}%</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('impliedProbability')}</span>
                            <span class="bet-metric-value" style="color: #f59e0b;">${(impliedProb * 100).toFixed(1)}%</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('valueEdge')}</span>
                            <span class="bet-metric-value" style="color: ${edge > 0.1 ? '#10b981' : '#f59e0b'};">${(edge * 100).toFixed(2)}%</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('recommendedStake')}</span>
                            <span class="bet-metric-value" style="color: #8b5cf6;">€${stake}</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('grossReturn')}</span>
                            <span class="bet-metric-value">€${grossWinnings.toFixed(0)}</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('expectedValue')} (EV)</span>
                            <span class="bet-metric-value" style="color: #6366f1;">${(ev/stake * 100).toFixed(2)}%</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('expectedROI')}</span>
                            <span class="bet-metric-value" style="color: ${roi > 15 ? '#10b981' : roi > 8 ? '#f59e0b' : '#ef4444'};">${roi.toFixed(1)}%</span>
                        </div>
                    </div>
                    
                    <!-- MATHEMATICAL FOUNDATION -->
                    <div style="margin-top: 1.5rem; padding: 1rem; background: rgba(99, 102, 241, 0.05); border-radius: 12px; border: 1px solid rgba(99, 102, 241, 0.2);">
                        <h5 style="color: #a5b4fc; margin-bottom: 0.75rem; font-size: 0.9rem;">🔬 ${getText('mathematicalFoundation')}</h5>
                                                    <div style="font-size: 0.85rem; color: #c7d2fe; line-height: 1.6;">
                            <div>Kelly %: ${kellyPercentage}% → Kiigazított: ${adjustedKellyPercentage}%</div>
                            <div>Képlet: \\(f^* = \\frac{p \\times (o-1) - (1-p)}{o-1} = \\frac{${prob.toFixed(3)} \\times ${netOdds.toFixed(2)} - ${(1-prob).toFixed(3)}}{${netOdds.toFixed(2)}}\\)</div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function generateParlayCardHTML(parlay) {
            const { legs, combinedOdds, combinedProb, edge, stake, ev } = parlay;
            const capital = parseFloat(document.getElementById('capital').value);

            // Accurate parlay profit calculations
            const netOdds = combinedOdds - 1;
            const grossWinnings = stake * combinedOdds;
            const netProfit = stake * netOdds;
            const impliedProb = 1 / combinedOdds;
            const roi = ((ev / stake) * 100);
            
            // Parlay confidence level (more conservative)
            let confidenceLevel = 'low';
            let confidenceColor = '#ef4444';
            if (edge > 0.25 && combinedProb > 0.3) {
                confidenceLevel = 'high';
                confidenceColor = '#10b981';
            } else if (edge > 0.15 && combinedProb > 0.2) {
                confidenceLevel = 'medium';
                confidenceColor = '#f59e0b';
            }

            const legsHTML = legs.map((leg, index) => {
                const { home_team, away_team, market_type, market_specifier, selection, odds, prob } = leg;
                const sportConfig = SportConfigs[leg.sport] || SportConfigs.unknown;
                const prettyMarket = market_type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                const marketDisplay = `${prettyMarket} ${market_specifier || ''}`.trim();
                return `
                    <div class="rec-parlay-leg" style="border-left: 3px solid ${index % 2 === 0 ? '#8b5cf6' : '#06b6d4'}; margin-bottom: 0.75rem;">
                        <div style="background: linear-gradient(135deg, rgba(6,182,212,0.1), rgba(6,182,212,0.05)); border-radius: 10px; padding: 0.75rem; margin-bottom: 0.5rem;">
                            <div style="display: flex; align-items: center; gap: 0.75rem;">
                                <span style="font-size: 1.5rem;">${sportConfig.icon}</span>
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; color: #06b6d4; font-size: 0.95rem;">
                                        ${home_team} ${getText('vs')} ${away_team}
                                    </div>
                                    <div style="color: #94a3b8; font-size: 0.85rem; margin-top: 0.25rem;">
                                        ${marketDisplay}: <strong style="color: #10b981;">${selection}</strong>
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="color: #06b6d4; font-weight: 700;">@ ${odds.toFixed(2)}</div>
                                    <div style="color: #f59e0b; font-size: 0.85rem;">${(prob*100).toFixed(1)}%</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            return `
                 <div class="recommendation-card parlay">
                    <div class="rec-header">
                        <div style="display: flex; align-items: center; justify-content: space-between;">
                            <span style="color: #f59e0b; font-weight: 700; font-size: 1.2rem;">
                                🔗 ${getText('parlayBet')} (${legs.length}x)
                            </span>
                            <div class="bet-confidence confidence-${confidenceLevel}" style="background: ${confidenceColor}; padding: 0.5rem 1rem; border-radius: 20px; font-weight: 700;">
                                ${getText('confidence')}: ${confidenceLevel.toUpperCase()} (${(combinedProb * 100).toFixed(1)}%)
                    </div>
                        </div>
                    </div>
                    
                    <!-- PARLAY LEGS -->
                    <div style="margin: 1.5rem 0;">
                       ${legsHTML}
                    </div>
                    
                    <!-- STAKE DISPLAY (PROMINENT) -->
                    <div class="stake-display" style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(245, 158, 11, 0.1)); border: 2px solid rgba(245, 158, 11, 0.5); border-radius: 15px; padding: 1.5rem; margin: 1rem 0; text-align: center; position: relative; overflow: hidden;">
                        <div style="color: #f59e0b; font-weight: 600; margin-bottom: 0.5rem;">💎 ${getText('recommendedStake')}</div>
                        <div class="stake-amount" style="font-size: 3rem; font-weight: 900; color: #f59e0b; text-shadow: 0 0 20px rgba(245, 158, 11, 0.5); position: relative;">€${stake}</div>
                        <div class="math-formula">
                            Kombi Kelly: ${(parlay.kellyFraction * 100).toFixed(2)}% × €${capital.toFixed(0)} = €${stake}
                        </div>
                    </div>
                    
                    <!-- PROFIT DISPLAY (SECONDARY) -->
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.05)); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 12px; padding: 1rem; margin: 1rem 0; text-align: center;">
                        <div style="color: #059669; font-weight: 600; margin-bottom: 0.5rem;">💰 ${getText('profitIfWin')}</div>
                        <div style="font-size: 1.8rem; font-weight: 700; color: #10b981;">€${netProfit.toFixed(0)}</div>
                        <div class="math-formula">
                            €${stake} × (${combinedOdds.toFixed(2)} - 1) = €${stake} × ${netOdds.toFixed(2)} = €${netProfit.toFixed(0)}
                        </div>
                    </div>
                    
                    <!-- DETAILED METRICS -->
                    <div style="margin-top: 1.5rem;">
                        <h4 style="color: #f59e0b; margin-bottom: 1rem; font-size: 1.1rem;">📊 ${getText('detailedAnalysis')}</h4>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('tipOdds')} (Combined)</span>
                            <span class="bet-metric-value" style="color: #06b6d4;">${combinedOdds.toFixed(2)}</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('ourProbability')}</span>
                            <span class="bet-metric-value" style="color: #10b981;">${(combinedProb * 100).toFixed(1)}%</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('impliedProbability')}</span>
                            <span class="bet-metric-value" style="color: #f59e0b;">${(impliedProb * 100).toFixed(1)}%</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('valueEdge')}</span>
                            <span class="bet-metric-value" style="color: ${edge > 0.2 ? '#10b981' : '#f59e0b'};">${(edge * 100).toFixed(2)}%</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('recommendedStake')}</span>
                            <span class="bet-metric-value" style="color: #8b5cf6;">€${stake}</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('grossReturn')}</span>
                            <span class="bet-metric-value">€${grossWinnings.toFixed(0)}</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('expectedValue')} (EV)</span>
                            <span class="bet-metric-value" style="color: #6366f1;">${(ev/stake * 100).toFixed(2)}%</span>
                        </div>
                        
                        <div class="bet-metric">
                            <span class="bet-metric-label">${getText('expectedROI')}</span>
                            <span class="bet-metric-value" style="color: ${roi > 20 ? '#10b981' : roi > 10 ? '#f59e0b' : '#ef4444'};">${roi.toFixed(1)}%</span>
                        </div>
                    </div>
                    
                    <!-- MATHEMATICAL FOUNDATION -->
                    <div style="margin-top: 1.5rem; padding: 1rem; background: rgba(245, 158, 11, 0.05); border-radius: 12px; border: 1px solid rgba(245, 158, 11, 0.2);">
                        <h5 style="color: #fbbf24; margin-bottom: 0.75rem; font-size: 0.9rem;">🔬 ${getText('mathematicalFoundation')}</h5>
                        <div style="font-size: 0.85rem; color: #fde68a; line-height: 1.6;">
                            <div>Kombinált Valószínűség: \\(P = \\prod_{i=1}^{${legs.length}} p_i = ${legs.map(l => l.prob.toFixed(3)).join(' \\times ')} = ${combinedProb.toFixed(4)}\\)</div>
                            <div>Kombinált Szorzók: \\(O = \\prod_{i=1}^{${legs.length}} o_i = ${legs.map(l => l.odds.toFixed(2)).join(' \\times ')} = ${combinedOdds.toFixed(2)}\\)</div>
                        </div>
                    </div>
                </div>
            `;
        }

        function calculateMath() {
            try {
                const prob = parseFloat(document.getElementById('calcProb').value) / 100;
                const odds = parseFloat(document.getElementById('calcOdds').value);
                const capital = parseFloat(document.getElementById('calcCapital').value);
                const kellyMod = parseFloat(document.getElementById('calcKellyMod').value);
                
                // Validate inputs
                if (isNaN(prob) || isNaN(odds) || isNaN(capital) || isNaN(kellyMod)) {
                    showLocalizedNotification('fillFields', 'error');
                    return;
                }
                
                if (prob <= 0 || prob >= 1) {
                    showLocalizedNotification('invalidProbability', 'error');
                    return;
                }
                
                if (odds <= 1) {
                    showLocalizedNotification('invalidOdds', 'error');
                    return;
                }
                
                if (capital <= 0) {
                    showLocalizedNotification('invalidCapital', 'error');
                    return;
                }
                
                if (kellyMod <= 0 || kellyMod > 1) {
                    showLocalizedNotification('invalidKellyModifier', 'error');
                    return;
                }
                
                // Edge calculation
                const edge = (prob * odds) - 1;
                
                // Kelly calculation - simplified
                const b = odds - 1; // Net odds
                const q = 1 - prob;
                const kellyFraction = b > 0 ? (b * prob - q) / b : 0;
                const kellyPercent = Math.max(0, kellyFraction * kellyMod * 100);
                
                // Stake calculation with realistic rounding
                const rawStake = Math.max(0, kellyFraction * kellyMod * capital);
                const maxStake = capital * 0.05; // Never risk more than 5%
                const minStake = capital * 0.005; // Minimum 0.5%
                let stake = Math.min(rawStake, maxStake);
                
                // Round to realistic amounts
                if (stake > 100) {
                    stake = Math.round(stake / 10) * 10;
                } else if (stake > 50) {
                    stake = Math.round(stake / 5) * 5;
                } else if (stake > 20) {
                    stake = Math.round(stake / 2) * 2;
                } else {
                    stake = Math.round(stake);
                }
                
                // Check minimum stake
                if (stake < minStake && edge > 0) {
                    stake = 0; // Don't bet if below minimum
                }
                
                // Expected value
                const expectedValue = stake * edge;
                
                // Potential winnings
                const potentialWinnings = stake * b;
                
                // ROI
                const roi = stake > 0 ? (expectedValue / stake) * 100 : 0;
                
                // Display results
                if (document.getElementById('calcEdge')) {
                document.getElementById('calcEdge').textContent = `${(edge * 100).toFixed(2)}%`;
                }
                if (document.getElementById('calcKelly')) {
                document.getElementById('calcKelly').textContent = `${kellyPercent.toFixed(2)}%`;
                }
                if (document.getElementById('calcStake')) {
                    document.getElementById('calcStake').textContent = `€${stake.toFixed(0)}`;
                }
                if (document.getElementById('calcEV')) {
                document.getElementById('calcEV').textContent = `${(expectedValue/stake * 100).toFixed(2)}%`;
                }
                if (document.getElementById('calcWinnings')) {
                    document.getElementById('calcWinnings').textContent = `€${potentialWinnings.toFixed(0)}`;
                }
                if (document.getElementById('calcROI')) {
                    document.getElementById('calcROI').textContent = `${roi.toFixed(1)}%`;
                }
                
                if (document.getElementById('calcResults')) {
                document.getElementById('calcResults').style.display = 'block';
                    
                    // Trigger MathJax to render any formulas
                    if (window.MathJax) {
                        MathJax.typesetPromise().catch((e) => console.log('MathJax error:', e));
                    }
                }
                
                // Color coding based on edge
                const edgeElement = document.getElementById('calcEdge');
                if (edgeElement) {
                if (edge > 0.1) {
                    edgeElement.style.color = '#10b981'; // Green for high edge
                } else if (edge > 0.05) {
                    edgeElement.style.color = '#f59e0b'; // Yellow for medium edge
                } else if (edge > 0) {
                    edgeElement.style.color = '#06b6d4'; // Blue for low edge
                } else {
                    edgeElement.style.color = '#ef4444'; // Red for negative edge
                    }
                }
                
                // Simple recommendation text
                if (stake === 0) {
                    const reason = edge <= 0 ? getText('negativeEdge') : getText('belowMinStake');
                    console.log(`No bet recommended: ${reason}`);
                } else {
                    console.log(`Recommendation: Bet €${stake} for expected profit of €${expectedValue.toFixed(2)}`);
                }
            } catch (error) {
                console.error('Error calculating math:', error);
                showLocalizedNotification('calculationError', 'error');
            }
        }

        // --- INPUT MODE MANAGEMENT --- //
        function initializeInputModes() {
            // Initialize with image mode
            switchInputMode('image');
            
            // Initialize auto data search checkbox state
            const autoDataSearchCheckbox = document.getElementById('enableAutoDataSearch');
            const postAnalysisSearchCheckbox = document.getElementById('enablePostAnalysisSearch');
            autoDataSearchCheckbox.disabled = true;
            autoDataSearchCheckbox.parentElement.style.opacity = '0.5';
            postAnalysisSearchCheckbox.disabled = true;
            postAnalysisSearchCheckbox.parentElement.style.opacity = '0.5';
            
            // Add event listeners for AI model selection
            document.getElementById('aiModel').addEventListener('change', function() {
                const aiApiKeyGroup = document.getElementById('aiApiKeyGroup');
                const autoDataSearchCheckbox = document.getElementById('enableAutoDataSearch');
                const postAnalysisSearchCheckbox = document.getElementById('enablePostAnalysisSearch');
                
                if (this.value !== 'none') {
                    aiApiKeyGroup.style.display = 'block';
                    
                    // Enable auto data search only for Perplexity
                    if (this.value === 'perplexity') {
                        autoDataSearchCheckbox.disabled = false;
                        autoDataSearchCheckbox.parentElement.style.opacity = '1';
                        postAnalysisSearchCheckbox.disabled = false;
                        postAnalysisSearchCheckbox.parentElement.style.opacity = '1';
                    } else {
                        autoDataSearchCheckbox.disabled = true;
                        autoDataSearchCheckbox.checked = false;
                        autoDataSearchCheckbox.parentElement.style.opacity = '0.5';
                        postAnalysisSearchCheckbox.disabled = true;
                        postAnalysisSearchCheckbox.checked = false;
                        postAnalysisSearchCheckbox.parentElement.style.opacity = '0.5';
                    }
                } else {
                    aiApiKeyGroup.style.display = 'none';
                    autoDataSearchCheckbox.disabled = true;
                    autoDataSearchCheckbox.checked = false;
                    autoDataSearchCheckbox.parentElement.style.opacity = '0.5';
                    postAnalysisSearchCheckbox.disabled = true;
                    postAnalysisSearchCheckbox.checked = false;
                    postAnalysisSearchCheckbox.parentElement.style.opacity = '0.5';
                }
            });
        }
        
        function switchInputMode(mode) {
            const imageMode = document.getElementById('imageInputMode');
            const textMode = document.getElementById('textInputMode');
            const imageBtn = document.getElementById('imageInputBtn');
            const textBtn = document.getElementById('textInputBtn');
            
            if (mode === 'image') {
                imageMode.style.display = 'block';
                textMode.style.display = 'none';
                imageBtn.classList.remove('btn-secondary');
                imageBtn.classList.add('btn-primary');
                textBtn.classList.remove('btn-primary');
                textBtn.classList.add('btn-secondary');
            } else {
                imageMode.style.display = 'none';
                textMode.style.display = 'block';
                textBtn.classList.remove('btn-secondary');
                textBtn.classList.add('btn-primary');
                imageBtn.classList.remove('btn-primary');
                imageBtn.classList.add('btn-secondary');
            }
        }
        
        async function processBettingText() {
            const textInput = document.getElementById('bettingTextInput').value.trim();
            if (!textInput) {
                showLocalizedNotification('notificationEmptyTextInput', 'warning');
                return;
            }
            
            if (!AppState.apiConnected) {
                showLocalizedNotification('notificationSetupApiFirst', 'warning');
                UIManager.switchTab('setup');
                return;
            }
            
            showLocalizedLoading('loadingTextAnalysis', 'loadingExtractingBettingData');
            
            try {
                // Create a structured prompt for text analysis
                const prompt = `Analyze the following betting information and extract all relevant data in JSON format. 
                
TEXT TO ANALYZE:
${textInput}

Please extract and return in this JSON format:
{
  "extracted_data": {
    "sport_type": "football|tennis|basketball|hockey|baseball|americanfootball|other",
    "matches_detected": [
      { "home_team": "Team/Player name", "away_team": "Team/Player name", "league": "League name or null", "date": "Date if mentioned", "additional_info": "Any extra context" }
    ],
    "odds_found": [
      { "market_type": "match_result|total_goals_over_under|total_points_over_under|corners|cards|handicap", "market_specifier": "2.5|null", "values": { "Home": 1.90, "Draw": 3.20, "Away": 4.10 }, "applies_to_match_index": 0 }
    ],
    "additional_context": {
      "weather_conditions": "Description if mentioned",
      "player_injuries": ["Player names if mentioned"],
      "team_news": "Any team news or tactical information",
      "betting_tips": "Any analysis or reasoning provided"
    }
  }
}

Be thorough and extract all betting markets, odds, and contextual information.`;
                
                // Send to OpenAI API
                const response = await fetch(CONSTANTS.API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${AppState.apiKey}` },
                    body: JSON.stringify({
                        model: CONSTANTS.API_MODEL,
                        messages: [{ role: 'user', content: prompt }],
                        response_format: { type: "json_object" }
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                const extractedData = JSON.parse(data.choices[0].message.content);
                
                // Convert extracted data to image-like format for compatibility
                const syntheticImage = {
                    id: Date.now(),
                    name: `Text_Input_${Date.now()}`,
                    size: textInput.length,
                    sport: extractedData.extracted_data.sport_type || 'unknown',
                    status: 'completed',
                    analysisResult: {
                        sport_type: extractedData.extracted_data.sport_type,
                        matches_detected: extractedData.extracted_data.matches_detected || [],
                        odds_found: extractedData.extracted_data.odds_found || [],
                        additional_context: extractedData.extracted_data.additional_context || {}
                    },
                    error: null,
                    dataUrl: null, // No image data for text input
                    isTextInput: true
                };
                
                AppState.uploadedImages.push(syntheticImage);
                UIManager.displayUploadedImages();
                UIManager.updateActionButtons();
                
                showLocalizedNotification('notificationTextProcessed', 'success');
                
                // Clear text input
                document.getElementById('bettingTextInput').value = '';
                
                // Automatically process if this is the first data
                if (AppState.uploadedImages.length === 1) {
                    setTimeout(() => {
                        processAndDisplayAnalysisResults();
                        UIManager.switchTab('analysis');
                    }, 1000);
                }
                
            } catch (error) {
                console.error('Error processing text:', error);
                showLocalizedNotification('notificationTextProcessingError', 'error', { error: error.message });
            } finally {
                UIManager.hideLoading();
            }
        }

        // --- ADVANCED MATHEMATICAL ADJUSTMENTS --- //
        // Enhanced multilingual keyword recognition system
        const KeywordMatcher = {
            // Weather-related keywords (Hungarian and English)
            weather: {
                temperature: ['hőmérséklet', 'temperature', 'temp', 'celsius', 'fahrenheit', 'fok', 'degree'],
                wind: ['szél', 'wind', 'szélsebesség', 'wind_speed', 'windspeed', 'szélirány', 'wind_direction'],
                rain: ['eső', 'rain', 'precipitation', 'csapadék', 'esély', 'probability', 'valószínűség'],
                humidity: ['páratartalom', 'humidity', 'nedvesség', 'moisture'],
                conditions: ['körülmények', 'conditions', 'időjárás', 'weather', 'feltételek']
            },
            
            // Player-related keywords
            players: {
                missing: ['hiányzó', 'missing', 'absent', 'unavailable', 'sérült', 'injured', 'eltiltott', 'suspended'],
                injury: ['sérülés', 'injury', 'hurt', 'strain', 'sprain', 'tear', 'contusion', 'inflammation'],
                suspension: ['eltiltás', 'suspension', 'banned', 'card', 'lap', 'yellow', 'red', 'sárga', 'piros'],
                key_player: ['kulcsjátékos', 'key_player', 'star', 'important', 'crucial', 'essential', 'main']
            },
            
            // Motivation keywords
            motivation: {
                high: ['magas', 'high', 'strong', 'erős', 'motivated', 'motivált', 'determined'],
                league_position: ['liga', 'league', 'position', 'pozíció', 'helyezés', 'standing', 'rank'],
                playoff: ['playoff', 'rájátszás', 'elimination', 'kiesés', 'qualification', 'kvalifikáció']
            },
            
            // Numerical extractors
            extractNumber: function(text, keywords) {
                if (!text) return null;
                const textLower = text.toString().toLowerCase();
                
                // Look for numbers near keywords
                for (const keyword of keywords) {
                    const regex = new RegExp(`(${keyword})[^\\d]*([\\d\\.\\,]+)`, 'i');
                    const match = textLower.match(regex);
                    if (match) {
                        return parseFloat(match[2].replace(',', '.'));
                    }
                    
                    // Reverse pattern: number before keyword
                    const reverseRegex = new RegExp(`([\\d\\.\\,]+)[^\\d]*${keyword}`, 'i');
                    const reverseMatch = textLower.match(reverseRegex);
                    if (reverseMatch) {
                        return parseFloat(reverseMatch[1].replace(',', '.'));
                    }
                }
                
                // Fallback: direct number extraction if it's already a number
                const num = parseFloat(text);
                return isNaN(num) ? null : num;
            },
            
            // Impact scale converter (handles text to 1-100 scale)
            convertImpactScale: function(value) {
                if (typeof value === 'number') return Math.max(1, Math.min(100, value));
                if (!value) return 50; // Default neutral
                
                const textLower = value.toString().toLowerCase();
                
                // Severity keywords (Hungarian and English)
                if (textLower.match(/(súlyos|severe|serious|critical|kritikus|nagy)/)) return 20;
                if (textLower.match(/(közepes|moderate|medium|átlagos)/)) return 50;
                if (textLower.match(/(enyhe|mild|light|kis|minor)/)) return 75;
                if (textLower.match(/(minimális|minimal|negligible|elhanyagolható)/)) return 90;
                
                // Try to extract percentage
                const percentMatch = textLower.match(/(\d+)%/);
                if (percentMatch) return parseInt(percentMatch[1]);
                
                // Try to extract direct number
                const numberMatch = textLower.match(/(\d+)/);
                if (numberMatch) {
                    const num = parseInt(numberMatch[1]);
                    return num > 100 ? 50 : num; // Cap at 100, default to 50 if too high
                }
                
                return 50; // Default neutral if no match
            },
            
            // Boolean converter for yes/no, true/false in multiple languages
            convertBoolean: function(value) {
                if (typeof value === 'boolean') return value;
                if (!value) return false;
                
                const textLower = value.toString().toLowerCase();
                const trueWords = ['true', 'yes', 'igen', 'igaz', 'van', 'magas', 'high', '1'];
                const falseWords = ['false', 'no', 'nem', 'hamis', 'nincs', 'alacsony', 'low', '0'];
                
                if (trueWords.some(word => textLower.includes(word))) return true;
                if (falseWords.some(word => textLower.includes(word))) return false;
                
                return false; // Default to false if unclear
            }
        };

        function applyAdvancedAdjustments(baseProb, matchAnalysis, marketType) {
            if (!baseProb || baseProb <= 0) return baseProb;
            
            let adjustedProb = baseProb;
            
            // Enhanced weather adjustments with multilingual support
            if (matchAnalysis.weather_conditions || matchAnalysis.weather_analysis) {
                adjustedProb = applyEnhancedWeatherAnalysis(adjustedProb, matchAnalysis, marketType);
            }
            
            // Venue conditions for indoor sports (no weather impact)
            if (matchAnalysis.venue_conditions) {
                adjustedProb = applyEnhancedVenueAnalysis(adjustedProb, matchAnalysis.venue_conditions, marketType);
            }
            
            // Enhanced missing players analysis with multilingual support
            if (matchAnalysis.missing_players_analysis || matchAnalysis.team_a_missing || matchAnalysis.team_b_missing) {
                adjustedProb = applyEnhancedMissingPlayersAnalysis(adjustedProb, matchAnalysis, marketType);
            }
            
            // Enhanced motivation analysis
            if (matchAnalysis.motivation_analysis) {
                adjustedProb = applyEnhancedMotivationAnalysis(adjustedProb, matchAnalysis.motivation_analysis, marketType);
            }
            
            // Tennis-specific analysis (surface, injuries, venue)
            if (matchAnalysis.tennis_analysis) {
                adjustedProb = applyEnhancedTennisAnalysis(adjustedProb, matchAnalysis.tennis_analysis, marketType);
            }
            
            // Tactical/formation adjustments
            if (matchAnalysis.tactical_analysis) {
                adjustedProb = applyTacticalAdjustments(adjustedProb, matchAnalysis.tactical_analysis, marketType);
            }
            
            // Ensure probability remains within bounds [0.01, 0.99]
            return Math.max(0.01, Math.min(0.99, adjustedProb));
        }
        
        // Enhanced weather analysis with multilingual support
        function applyEnhancedWeatherAnalysis(prob, matchAnalysis, marketType) {
            let adjustment = 1.0;
            
            // Combine weather_conditions and weather_analysis
            const weatherData = matchAnalysis.weather_analysis || matchAnalysis.weather_conditions || {};
            
            // Extract temperature with multilingual support
            const temperature = KeywordMatcher.extractNumber(
                weatherData.temperature || weatherData.hőmérséklet || weatherData.temp,
                KeywordMatcher.weather.temperature
            );
            
            // Extract wind speed
            const windSpeed = KeywordMatcher.extractNumber(
                weatherData.wind_speed || weatherData.szélsebesség || weatherData.wind,
                KeywordMatcher.weather.wind
            );
            
            // Extract precipitation probability
            const rainProb = KeywordMatcher.extractNumber(
                weatherData.precipitation_probability || weatherData.eső_valószínűség || weatherData.rain || weatherData.esély,
                KeywordMatcher.weather.rain
            );
            
            // Extract humidity
            const humidity = KeywordMatcher.extractNumber(
                weatherData.humidity || weatherData.páratartalom,
                KeywordMatcher.weather.humidity
            );
            
            // Weather impact scales (1-100 system)
            const teamAImpact = KeywordMatcher.convertImpactScale(
                weatherData.team_a_weather_impact || weatherData.player_a_weather_impact || 50
            );
            const teamBImpact = KeywordMatcher.convertImpactScale(
                weatherData.team_b_weather_impact || weatherData.player_b_weather_impact || 50
            );
            
            // Apply weather effects only for outdoor sports
            const venueType = matchAnalysis.venue_type || matchAnalysis.venue_conditions?.venue_type || 'outdoor';
            if (venueType.toLowerCase() === 'indoor') {
                return prob; // No weather impact for indoor sports
            }
            
            // Temperature effects (optimal around 20°C)
            if (temperature !== null) {
                const tempDeviation = Math.abs(temperature - 20) / 10;
                const tempEffect = Math.min(tempDeviation * 0.03, 0.08); // Max 8% adjustment
                adjustment *= (1 - tempEffect);
            }
            
            // Wind effects (affects aerial play)
            if (windSpeed !== null && windSpeed > 5) {
                const windEffect = Math.min(windSpeed / 20, 0.12); // Max 12% adjustment
                if (marketType === 'corners' || marketType.includes('corner')) {
                    adjustment *= (1 + windEffect); // More corners in windy conditions
                } else if (marketType.includes('goals') || marketType.includes('total')) {
                    adjustment *= (1 - windEffect * 0.5); // Slightly fewer goals
                }
            }
            
            // Rain effects (affects ball control)
            if (rainProb !== null && rainProb > 30) {
                const rainEffect = Math.min(rainProb / 200, 0.1); // Max 10% adjustment
                if (marketType === 'cards' || marketType.includes('card')) {
                    adjustment *= (1 + rainEffect); // More fouls in wet conditions
                } else if (marketType.includes('total')) {
                    adjustment *= (1 - rainEffect); // Lower scoring in rain
                }
            }
            
            // Team-specific weather impact (1-100 scale)
            const avgWeatherImpact = (teamAImpact + teamBImpact) / 2;
            const weatherMultiplier = 1 + Math.max(-0.15, Math.min(0.15, (avgWeatherImpact - 50) / 100 * 0.3));
            adjustment *= weatherMultiplier;
            
            return prob * adjustment;
        }
        
        function applyWeatherAdjustments(prob, weatherData, marketType) {
            if (!weatherData || typeof weatherData !== 'object') return prob;
            
            let adjustment = 1.0;
            
            // Wind effect (primarily affects aerial play and passing accuracy)
            if (weatherData.wind_speed) {
                const windEffect = Math.min(weatherData.wind_speed / 10, 0.15); // Max 15% adjustment
                if (marketType === 'corners') {
                    adjustment *= (1 + windEffect); // More corners in windy conditions
                } else if (marketType.includes('goals') || marketType.includes('points')) {
                    adjustment *= (1 - windEffect * 0.5); // Slightly fewer goals
                }
            }
            
            // Rain effect (affects ball control and playing style)
            if (weatherData.precipitation) {
                const rainEffect = Math.min(weatherData.precipitation / 5, 0.1); // Max 10% adjustment
                if (marketType === 'cards') {
                    adjustment *= (1 + rainEffect); // More fouls in wet conditions
                } else if (marketType.includes('total')) {
                    adjustment *= (1 - rainEffect); // Lower scoring in rain
                }
            }
            
            // Temperature effect (affects player performance and ball physics)
            if (weatherData.temperature) {
                const tempDeviation = Math.abs(weatherData.temperature - 20) / 10; // Optimal at 20°C
                const tempEffect = Math.min(tempDeviation * 0.05, 0.08); // Max 8% adjustment
                adjustment *= (1 - tempEffect);
            }
            
            return prob * adjustment;
        }
        
        function applyAdvancedWeatherAnalysis(prob, weatherAnalysis, marketType) {
            if (!weatherAnalysis || typeof weatherAnalysis !== 'object') return prob;
            
            let adjustment = 1.0;
            
            // Egységes 1-100 skálás időjárás hatás CSAK SZABADTÉRI SPORTOKRA (max 15% kiigazítás)
            if (weatherAnalysis.team_a_weather_impact && weatherAnalysis.team_b_weather_impact) {
                const teamAImpact = parseFloat(weatherAnalysis.team_a_weather_impact) || 50;
                const teamBImpact = parseFloat(weatherAnalysis.team_b_weather_impact) || 50;
                
                // 1-100 skála -> max 15% kiigazítás
                // 50 = semleges (0%), 1 = -15%, 100 = +15%
                const teamAMultiplier = 1 + Math.max(-0.15, Math.min(0.15, (teamAImpact - 50) / 100 * 0.3)); // Max 15%
                const teamBMultiplier = 1 + Math.max(-0.15, Math.min(0.15, (teamBImpact - 50) / 100 * 0.3)); // Max 15%
                
                // Sportspecifikus alkalmazás CSAK szabadtéri sportokra
                if (marketType === 'match_result') {
                    adjustment *= Math.sqrt(teamAMultiplier * teamBMultiplier); // Kiegyensúlyozott
                } else if (marketType === 'corners') {
                    const avgImpact = (teamAMultiplier + teamBMultiplier) / 2;
                    adjustment *= avgImpact;
                } else if (marketType === 'cards') {
                    const weatherStress = 2 - (teamAMultiplier + teamBMultiplier) / 2;
                    adjustment *= Math.min(1.15, weatherStress); // Cap at 15%
                } else if (marketType.includes('total')) {
                    const avgImpact = (teamAMultiplier + teamBMultiplier) / 2;
                    adjustment *= avgImpact;
                }
            }
            
            return prob * adjustment;
        }
        
        function applyVenueConditionsAnalysis(prob, venueConditions, marketType) {
            if (!venueConditions || typeof venueConditions !== 'object') return prob;
            
            let adjustment = 1.0;
            
            // Beltéri sportok esetén minimális venue hatás (max 2-3%)
            // Pl. arena akusztika, pálya minőség, világítás
            if (venueConditions.arena_conditions || venueConditions.court_conditions) {
                // Csak elhanyagolható hatás, mert kontrollált körülmények
                if (marketType === 'match_result') {
                    // Minimális home court advantage pici növelése
                    adjustment *= 1.01; // 1% növelés
                } else if (marketType.includes('total')) {
                    // Jó arena körülmények kissé növelhetik a teljesítményt
                    adjustment *= 1.005; // 0.5% növelés
                }
            }
            
            return prob * adjustment;
        }
        
        function applyTennisSpecificAnalysis(prob, tennisAnalysis, marketType) {
            if (!tennisAnalysis || typeof tennisAnalysis !== 'object') return prob;
            
            let adjustment = 1.0;
            
            // Pálya típus hatása (surface advantage)
            if (tennisAnalysis.surface_advantage) {
                const playerAAdvantage = parseFloat(tennisAnalysis.surface_advantage.player_a_advantage) || 50;
                const playerBAdvantage = parseFloat(tennisAnalysis.surface_advantage.player_b_advantage) || 50;
                
                // 1-100 skála -> max 20% hatás pályatípusra
                const playerAMultiplier = 1 + Math.max(-0.2, Math.min(0.2, (playerAAdvantage - 50) / 100 * 0.4)); // Max 20%
                const playerBMultiplier = 1 + Math.max(-0.2, Math.min(0.2, (playerBAdvantage - 50) / 100 * 0.4)); // Max 20%
                
                if (marketType === 'match_result') {
                    adjustment *= Math.sqrt(playerAMultiplier * playerBMultiplier); // Kiegyensúlyozott
                }
            }
            
            // Friss sérülések hatása
            if (tennisAnalysis.recent_injuries) {
                const processPlayerInjury = (injury) => {
                    if (!injury) return 1.0;
                    
                    const severity = parseFloat(injury.injury_severity) || 50;
                    const recoveryPercent = parseFloat(injury.recovery_status?.replace('%', '')) || 100;
                    
                    // Súlyosság: 1-100 skála (1=súlyos, 100=enyhe)
                    // Felépülés: 0-100% (100% = teljesen felépült)
                    const injuryImpact = Math.max(0, (50 - severity) / 100); // Max 50% impact
                    const recoveryFactor = recoveryPercent / 100; // 0-1 skála
                    
                    const finalImpact = injuryImpact * (1 - recoveryFactor); // Felépülés csökkenti a hatást
                    const cappedImpact = Math.max(-0.25, Math.min(0, -finalImpact)); // Max 25% negatív hatás
                    
                    return 1 + cappedImpact;
                };
                
                const playerAInjuryMultiplier = processPlayerInjury(tennisAnalysis.recent_injuries.player_a_injury);
                const playerBInjuryMultiplier = processPlayerInjury(tennisAnalysis.recent_injuries.player_b_injury);
                
                if (marketType === 'match_result') {
                    adjustment *= Math.sqrt(playerAInjuryMultiplier * playerBInjuryMultiplier);
                }
            }
            
            // Helyszín hatása (indoor vs outdoor)
            if (tennisAnalysis.venue_type === 'indoor') {
                // Beltéri tenisz: kontrollált körülmények, minimális hatás
                adjustment *= 1.01; // 1% növelés stabilitásért
            } else if (tennisAnalysis.venue_type === 'outdoor') {
                // Szabadtéri tenisz: időjárás hatás már külön kezelve
                // Itt csak a helyszín stabilitás hatása
                adjustment *= 0.98; // 2% csökkenés a változó körülményekért
            }
            
            return prob * adjustment;
        }
        
        // Enhanced missing players analysis with multilingual support
        function applyEnhancedMissingPlayersAnalysis(prob, matchAnalysis, marketType) {
            let adjustment = 1.0;
            
            // Collect all missing players from different sources
            const allMissingPlayers = [
                ...(matchAnalysis.missing_players_analysis?.team_a_missing || []),
                ...(matchAnalysis.missing_players_analysis?.team_b_missing || []),
                ...(matchAnalysis.team_a_missing || []),
                ...(matchAnalysis.team_b_missing || []),
                ...(matchAnalysis.missing_players_analysis?.player_a_issues || []),
                ...(matchAnalysis.missing_players_analysis?.player_b_issues || [])
            ];
            
            if (allMissingPlayers.length === 0) return prob;
            
            const processPlayerImpact = (player) => {
                if (!player) return 1.0;
                
                // Extract impact scale with multilingual support
                let impactScale = KeywordMatcher.convertImpactScale(
                    player.impact_scale || player.hatás || player.impact || player.severity
                );
                
                // Determine if key player with multilingual support
                const isKeyPlayer = KeywordMatcher.convertBoolean(
                    player.is_key_player || player.kulcsjátékos || player.key || player.important
                );
                
                // Extract injury/suspension type
                const injuryType = (player.injury_type || player.sérülés_típus || player.type || '').toLowerCase();
                const isInjury = KeywordMatcher.players.injury.some(keyword => 
                    injuryType.includes(keyword.toLowerCase())
                );
                const isSuspension = KeywordMatcher.players.suspension.some(keyword => 
                    injuryType.includes(keyword.toLowerCase())
                );
                
                // Adjust impact based on player importance and type
                let maxImpact = isKeyPlayer ? 0.30 : 0.15; // Key players: max 30%, others: max 15%
                
                // Suspension typically has immediate full impact
                if (isSuspension) {
                    maxImpact = isKeyPlayer ? 0.35 : 0.20;
                }
                
                // Convert 1-100 scale to impact percentage
                // Lower numbers = worse impact (inverted scale)
                const rawImpact = (100 - impactScale) / 100; // 20 becomes 0.80 (80% negative impact)
                const cappedImpact = Math.max(-maxImpact, Math.min(0, -rawImpact * maxImpact));
                
                return 1 + cappedImpact; // 1 - 0.30 = 0.70 (30% weaker)
            };
            
            // Group players by team if possible
            const teamAPlayers = [
                ...(matchAnalysis.missing_players_analysis?.team_a_missing || []),
                ...(matchAnalysis.team_a_missing || [])
            ];
            const teamBPlayers = [
                ...(matchAnalysis.missing_players_analysis?.team_b_missing || []),
                ...(matchAnalysis.team_b_missing || [])
            ];
            
            // Calculate team adjustments
            let teamAAdjustment = 1.0;
            let teamBAdjustment = 1.0;
            
            teamAPlayers.forEach(player => {
                teamAAdjustment *= processPlayerImpact(player);
            });
            
            teamBPlayers.forEach(player => {
                teamBAdjustment *= processPlayerImpact(player);
            });
            
            // Apply market-specific adjustments
            if (marketType === 'match_result') {
                // For match result, balance both teams' impacts
                adjustment *= Math.sqrt(teamAAdjustment * teamBAdjustment);
            } else if (marketType.includes('total')) {
                // For totals, average both teams (missing players usually reduce scoring)
                adjustment *= (teamAAdjustment + teamBAdjustment) / 2;
            } else if (marketType === 'corners' || marketType === 'cards') {
                // Missing players can affect set pieces and aggression
                adjustment *= (teamAAdjustment + teamBAdjustment) / 2;
            } else {
                // Default: balanced impact
                adjustment *= Math.sqrt(teamAAdjustment * teamBAdjustment);
            }
            
            return prob * adjustment;
        }
        
        function applyMissingPlayersAnalysis(prob, missingPlayersAnalysis, marketType, teamContext) {
            if (!missingPlayersAnalysis || typeof missingPlayersAnalysis !== 'object') return prob;
            
            let adjustment = 1.0;
            
            // Egységes hiányzó játékosok hatása minden sportra
            const processTeamMissing = (missingPlayers) => {
                if (!missingPlayers || !Array.isArray(missingPlayers)) return 1.0;
                
                let teamAdjustment = 1.0;
                missingPlayers.forEach(player => {
                    if (player.impact_scale !== undefined) {
                        const impact = parseFloat(player.impact_scale) || 50;
                        const isKeyPlayer = player.is_key_player === true;
                        
                        // Egységes súlyozás: kulcsjátékos max 30%, nem kulcs max 10%
                        const maxImpact = isKeyPlayer ? 0.30 : 0.10;
                        
                        // 1-100 skála -> százalékos hatás (50 = semleges)
                        const rawImpact = (50 - impact) / 100; // 25 -> 0.25 (25% gyengébb)
                        const cappedImpact = Math.max(-maxImpact, Math.min(maxImpact, rawImpact));
                        
                        const playerMultiplier = 1 + cappedImpact; // 1 - 0.25 = 0.75 (25% gyengébb)
                        teamAdjustment *= playerMultiplier;
                    }
                });
                return teamAdjustment;
            };
            
            // Minden sport típusú missing players listáját feldolgozza
            const teamAMissing = processTeamMissing(missingPlayersAnalysis.team_a_missing || missingPlayersAnalysis.player_a_issues || []);
            const teamBMissing = processTeamMissing(missingPlayersAnalysis.team_b_missing || missingPlayersAnalysis.player_b_issues || []);
            
            // Sportspecifikus alkalmazás
            if (marketType === 'match_result') {
                adjustment *= Math.sqrt(teamAMissing * teamBMissing); // Kiegyensúlyozott
            } else if (marketType.includes('total')) {
                adjustment *= (teamAMissing + teamBMissing) / 2; // Átlagos hatás total piacokra
            } else if (marketType === 'corners') {
                adjustment *= (teamAMissing + teamBMissing) / 2; // Átlagos hatás szögletekre
            }
            
            return prob * adjustment;
        }
        
        function applyInjuryAdjustments(prob, injuryData, marketType) {
            if (!injuryData || !Array.isArray(injuryData)) return prob;
            
            let adjustment = 1.0;
            
            injuryData.forEach(injury => {
                if (!injury.player_importance) return;
                
                // Player importance scale: 0.1 (bench) to 1.0 (star player)
                const importance = parseFloat(injury.player_importance) || 0.5;
                const injuryImpact = importance * 0.1; // Max 10% per key player
                
                if (injury.position === 'goalkeeper' && marketType.includes('total')) {
                    adjustment *= (1 + injuryImpact); // Weaker keeper = more goals
                } else if (injury.position === 'striker' && marketType.includes('goals')) {
                    adjustment *= (1 - injuryImpact); // Missing striker = fewer goals
                } else if (injury.position === 'defender' && marketType === 'corners') {
                    adjustment *= (1 + injuryImpact * 0.5); // Weaker defense = more corners
                }
            });
            
            return prob * adjustment;
        }
        
        function applyTacticalAdjustments(prob, tacticalData, marketType) {
            if (!tacticalData || typeof tacticalData !== 'object') return prob;
            
            let adjustment = 1.0;
            
            // Formation analysis (e.g., 3-5-2 vs 4-4-2)
            if (tacticalData.formation_impact) {
                const formationFactor = parseFloat(tacticalData.formation_impact) || 1.0;
                if (marketType.includes('goals') && formationFactor > 1.1) {
                    adjustment *= 1.05; // Attacking formation
                } else if (marketType.includes('goals') && formationFactor < 0.9) {
                    adjustment *= 0.95; // Defensive formation
                }
            }
            
            // Playing style (possession vs counter-attack)
            if (tacticalData.playing_style) {
                if (tacticalData.playing_style.includes('possession') && marketType === 'corners') {
                    adjustment *= 0.9; // Possession play = fewer corners
                } else if (tacticalData.playing_style.includes('counter') && marketType.includes('cards')) {
                    adjustment *= 1.1; // Counter-attacking = more fouls
                }
            }
            
            return prob * adjustment;
        }
        
        // Enhanced venue conditions analysis
        function applyEnhancedVenueAnalysis(prob, venueConditions, marketType) {
            let adjustment = 1.0;
            
            const venueType = venueConditions.venue_type || 'outdoor';
            
            if (venueType.toLowerCase() === 'indoor') {
                // Indoor venues: minimal environmental impact, focus on venue quality
                const courtConditions = venueConditions.court_conditions || venueConditions.arena_conditions || 'good';
                const homeAdvantage = KeywordMatcher.extractNumber(
                    venueConditions.home_court_advantage || venueConditions.home_advantage,
                    ['advantage', 'előny', 'benefit']
                ) || 0;
                
                // Small positive adjustment for excellent conditions
                if (courtConditions.toLowerCase().includes('excellent') || courtConditions.toLowerCase().includes('kiváló')) {
                    adjustment *= 1.02; // 2% improvement
                }
                
                // Home advantage factor (typically small for indoor sports)
                if (homeAdvantage > 0) {
                    const homeBonus = Math.min(homeAdvantage / 100, 0.05); // Max 5% home advantage
                    if (marketType === 'match_result') {
                        adjustment *= (1 + homeBonus);
                    }
                }
            } else {
                // Outdoor venues: consider field conditions, dimensions, altitude
                const altitude = KeywordMatcher.extractNumber(
                    venueConditions.altitude || venueConditions.tengerszint,
                    ['altitude', 'elevation', 'magasság', 'meter', 'feet']
                );
                
                // Altitude effects (higher altitude = more offense in some sports)
                if (altitude && altitude > 1000) {
                    const altitudeEffect = Math.min((altitude - 1000) / 10000, 0.08); // Max 8% at very high altitude
                    if (marketType.includes('total') || marketType.includes('goals')) {
                        adjustment *= (1 + altitudeEffect); // More scoring at altitude
                    }
                }
            }
            
            return prob * adjustment;
        }
        
        // Enhanced motivation analysis with multilingual support
        function applyEnhancedMotivationAnalysis(prob, motivationAnalysis, marketType) {
            let adjustment = 1.0;
            
            // Extract motivation data for both teams/players
            const teamAMotivation = motivationAnalysis.home_team_motivation || motivationAnalysis.player1_motivation || {};
            const teamBMotivation = motivationAnalysis.away_team_motivation || motivationAnalysis.player2_motivation || {};
            
            const processTeamMotivation = (teamMotiv) => {
                if (!teamMotiv) return 1.0;
                
                // Extract motivation scale
                const motivationScale = KeywordMatcher.convertImpactScale(
                    teamMotiv.motivation_scale || teamMotiv.motiváció || 50
                );
                
                // Extract high motivation boolean
                const isHighMotivation = KeywordMatcher.convertBoolean(
                    teamMotiv.is_high_motivation || teamMotiv.magas_motiváció
                );
                
                // League position impact
                const leaguePosition = KeywordMatcher.extractNumber(
                    teamMotiv.league_position || teamMotiv.division_standing || teamMotiv.pozíció,
                    KeywordMatcher.motivation.league_position
                );
                
                // Playoff implications
                const playoffImplications = KeywordMatcher.convertBoolean(
                    teamMotiv.playoff_race || teamMotiv.rájátszás || teamMotiv.european_competition
                );
                
                let teamAdjustment = 1.0;
                
                // Base motivation scale effect (50 = neutral, 100 = max motivated)
                if (isHighMotivation && motivationScale > 50) {
                    const motivationBoost = Math.max(0, Math.min(0.15, (motivationScale - 50) / 100 * 0.3)); // Max 15%
                    teamAdjustment *= (1 + motivationBoost);
                }
                
                // League position pressure (lower position = higher desperation)
                if (leaguePosition && leaguePosition > 10) {
                    const desperationFactor = Math.min((leaguePosition - 10) / 10, 0.1); // Max 10% desperation boost
                    teamAdjustment *= (1 + desperationFactor);
                }
                
                // Playoff implications boost
                if (playoffImplications) {
                    teamAdjustment *= 1.05; // 5% boost for playoff implications
                }
                
                return teamAdjustment;
            };
            
            const teamAAdjustment = processTeamMotivation(teamAMotivation);
            const teamBAdjustment = processTeamMotivation(teamBMotivation);
            
            // Apply market-specific motivation effects
            if (marketType === 'match_result') {
                // For match results, apply balanced motivation effect
                adjustment *= Math.sqrt(teamAAdjustment * teamBAdjustment);
            } else if (marketType === 'cards' || marketType.includes('card')) {
                // High motivation can lead to more aggressive play
                const avgMotivation = (teamAAdjustment + teamBAdjustment) / 2;
                adjustment *= Math.min(1.15, avgMotivation * 1.1); // Cap at 15% increase
            } else if (marketType.includes('total') || marketType.includes('goals')) {
                // Motivation can affect scoring
                const avgMotivation = (teamAAdjustment + teamBAdjustment) / 2;
                adjustment *= avgMotivation;
            } else if (marketType === 'corners') {
                // Motivated teams attack more
                const avgMotivation = (teamAAdjustment + teamBAdjustment) / 2;
                adjustment *= Math.min(1.12, avgMotivation * 1.05); // Cap at 12% increase
            }
            
            return prob * adjustment;
        }
        
        // Enhanced tennis analysis with multilingual support
        function applyEnhancedTennisAnalysis(prob, tennisAnalysis, marketType) {
            let adjustment = 1.0;
            
            // Surface advantage analysis
            if (tennisAnalysis.surface_advantage) {
                const playerAAdvantage = KeywordMatcher.convertImpactScale(
                    tennisAnalysis.surface_advantage.player_a_advantage || 50
                );
                const playerBAdvantage = KeywordMatcher.convertImpactScale(
                    tennisAnalysis.surface_advantage.player_b_advantage || 50
                );
                
                // Surface effects (bigger impact in tennis than other sports)
                const playerAMultiplier = 1 + Math.max(-0.25, Math.min(0.25, (playerAAdvantage - 50) / 100 * 0.5));
                const playerBMultiplier = 1 + Math.max(-0.25, Math.min(0.25, (playerBAdvantage - 50) / 100 * 0.5));
                
                if (marketType === 'match_result') {
                    adjustment *= Math.sqrt(playerAMultiplier * playerBMultiplier);
                }
            }
            
            // Recent injuries analysis
            if (tennisAnalysis.recent_injuries) {
                const processPlayerInjury = (injury) => {
                    if (!injury) return 1.0;
                    
                    const severity = KeywordMatcher.convertImpactScale(injury.injury_severity || 50);
                    const recoveryPercent = KeywordMatcher.extractNumber(
                        injury.recovery_status,
                        ['percent', '%', 'százalék']
                    ) || 100;
                    
                    // In tennis, injuries have more direct impact
                    const injuryImpact = Math.max(0, (50 - severity) / 100); // Lower severity number = worse
                    const recoveryFactor = recoveryPercent / 100;
                    
                    const finalImpact = injuryImpact * (1 - recoveryFactor);
                    return 1 + Math.max(-0.30, Math.min(0, -finalImpact)); // Max 30% negative impact
                };
                
                const playerAInjuryMultiplier = processPlayerInjury(tennisAnalysis.recent_injuries.player_a_injury);
                const playerBInjuryMultiplier = processPlayerInjury(tennisAnalysis.recent_injuries.player_b_injury);
                
                adjustment *= Math.sqrt(playerAInjuryMultiplier * playerBInjuryMultiplier);
            }
            
            return prob * adjustment;
        }
        
        function applyMotivationAnalysis(prob, motivationAnalysis, marketType) {
            if (!motivationAnalysis || typeof motivationAnalysis !== 'object') return prob;
            
            let adjustment = 1.0;
            
            // Egységes motivációs hatás minden sportra (max 20% pozitív hatás)
            if (motivationAnalysis.is_high_motivation && motivationAnalysis.motivation_scale) {
                const isHighMotivation = motivationAnalysis.is_high_motivation === true;
                const motivationScale = parseFloat(motivationAnalysis.motivation_scale) || 50;
                
                if (isHighMotivation && motivationScale > 50) {
                    // 1-100 skála -> max 20% pozitív hatás
                    // 50 = semleges, 100 = +20% hatás
                    const rawMotivationBoost = (motivationScale - 50) / 100 * 0.4; // Max 20%
                    const cappedBoost = Math.max(0, Math.min(0.2, rawMotivationBoost)); // Cap at 20%
                    
                    // Sportspecifikus alkalmazás
                    if (marketType === 'match_result') {
                        adjustment *= (1 + cappedBoost); // Általános teljesítmény növekedés
                    } else if (marketType === 'cards') {
                        adjustment *= (1 + cappedBoost * 1.5); // Motiváció -> több intenzitás -> több lap
                    } else if (marketType.includes('total')) {
                        adjustment *= (1 + cappedBoost * 0.8); // Motiváció -> több gól/pont
                    } else if (marketType === 'corners') {
                        adjustment *= (1 + cappedBoost * 0.6); // Motiváció -> több támadás -> több szöglet
                    }
                }
            }
            
            return prob * adjustment;
        }
        
        function applyMotivationAdjustments(prob, motivationData, marketType) {
            if (!motivationData || typeof motivationData !== 'object') return prob;
            
            let adjustment = 1.0;
            
            // League position pressure
            if (motivationData.league_pressure) {
                const pressure = parseFloat(motivationData.league_pressure) || 1.0;
                if (pressure > 1.2 && marketType === 'cards') {
                    adjustment *= 1.1; // High pressure = more aggressive play
                } else if (pressure > 1.2 && marketType.includes('goals')) {
                    adjustment *= 1.05; // Desperation can lead to more goals
                }
            }
            
            // Cup competition importance
            if (motivationData.cup_importance) {
                const importance = parseFloat(motivationData.cup_importance) || 1.0;
                if (importance > 1.5) {
                    adjustment *= 1.03; // Cup matches tend to be more intense
                }
            }
            
            // Derby/rivalry factor
            if (motivationData.rivalry_factor) {
                const rivalry = parseFloat(motivationData.rivalry_factor) || 1.0;
                if (rivalry > 1.3) {
                    if (marketType === 'cards') adjustment *= 1.2; // Derbies = more cards
                    if (marketType.includes('goals')) adjustment *= 1.1; // Derbies = more goals
                }
            }
            
            return prob * adjustment;
        }

        // --- MATHJAX RENDERING FUNCTIONS --- //
        function renderAllMath() {
            if (window.MathJax && window.MathJax.typesetPromise) {
                console.log('Re-rendering all MathJax formulas...');
                MathJax.typesetPromise().then(() => {
                    console.log('All MathJax formulas rendered successfully!');
                }).catch((err) => console.error('MathJax global render error:', err));
            }
        }
        
        // Re-render math when switching tabs
        function switchTabAndRenderMath(tabName) {
            UIManager.switchTab(tabName);
            setTimeout(renderAllMath, 200);
        }

        // --- HELPER FUNCTIONS --- //
        function calculateDiversification(bets) {
            const matchSet = new Set(bets.map(b => b.matchIdentifier));
            const marketSet = new Set(bets.map(b => b.market));
            const matchDiv = matchSet.size / bets.length;
            const marketDiv = marketSet.size / bets.length;
            return {matchDiv, marketDiv, matchCount: matchSet.size, marketCount: marketSet.size};
        }

        function getBestTip(bets, by = 'prob') {
            if (!bets.length) return null;
            return bets.reduce((best, bet) => (bet[by] > (best?.[by] ?? -Infinity) ? bet : best), null);
        }

        function getConfidenceIcon(conf) {
            if (conf === 'high') return '🟢';
            if (conf === 'medium') return '🟠';
            return '🔴';
        }

        function getConfidenceColor(conf) {
            if (conf === 'high') return '#10b981';
            if (conf === 'medium') return '#f59e0b';
            return '#ef4444';
        }

        // 1. Alacsony kockázatú/kiemelkedő EV-s tippek szűrése
        function filterLowRiskHighEV(bets, capital) {
            return bets.filter(bet => bet.expected_return > 0 && (bet.prob > 0.6 || bet.expected_return > 0.1 * capital));
        }

        // --- AUTOMATIC PROCESSING FUNCTIONS --- //
        function checkForAutomaticProcessing(sportBreakdown) {
            const selectedAiModel = document.getElementById('aiModel').value;
            const aiApiKey = document.getElementById('aiApiKey').value.trim();
            
            if (selectedAiModel !== 'none' && aiApiKey.length > 0) {
                console.log(`Automatic processing available with ${selectedAiModel}`);
                // Auto-processing is available - user can click the button
            } else {
                console.log('Manual processing mode - user needs to paste JSON response');
            }
        }
        
        async function processPromptAutomatically() {
            const selectedAiModel = document.getElementById('aiModel').value;
            const aiApiKey = document.getElementById('aiApiKey').value.trim();
            const autoDataSearchEnabled = document.getElementById('enableAutoDataSearch').checked;
            
            if (selectedAiModel === 'none' || !aiApiKey) {
                showLocalizedNotification('notificationNoAiModelSelected', 'warning');
                return;
            }
            
            showLocalizedLoading('autoProcessingPrompt', 'autoProcessingData', { model: selectedAiModel });
            
            try {
                let response;
                
                // Check if automatic data search is enabled and we have Perplexity
                if (autoDataSearchEnabled && selectedAiModel === 'perplexity') {
                    console.log('🔍 Starting automatic data search with Perplexity...');
                    response = await performAutomaticDataSearch(aiApiKey);
                } else {
                    // Use traditional prompt-based approach
                    const promptContent = document.getElementById('combinedPromptContent').textContent;
                    if (!promptContent) {
                        showLocalizedNotification('notificationNoPromptContent', 'error');
                        return;
                    }
                    
                    switch (selectedAiModel) {
                        case 'chatgpt':
                            response = await processWithChatGPT(promptContent, aiApiKey);
                            break;
                        case 'deepseek':
                            response = await processWithDeepSeek(promptContent, aiApiKey);
                            break;
                        case 'perplexity':
                            response = await processWithPerplexity(promptContent, aiApiKey);
                            break;
                        case 'gemini':
                            response = await processWithGemini(promptContent, aiApiKey);
                            break;
                        default:
                            throw new Error(`Unsupported AI model: ${selectedAiModel}`);
                    }
                }
                
                // Automatically fill the retrieved data field
                DOM.retrievedDataInput.value = response;
                DOM.processDataBtn.disabled = false;
                
                showLocalizedNotification('notificationAutoProcessingComplete', 'success');
                
                // Optionally auto-process the data
                setTimeout(() => {
                    processAllRetrievedData();
                }, 1000);
                
            } catch (error) {
                console.error('Auto processing error:', error);
                showLocalizedNotification('notificationAutoProcessingError', 'error', { error: error.message });
            } finally {
                UIManager.hideLoading();
            }
        }
        
        async function processWithChatGPT(prompt, apiKey) {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-4o',
                    messages: [{ role: 'user', content: prompt }],
                    response_format: { type: "json_object" }
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || `HTTP ${response.status}`);
            }
            
            const data = await response.json();
            return data.choices[0].message.content;
        }
        
        async function processWithDeepSeek(prompt, apiKey) {
            const response = await fetch('https://api.deepseek.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'deepseek-chat',
                    messages: [{ role: 'user', content: prompt }],
                    response_format: { type: "json_object" }
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || `HTTP ${response.status}`);
            }
            
            const data = await response.json();
            return data.choices[0].message.content;
        }
        
        async function processWithPerplexity(prompt, apiKey) {
            const response = await fetch('https://api.perplexity.ai/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'llama-3.1-sonar-large-128k-online',
                    messages: [{ role: 'user', content: prompt }]
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || `HTTP ${response.status}`);
            }
            
            const data = await response.json();
            return data.choices[0].message.content;
        }
        
        // Automatic data search using Perplexity with web search
        async function performAutomaticDataSearch(apiKey) {
            console.log('🔍 Starting automatic data search...');
            
            // Extract matches from uploaded images
            const allMatches = [];
            AppState.uploadedImages.forEach(image => {
                if (image.analysisResult && image.analysisResult.matches_detected) {
                    image.analysisResult.matches_detected.forEach(match => {
                        allMatches.push({
                            home_team: match.home_team,
                            away_team: match.away_team,
                            sport: image.sport || 'football',
                            league: match.league
                        });
                    });
                }
            });
            
            if (allMatches.length === 0) {
                throw new Error('No matches found for automatic data search');
            }
            
            console.log(`Found ${allMatches.length} matches for data search`);
            
            // Group matches by sport
            const matchesBySport = {};
            allMatches.forEach(match => {
                if (!matchesBySport[match.sport]) {
                    matchesBySport[match.sport] = [];
                }
                matchesBySport[match.sport].push(match);
            });
            
            const analyses = [];
            
            // Process each sport
            for (const [sport, matches] of Object.entries(matchesBySport)) {
                console.log(`🔍 Searching data for ${sport}: ${matches.length} matches`);
                
                const sportAnalysis = {
                    sport: sport,
                    matches: []
                };
                
                // Search data for each match
                for (let i = 0; i < Math.min(matches.length, 5); i++) { // Limit to 5 matches per sport
                    const match = matches[i];
                    console.log(`🔍 Searching: ${match.home_team} vs ${match.away_team}`);
                    
                    try {
                        const matchData = await searchMatchDataComprehensive(match, apiKey);
                        sportAnalysis.matches.push(matchData);
                        
                        // Small delay to avoid rate limiting
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        
                    } catch (error) {
                        console.error(`Error searching data for ${match.home_team} vs ${match.away_team}:`, error);
                        
                        // Add basic fallback data
                        sportAnalysis.matches.push(createFallbackMatchData(match));
                    }
                }
                
                analyses.push(sportAnalysis);
            }
            
            const result = { analyses };
            console.log('✅ Automatic data search completed:', result);
            
            return JSON.stringify(result, null, 2);
        }
        
        // Helper function to get sport-specific advanced metrics
        function getAdvancedMetricsForSport(sport) {
            const metricsMap = {
                'football': `
- Expected Goals (xG) for and against (last 10 matches)
- Shot conversion rates and shots on target %
- Possession statistics and passing accuracy
- Defensive actions per game (tackles, interceptions, clearances)
- Set piece efficiency (corners, free kicks)
- Player ratings and key performance indicators`,
                'soccer': `
- Expected Goals (xG) for and against (last 10 matches)
- Shot conversion rates and shots on target %
- Possession statistics and passing accuracy
- Defensive actions per game (tackles, interceptions, clearances)
- Set piece efficiency (corners, free kicks)
- Player ratings and key performance indicators`,
                'tennis': `
- Elo ratings and ranking positions
- Surface-specific performance (clay, grass, hard court)
- Serve statistics (first serve %, aces, double faults)
- Return game statistics and break point conversion
- Recent match times and physical condition indicators
- Head-to-head surface-specific records`,
                'basketball': `
- Offensive/Defensive efficiency ratings
- Four Factors: eFG%, TOV%, OREB%, FTR
- Pace and possessions per game
- Player efficiency ratings (PER) for key players
- Fatigue factors (back-to-back games, travel distance)
- Clutch performance statistics`,
                'hockey': `
- Corsi/Fenwick statistics and shot metrics
- Goaltender save percentages and recent form
- Power play/penalty kill efficiency
- Faceoff win percentages by zone
- Plus/minus ratings for key players
- Special teams usage and success rates`,
                'baseball': `
- Pitcher FIP, ERA, WHIP, and recent performance
- Team wOBA, wRC+, and advanced hitting metrics
- Bullpen usage and effectiveness
- Park factors and weather impact calculations
- Pitcher vs batter matchup history
- Defensive efficiency metrics (UZR, DRS)`,
                'americanfootball': `
- EPA (Expected Points Added) per play
- DVOA (Defense-adjusted Value Over Average)
- Turnover differential and red zone efficiency
- Strength of schedule and recent opponent quality
- Injury report impact on key positions
- Weather impact on passing vs rushing games`
            };
            
            return metricsMap[sport] || `
- Sport-specific performance metrics
- Key player performance indicators
- Recent statistical trends
- Situational performance data`;
        }

        // Enhanced search data for comprehensive mathematical analysis
        async function searchMatchDataComprehensive(match, apiKey) {
            const sportConfig = SportConfigs[match.sport] || SportConfigs.unknown;
            
            const searchPrompt = `🔍 COMPREHENSIVE SPORTS DATA SEARCH FOR MATHEMATICAL ANALYSIS

MATCH: ${match.home_team} vs ${match.away_team}
SPORT: ${match.sport.toUpperCase()}
LEAGUE: ${match.league || 'Unknown'}

You are tasked with finding ALL necessary data for advanced mathematical sports betting models. Search the internet thoroughly for the following data categories:

📊 BASIC STATISTICAL DATA:
- Recent form (last 10 matches for each team with exact scores)
- Head-to-head record (last 10 meetings with scores and dates)
- Current league position and points
- Home/away performance splits
- Goals/points scored and conceded statistics

🎯 ADVANCED METRICS (Sport-specific):
${getAdvancedMetricsForSport(match.sport)}

💉 INJURY & SUSPENSION DATA:
- All missing players (names, positions, importance rating 1-10)
- Expected return dates
- Replacement players and their quality
- Impact on team performance (quantify in percentages)

🏟️ VENUE & CONDITIONS:
- Stadium/arena name and capacity
- Surface type (grass, artificial, court type)
- Weather forecast (temperature, wind, precipitation)
- Altitude and climate effects on performance

🔬 TACTICAL ANALYSIS:
- Formation and playing style for each team
- Key player dependencies
- Recent tactical changes or injuries affecting strategy
- Manager/coach impact and recent decisions

📈 MOMENTUM & PSYCHOLOGY:
- Team morale and confidence levels
- Pressure situations (relegation, promotion, titles)
- Recent media coverage and controversies
- Fan support and attendance factors

🎲 BETTING MARKET DATA:
- Opening odds vs current odds movement
- Betting volume and public sentiment
- Sharp money indicators
- Historical closing line value

Please provide QUANTIFIED data wherever possible. Instead of "good form", provide "80% win rate in last 10 matches". Instead of "key injury", provide "reduces team strength by 15%".

Provide the response in this comprehensive JSON format:
{
  "home_team": "${match.home_team}",
  "away_team": "${match.away_team}",
  "league": "${match.league || 'Unknown'}",
  "match_date": "2024-01-15",
  "venue": {
    "name": "Stadium name",
    "capacity": 60000,
    "surface_type": "natural_grass",
    "venue_type": "outdoor",
    "altitude": 100,
    "weather_forecast": {
      "temperature": 15,
      "wind_speed": 10,
      "wind_direction": "SW",
      "precipitation_probability": 20,
      "humidity": 65
    }
  },
  "comprehensive_team_data": {
    "home_team": {
      "recent_form_detailed": [
        {"opponent": "Team A", "result": "W", "score": "2-1", "date": "2024-01-10", "xG_for": 1.8, "xG_against": 1.2},
        {"opponent": "Team B", "result": "W", "score": "3-0", "date": "2024-01-07", "xG_for": 2.1, "xG_against": 0.8}
      ],
      "league_position": 3,
      "points": 45,
      "goals_for": 58,
      "goals_against": 32,
      "home_record": {"wins": 8, "draws": 3, "losses": 1},
      "away_record": {"wins": 6, "draws": 2, "losses": 4},
      "advanced_metrics": {
        "xG_per_game": 1.85,
        "xGA_per_game": 1.12,
        "possession_avg": 62.5,
        "shot_conversion_rate": 12.8,
        "defensive_actions_per_game": 45.2
      }
    },
    "away_team": {
      "recent_form_detailed": [
        {"opponent": "Team C", "result": "L", "score": "0-2", "date": "2024-01-10", "xG_for": 0.9, "xG_against": 2.2},
        {"opponent": "Team D", "result": "W", "score": "1-0", "date": "2024-01-07", "xG_for": 1.1, "xG_against": 0.7}
      ],
      "league_position": 7,
      "points": 38,
      "goals_for": 42,
      "goals_against": 38,
      "home_record": {"wins": 7, "draws": 4, "losses": 1},
      "away_record": {"wins": 4, "draws": 3, "losses": 5},
      "advanced_metrics": {
        "xG_per_game": 1.45,
        "xGA_per_game": 1.38,
        "possession_avg": 48.2,
        "shot_conversion_rate": 10.2,
        "defensive_actions_per_game": 52.8
      }
    }
  },
  "head_to_head_detailed": {
    "overall_wins_home": 6,
    "overall_wins_away": 3,
    "overall_draws": 2,
    "last_5_meetings": [
      {"date": "2023-09-15", "result": "2-1", "venue": "home"},
      {"date": "2023-04-22", "result": "0-0", "venue": "away"},
      {"date": "2022-11-30", "result": "3-1", "venue": "home"}
    ],
    "goals_scored_home": 18,
    "goals_scored_away": 12,
    "average_goals_per_meeting": 2.73
  },
  "injury_suspension_impact": {
    "home_team_missing": [
      {"name": "Star Player", "position": "CAM", "importance": 9, "impact_percentage": 15, "expected_return": "2024-02-01"},
      {"name": "Defender", "position": "CB", "importance": 7, "impact_percentage": 8, "expected_return": "2024-01-20"}
    ],
    "away_team_missing": [
      {"name": "Striker", "position": "ST", "importance": 8, "impact_percentage": 12, "expected_return": "2024-01-25"}
    ],
    "total_impact_home": 23,
    "total_impact_away": 12
  },
  "tactical_analysis": {
    "home_team_formation": "4-3-3",
    "away_team_formation": "4-2-3-1",
    "home_team_style": "possession_based",
    "away_team_style": "counter_attacking",
    "manager_impact": {
      "home_manager_experience": 8.5,
      "away_manager_experience": 6.2,
      "tactical_flexibility": "high"
    }
  },
  "psychological_factors": {
    "home_team_morale": 78,
    "away_team_morale": 65,
    "pressure_level": {
      "home_team": 75,
      "away_team": 40
    },
    "fan_support_impact": 12,
    "media_coverage": "high_attention"
  },
  "betting_market_analysis": {
    "opening_odds": {"home": 1.90, "draw": 3.40, "away": 4.20},
    "current_odds": {"home": 1.85, "draw": 3.50, "away": 4.00},
    "odds_movement": "slight_favor_home",
    "betting_volume": "high",
    "sharp_money_indicator": "home_team"
  },
  "fair_odds_calculation": {
    "home_win_prob": 0.52,
    "draw_prob": 0.26,
    "away_win_prob": 0.22,
    "calculation_method": "Comprehensive model incorporating xG, injuries, form, H2H, weather, psychology",
    "confidence_level": 85
  },
  "total_goals_analysis": {
    "expected_total_goals": 2.78,
    "over_2_5_prob": 0.63,
    "under_2_5_prob": 0.37,
    "over_1_5_prob": 0.82,
    "under_1_5_prob": 0.18,
    "btts_prob": 0.68
  },
  "additional_markets": {
    "corners": {"expected": 11.5, "over_10_5": 0.58},
    "cards": {"expected": 4.2, "over_4_5": 0.45},
    "first_goal": {"home": 0.58, "away": 0.42}
  },
  "reasoning": "Comprehensive analysis based on xG data showing home team superior (1.85 vs 1.45), significant injury impact favoring home (23% vs 12%), strong home form (8-3-1), and weather conditions favoring possession-based play. Sharp money on home team confirms model. Sources: ESPN, FiveThirtyEight, Transfermarkt.",
  "data_sources": ["ESPN", "BBC Sport", "FiveThirtyEight", "Transfermarkt", "Official League Data", "Weather.com"],
  "last_updated": "2024-01-15T10:30:00Z"
}

Please search for real, current data and provide accurate probabilities based on your findings.`;

            const response = await fetch('https://api.perplexity.ai/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'sonar-pro',
                    messages: [{ role: 'user', content: searchPrompt }],
                    search_mode: 'web',
                    temperature: 0.1,
                    max_tokens: 2000
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || `HTTP ${response.status}`);
            }
            
            const data = await response.json();
            const content = data.choices[0].message.content;
            
            // Try to extract JSON from the response
            try {
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    return JSON.parse(jsonMatch[0]);
                } else {
                    throw new Error('No JSON found in response');
                }
            } catch (parseError) {
                console.warn('Failed to parse JSON from Perplexity response, creating fallback data');
                return createFallbackMatchData(match, content);
            }
        }
        
        // Create fallback match data when search fails
        function createFallbackMatchData(match, searchContent = '') {
            return {
                home_team: match.home_team,
                away_team: match.away_team,
                league: match.league || 'Unknown League',
                match_date: new Date().toISOString().split('T')[0],
                venue: 'Unknown Venue',
                venue_type: 'outdoor',
                fair_odds_calculation: {
                    home_win_prob: 0.40,
                    draw_prob: 0.30,
                    away_win_prob: 0.30,
                    calculation_method: 'Fallback probabilities - search data unavailable'
                },
                total_goals_prob: {
                    over_2_5: 0.50,
                    under_2_5: 0.50
                },
                both_teams_score: {
                    yes: 0.55,
                    no: 0.45
                },
                team_stats: {
                    home_team: {
                        recent_form: 'Data unavailable',
                        league_position: 'Unknown'
                    },
                    away_team: {
                        recent_form: 'Data unavailable', 
                        league_position: 'Unknown'
                    }
                },
                head_to_head: {
                    overall_record: 'Data unavailable',
                    recent_meetings: 'Data unavailable'
                },
                missing_players_analysis: {
                    team_a_missing: [],
                    team_b_missing: []
                },
                motivation_analysis: {
                    home_team_motivation: {
                        motivation_scale: 50,
                        motivation_reasoning: 'Data unavailable'
                    },
                    away_team_motivation: {
                        motivation_scale: 50,
                        motivation_reasoning: 'Data unavailable'
                    }
                },
                reasoning: `Fallback data for ${match.home_team} vs ${match.away_team}. ${searchContent ? 'Partial search results: ' + searchContent.substring(0, 200) + '...' : 'No search data available.'}`
            };
        }
        
        async function processWithGemini(prompt, apiKey) {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-latest:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{ text: prompt }]
                    }],
                    generationConfig: {
                        responseMimeType: "application/json"
                    }
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || `HTTP ${response.status}`);
            }
            
            const data = await response.json();
            return data.candidates[0].content.parts[0].text;
        }

        // --- JSON REPAIR TESTING FUNCTION --- //
        function testEmergencyJsonRepair() {
            const testData = `{
                "broken": "json with trailing comma",
                "missing_quotes": here,
                "Manchester City vs Arsenal": {
                    "odds": 1.85,
                    "league": "Premier League"
                },
                "Liverpool": "vs Chelsea 2.10",
                "oversized_object": {
                    "key1": "value1", "key2": "value2", "key3": "value3",
                    "key4": "value4", "key5": "value5", "key6": "value6"
                }
            `;
            
            try {
                console.log('🔧 Testing emergency JSON repair with broken data...');
                const repairedJson = extractJsonFromText(testData);
                const parsed = JSON.parse(repairedJson);
                
                console.log('✅ JSON repair test successful!');
                console.log('Repaired data:', parsed);
                
                // Show the result in the textarea for demonstration
                DOM.retrievedDataInput.value = repairedJson;
                DOM.processDataBtn.disabled = false;
                
                showLocalizedNotification('emergencyExtractionSuccess', 'success');
                
            } catch (error) {
                console.error('❌ JSON repair test failed:', error);
                showLocalizedNotification('jsonRepairFallback', 'warning');
            }
        }

        // --- DOWNLOAD FUNCTIONS --- //
        function downloadPortfolioSummary() {
            const portfolio = AppState.portfolio;
            const capital = parseFloat(document.getElementById('capital').value);
            const totalStake = portfolio.singles.reduce((sum, bet) => sum + bet.stake, 0) + portfolio.parlays.reduce((sum, bet) => sum + bet.stake, 0);
            const totalEV = portfolio.singles.reduce((sum, bet) => sum + bet.ev, 0) + portfolio.parlays.reduce((sum, bet) => sum + bet.ev, 0);
            
            let content = `PROFESSZIONÁLIS SPORTFOGADÁSI PORTFÓLIÓ ÖSSZEFOGLALÓ
Generálva: ${new Date().toLocaleDateString('hu-HU')} ${new Date().toLocaleTimeString('hu-HU')}
================================================================================

PORTFÓLIÓ ÁTTEKINTÉS:
• Összes tőke: €${capital.toFixed(2)}
• Teljes tét: €${totalStake.toFixed(2)} (${(totalStake/capital*100).toFixed(1)}% kihasználás)
• Várható profit: €${totalEV.toFixed(2)}
• Várható ROI: ${(totalEV/totalStake*100).toFixed(1)}%
• Ajánlások száma: ${portfolio.singles.length} egyes + ${portfolio.parlays.length} kombi

================================================================================
EGYES FOGADÁSOK (${portfolio.singles.length} db):
================================================================================
`;

            portfolio.singles.forEach((bet, index) => {
                const evPercent = (bet.ev / bet.stake * 100).toFixed(2);
                content += `
${index + 1}. ${bet.home_team} vs ${bet.away_team}
   Sportág: ${bet.sport.toUpperCase()}
   Piac: ${bet.market_type.replace(/_/g, ' ')} ${bet.market_specifier || ''}
   Kiválasztás: ${bet.selection}
   Szorzó: ${bet.odds.toFixed(2)}
   Valószínűség: ${(bet.prob * 100).toFixed(1)}%
   Edge: ${(bet.edge * 100).toFixed(2)}%
   Ajánlott tét: €${bet.stake}
   EV: ${evPercent}%
   Potenciális nyereség: €${(bet.stake * (bet.odds - 1)).toFixed(0)}
   
`;
            });

            if (portfolio.parlays.length > 0) {
                content += `
================================================================================
KOMBI FOGADÁSOK (${portfolio.parlays.length} db):
================================================================================
`;

                portfolio.parlays.forEach((parlay, index) => {
                    const evPercent = (parlay.ev / parlay.stake * 100).toFixed(2);
                    content += `
${index + 1}. KOMBI (${parlay.legs.length}x)
   Kombinált szorzó: ${parlay.combinedOdds.toFixed(2)}
   Kombinált valószínűség: ${(parlay.combinedProb * 100).toFixed(1)}%
   Edge: ${(parlay.edge * 100).toFixed(2)}%
   Ajánlott tét: €${parlay.stake}
   EV: ${evPercent}%
   Potenciális nyereség: €${(parlay.stake * (parlay.combinedOdds - 1)).toFixed(0)}
   
   Meccsek:
`;
                    parlay.legs.forEach((leg, legIndex) => {
                        content += `   ${legIndex + 1}. ${leg.home_team} vs ${leg.away_team} - ${leg.selection} @ ${leg.odds.toFixed(2)}\n`;
                    });
                    content += '\n';
                });
            }

            content += `
================================================================================
KOCKÁZAT ELEMZÉS:
================================================================================
• Tőke kihasználás: ${(totalStake/capital*100).toFixed(1)}% (ajánlott: <15%)
• Diverzifikáció: ${portfolio.singles.length + portfolio.parlays.length} különböző fogadás
• Átlagos tétméret: €${(totalStake/(portfolio.singles.length + portfolio.parlays.length)).toFixed(0)}
• Kockázati kategória: ${totalStake/capital > 0.15 ? 'MAGAS' : totalStake/capital > 0.10 ? 'KÖZEPES' : 'ALACSONY'}

FIGYELMEZTETÉS: Ez a portfólió matematikai számításokon alapul. Mindig fogadj felelősségteljesen!
`;

            downloadFile(content, 'portfolio_summary.txt', 'text/plain');
        }

        function downloadCalculationDetails() {
            const portfolio = AppState.portfolio;
            
            let content = `MATEMATIKAI SZÁMÍTÁSOK RÉSZLETEI
Generálva: ${new Date().toLocaleDateString('hu-HU')} ${new Date().toLocaleTimeString('hu-HU')}
================================================================================

ALKALMAZOTT MATEMATIKAI MODELLEK:
================================================================================

1. KELLY KRITÉRIUM:
   Képlet: f* = (bp - q) / b
   ahol: b = szorzó - 1, p = valószínűség, q = 1 - p
   
2. EDGE SZÁMÍTÁS:
   Képlet: Edge = (p × odds) - 1
   
3. VÁRHATÓ ÉRTÉK (EV):
   Képlet: EV = Tét × Edge

================================================================================
RÉSZLETES SZÁMÍTÁSOK FOGADÁSONKÉNT:
================================================================================
`;

            portfolio.singles.forEach((bet, index) => {
                const b = bet.odds - 1;
                const p = bet.prob;
                const q = 1 - p;
                const kellyRaw = (b * p - q) / b;
                const kellyAdjusted = kellyRaw * 0.25; // Conservative modifier
                
                content += `
EGYES FOGADÁS #${index + 1}: ${bet.home_team} vs ${bet.away_team}
────────────────────────────────────────────────────────────────

Alapadatok:
• Szorzó (odds): ${bet.odds.toFixed(3)}
• Valószínűség (p): ${p.toFixed(3)} (${(p*100).toFixed(1)}%)
• Nettó szorzó (b): ${b.toFixed(3)}
• Ellentétes valószínűség (q): ${q.toFixed(3)}

Kelly számítás:
• Nyers Kelly: f* = (${b.toFixed(3)} × ${p.toFixed(3)} - ${q.toFixed(3)}) / ${b.toFixed(3)} = ${kellyRaw.toFixed(4)}
• Konzervatív Kelly: ${kellyRaw.toFixed(4)} × 0.25 = ${kellyAdjusted.toFixed(4)}
• Kelly százalék: ${(kellyAdjusted * 100).toFixed(2)}%

Edge számítás:
• Edge = (${p.toFixed(3)} × ${bet.odds.toFixed(3)}) - 1 = ${bet.edge.toFixed(4)}
• Edge százalék: ${(bet.edge * 100).toFixed(2)}%

Tét számítás:
• Nyers tét: ${kellyAdjusted.toFixed(4)} × €${parseFloat(document.getElementById('capital').value)} = €${(kellyAdjusted * parseFloat(document.getElementById('capital').value)).toFixed(2)}
• Kerekített tét: €${bet.stake}

Várható érték:
• EV = €${bet.stake} × ${bet.edge.toFixed(4)} = €${bet.ev.toFixed(2)}
• EV százalék: ${(bet.ev/bet.stake*100).toFixed(2)}%

Kockázat metrikák:
• Variancia: ${(p * q * b * b).toFixed(4)}
• Szórás: ${Math.sqrt(p * q * b * b).toFixed(4)}
• Sharpe ráta: ${(bet.edge / Math.sqrt(p * q * b * b)).toFixed(4)}

`;
            });

            portfolio.parlays.forEach((parlay, index) => {
                content += `
KOMBI FOGADÁS #${index + 1}:
────────────────────────────────────────────────────────────────

Kombinált számítások:
• Kombinált szorzó: ${parlay.legs.map(l => l.odds.toFixed(2)).join(' × ')} = ${parlay.combinedOdds.toFixed(3)}
• Kombinált valószínűség: ${parlay.legs.map(l => l.prob.toFixed(3)).join(' × ')} = ${parlay.combinedProb.toFixed(4)}
• Edge: ${parlay.edge.toFixed(4)} (${(parlay.edge * 100).toFixed(2)}%)
• EV: €${parlay.ev.toFixed(2)} (${(parlay.ev/parlay.stake*100).toFixed(2)}%)

Meccsek részletei:
`;
                parlay.legs.forEach((leg, legIndex) => {
                    content += `${legIndex + 1}. ${leg.home_team} vs ${leg.away_team}: p=${leg.prob.toFixed(3)}, odds=${leg.odds.toFixed(2)}\n`;
                });
                content += '\n';
            });

            content += `
================================================================================
PORTFÓLIÓ SZINTŰ SZÁMÍTÁSOK:
================================================================================

Teljes portfólió várható érték:
• Összes EV = ${portfolio.singles.map(b => `€${b.ev.toFixed(2)}`).join(' + ')}${portfolio.parlays.length > 0 ? ' + ' + portfolio.parlays.map(p => `€${p.ev.toFixed(2)}`).join(' + ') : ''}
• Teljes EV = €${(portfolio.singles.reduce((sum, bet) => sum + bet.ev, 0) + portfolio.parlays.reduce((sum, bet) => sum + bet.ev, 0)).toFixed(2)}

Kockázat diverzifikáció:
• Különböző meccsek száma: ${new Set([...portfolio.singles.map(b => `${b.home_team}-${b.away_team}`), ...portfolio.parlays.flatMap(p => p.legs.map(l => `${l.home_team}-${l.away_team}`))]).size}
• Különböző sportágak: ${new Set([...portfolio.singles.map(b => b.sport), ...portfolio.parlays.flatMap(p => p.legs.map(l => l.sport))]).size}
`;

            downloadFile(content, 'calculation_details.txt', 'text/plain');
        }

        function downloadDataSources() {
            let content = `ADATFORRÁSOK ÉS ELLENŐRZÉSI INFORMÁCIÓK
Generálva: ${new Date().toLocaleDateString('hu-HU')} ${new Date().toLocaleTimeString('hu-HU')}
================================================================================

FELHASZNÁLT ADATOK ELLENŐRZÉSE:
================================================================================

Az alábbi adatok alapján történtek a számítások. Kérjük, ellenőrizze ezeket a 
valós eredményekkel a számítások pontosságának megállapításához.

`;

            // Include Perplexity search results if available
            if (AppState.perplexitySearchResults && AppState.perplexitySearchResults.length > 0) {
                content += `
PERPLEXITY AI AUTOMATIKUS ADATKERESÉS EREDMÉNYEI:
================================================================================

A Perplexity AI automatikusan megkereste az interneten az alábbi információkat:

`;
                AppState.perplexitySearchResults.forEach((searchResult, index) => {
                    content += `
${index + 1}. KERESÉSI EREDMÉNY:
────────────────────────────────────────────────────────────────
Keresési kérdés: ${searchResult.query || 'N/A'}
Időpont: ${searchResult.timestamp || 'N/A'}

TALÁLT INFORMÁCIÓK:
${searchResult.content || searchResult.answer || 'Nincs elérhető tartalom'}

FORRÁSOK:
${searchResult.sources ? searchResult.sources.map(source => `• ${source.title || source.url}: ${source.url}`).join('\n') : 'Nincs forrás információ'}

MEGBÍZHATÓSÁG: ${searchResult.confidence || 'N/A'}%

`;
                });
                
                content += `
PERPLEXITY KERESÉS ÖSSZEFOGLALÁSA:
────────────────────────────────────────────────────────────────
Összes keresés: ${AppState.perplexitySearchResults.length}
Átlagos megbízhatóság: ${AppState.perplexitySearchResults.reduce((sum, result) => sum + (result.confidence || 0), 0) / AppState.perplexitySearchResults.length || 0}%
Legutóbbi frissítés: ${AppState.perplexitySearchResults[AppState.perplexitySearchResults.length - 1]?.timestamp || 'N/A'}

FONTOS: Ezek az adatok automatikusan kerültek összegyűjtésre a Perplexity AI által.
Kérjük, ellenőrizze a források megbízhatóságát és az információk pontosságát!

`;
            }

            // Extract data from retrieved data if available
            if (AppState.retrievedData && AppState.retrievedData.analyses) {
                AppState.retrievedData.analyses.forEach((analysis, sportIndex) => {
                    content += `
${analysis.sport.toUpperCase()} SPORTÁG:
────────────────────────────────────────────────────────────────
`;
                    
                    analysis.matches.forEach((match, matchIndex) => {
                        content += `
Meccs ${matchIndex + 1}: ${match.home_team} vs ${match.away_team}
League: ${match.league || 'Ismeretlen'}
Dátum: ${match.match_date || 'Nincs megadva'}
Helyszín: ${match.venue?.name || match.venue || 'Ismeretlen'}

ELLENŐRIZENDŐ ADATOK:
`;
                        
                        // Team stats
                        if (match.comprehensive_team_data || match.team_stats) {
                            const teamData = match.comprehensive_team_data || match.team_stats;
                            content += `
Hazai csapat forma: ${teamData.home_team?.recent_form || teamData.home_team?.recent_form_detailed?.map(m => m.result).join('-') || 'Nincs adat'}
Vendég csapat forma: ${teamData.away_team?.recent_form || teamData.away_team?.recent_form_detailed?.map(m => m.result).join('-') || 'Nincs adat'}
Liga pozíciók: Hazai ${teamData.home_team?.league_position || 'N/A'}, Vendég ${teamData.away_team?.league_position || 'N/A'}
`;
                        }
                        
                        // Injuries
                        if (match.injury_suspension_impact || match.missing_players_analysis) {
                            const injuries = match.injury_suspension_impact || match.missing_players_analysis;
                            content += `
Hiányzó játékosok (Hazai): ${injuries.home_team_missing?.map(p => p.name || p.player_name).join(', ') || 'Nincs adat'}
Hiányzó játékosok (Vendég): ${injuries.away_team_missing?.map(p => p.name || p.player_name).join(', ') || 'Nincs adat'}
`;
                        }
                        
                        // Weather
                        if (match.venue?.weather_forecast || match.weather_analysis) {
                            const weather = match.venue?.weather_forecast || match.weather_analysis;
                            content += `
Időjárás: ${weather.temperature || 'N/A'}°C, ${weather.conditions || weather.wind_speed ? `szél ${weather.wind_speed}km/h` : 'Nincs adat'}
`;
                        }
                        
                        // Probabilities used
                        if (match.fair_odds_calculation) {
                            content += `
HASZNÁLT VALÓSZÍNŰSÉGEK:
• Hazai győzelem: ${(match.fair_odds_calculation.home_win_prob * 100).toFixed(1)}%
• Döntetlen: ${(match.fair_odds_calculation.draw_prob * 100).toFixed(1)}%
• Vendég győzelem: ${(match.fair_odds_calculation.away_win_prob * 100).toFixed(1)}%
`;
                        }
                        
                        // Data sources
                        if (match.data_sources) {
                            content += `
Adatforrások: ${match.data_sources.join(', ')}
`;
                        }
                        
                        // Reasoning
                        if (match.reasoning) {
                            content += `
Elemzési indoklás: ${match.reasoning.substring(0, 200)}${match.reasoning.length > 200 ? '...' : ''}
`;
                        }
                        
                        content += '\n';
                    });
                });
            }

            content += `
================================================================================
ELLENŐRZÉSI ÚTMUTATÓ:
================================================================================

1. FORMA ELLENŐRZÉSE:
   • Ellenőrizze a csapatok legutóbbi 5 meccsének eredményeit
   • Hasonlítsa össze a tényleges eredményeket a fenti adatokkal

2. SÉRÜLÉSEK ELLENŐRZÉSE:
   • Nézze meg a hivatalos csapat honlapokat
   • Ellenőrizze a sportnews oldalakat a legfrissebb sérülés hírekért

3. LIGA POZÍCIÓK:
   • Ellenőrizze a hivatalos liga tabellákat
   • Győződjön meg róla, hogy a pontszámok aktuálisak

4. IDŐJÁRÁS (szabadtéri sportok):
   • Ellenőrizze a helyi időjárás előrejelzést
   • Vegye figyelembe a szél és eső hatását

5. ODDS ELLENŐRZÉS:
   • Hasonlítsa össze több fogadóiroda szorzóit
   • Figyelje meg az odds mozgásokat

FONTOS: Ha jelentős eltéréseket talál a fenti adatok és a valóság között,
újra kell gondolni a fogadási döntéseket!

================================================================================
MATEMATIKAI MODELLEK VALIDÁCIÓJA:
================================================================================

A program az alábbi matematikai modelleket használja:
• Kelly Kritérium optimális tétméretek számításához
• Poisson eloszlás gólok előrejelzéséhez (labdarúgás)
• Elo rating rendszer (tenisz)
• Dixon-Coles modell (fejlett labdarúgás elemzés)

Ezek a modellek tudományosan megalapozottak, de a sportfogadás természeténél
fogva mindig van kockázat. Soha ne fogadjon többet, mint amit megengedhet
magának elveszíteni.
`;

            downloadFile(content, 'data_sources_verification.txt', 'text/plain');
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showLocalizedNotification('downloadComplete', 'success', { filename });
        }

        // --- PROFESSIONAL MATHEMATICAL SCORING SYSTEM --- //
        function calculateProfessionalScore(bet) {
            const { prob, odds, stake, ev, confidence, sport, matchAnalysis } = bet;
            
            // 1. BASE EV SCORE (40% weight)
            const evPercent = (ev / stake) * 100;
            const evScore = Math.min(evPercent / 25, 4); // Max 4 points for 25%+ EV
            
            // 2. KELLY EFFICIENCY SCORE (25% weight)
            const b = odds - 1;
            const q = 1 - prob;
            const kellyFraction = (b * prob - q) / b;
            const kellyScore = Math.max(0, Math.min(kellyFraction * 20, 3)); // Max 3 points
            
            // 3. CONFIDENCE & RELIABILITY SCORE (20% weight)
            const confidenceScore = confidence * 2; // Max 2 points
            
            // 4. SPORT-SPECIFIC ADJUSTMENTS (10% weight)
            const sportScore = calculateSportSpecificScore(sport, matchAnalysis);
            
            // 5. RISK-ADJUSTED SCORE (5% weight)
            const riskScore = calculateRiskScore(prob, odds, stake);
            
            // TOTAL PROFESSIONAL SCORE
            const totalScore = 
                evScore * 0.4 +
                kellyScore * 0.25 + 
                confidenceScore * 0.2 +
                sportScore * 0.1 +
                riskScore * 0.05;
                
            return totalScore;
        }
        
        function calculateSportSpecificScore(sport, matchAnalysis) {
            if (!matchAnalysis) return 0.5;
            
            let score = 0.5; // Base score
            
            switch(sport) {
                case 'football':
                case 'soccer':
                    // Weather impact for outdoor sports
                    if (matchAnalysis.weather_analysis) {
                        const weatherImpact = matchAnalysis.weather_analysis.team_a_weather_impact;
                        if (weatherImpact < 40 || weatherImpact > 60) {
                            score += 0.3; // Weather advantage
                        }
                    }
                    // Key player impact
                    if (matchAnalysis.missing_players_analysis) {
                        const keyPlayerImpact = matchAnalysis.missing_players_analysis.team_a_missing?.some(p => p.is_key_player);
                        if (keyPlayerImpact) score += 0.2;
                    }
                    break;
                    
                case 'hockey':
                    // Goalie impact (most critical in hockey)
                    if (matchAnalysis.goaltender_analysis) {
                        const goalieImpact = matchAnalysis.goaltender_analysis.home_goalie?.goalie_impact_scale || 50;
                        if (goalieImpact > 70) score += 0.4; // Excellent goalie
                        else if (goalieImpact < 30) score += 0.4; // Poor goalie (fade)
                    }
                    break;
                    
                case 'baseball':
                    // Pitcher impact (most critical in baseball)
                    if (matchAnalysis.starting_pitchers) {
                        const pitcherImpact = matchAnalysis.starting_pitchers.home_pitcher?.pitcher_impact_scale || 50;
                        if (pitcherImpact > 75) score += 0.4; // Excellent pitcher
                        else if (pitcherImpact < 35) score += 0.4; // Poor pitcher (fade)
                    }
                    // Weather impact (very important in baseball)
                    if (matchAnalysis.weather_analysis) {
                        const weatherImpact = matchAnalysis.weather_analysis.team_a_weather_impact;
                        if (weatherImpact < 35 || weatherImpact > 65) {
                            score += 0.3; // Significant weather advantage
                        }
                    }
                    break;
                    
                case 'tennis':
                    // Injury impact (critical in individual sports)
                    if (matchAnalysis.tennis_analysis?.recent_injuries) {
                        const injuryImpact = matchAnalysis.tennis_analysis.recent_injuries;
                        if (injuryImpact.player_a_injury || injuryImpact.player_b_injury) {
                            score += 0.5; // Major advantage in individual sports
                        }
                    }
                    break;
                    
                case 'basketball':
                    // Schedule fatigue (important in basketball)
                    if (matchAnalysis.schedule_analysis) {
                        const backToBback = matchAnalysis.schedule_analysis.back_to_back;
                        if (backToBback) score += 0.2; // Fatigue advantage
                    }
                    break;
            }
            
            return Math.min(score, 1.0); // Cap at 1.0
        }
        
        function calculateRiskScore(prob, odds, stake) {
            // Sharpe ratio calculation
            const b = odds - 1;
            const expectedReturn = prob * b - (1 - prob);
            const variance = prob * (1 - prob) * b * b;
            const stdDev = Math.sqrt(variance);
            
            const sharpeRatio = stdDev > 0 ? expectedReturn / stdDev : 0;
            
            // Risk-adjusted score (higher Sharpe = better risk-adjusted return)
            return Math.min(sharpeRatio, 1.0);
        }
        
        // ADVANCED EV CALCULATION WITH INTEGRATED FACTORS
        function calculateAdvancedEV(bet) {
            const { prob, odds, stake, sport, matchAnalysis } = bet;
            
            // Base EV
            let adjustedProb = prob;
            let adjustedOdds = odds;
            
            // Sport-specific adjustments
            const sportAdjustments = calculateSportAdjustments(sport, matchAnalysis);
            adjustedProb *= sportAdjustments.probMultiplier;
            
            // Weather adjustments (for outdoor sports)
            if (matchAnalysis?.weather_analysis && isOutdoorSport(sport)) {
                const weatherAdj = calculateWeatherAdjustment(matchAnalysis.weather_analysis, sport);
                adjustedProb *= weatherAdj;
            }
            
            // Key player adjustments
            if (matchAnalysis?.missing_players_analysis) {
                const playerAdj = calculatePlayerAdjustment(matchAnalysis.missing_players_analysis, sport);
                adjustedProb *= playerAdj;
            }
            
            // Motivation adjustments
            if (matchAnalysis?.motivation_analysis) {
                const motivationAdj = calculateMotivationAdjustment(matchAnalysis.motivation_analysis);
                adjustedProb *= motivationAdj;
            }
            
            // Final EV calculation
            const finalEV = stake * (adjustedProb * adjustedOdds - 1);
            
            return {
                baseEV: stake * (prob * odds - 1),
                adjustedEV: finalEV,
                adjustedProb,
                adjustments: {
                    sport: sportAdjustments,
                    weather: matchAnalysis?.weather_analysis ? calculateWeatherAdjustment(matchAnalysis.weather_analysis, sport) : 1,
                    players: matchAnalysis?.missing_players_analysis ? calculatePlayerAdjustment(matchAnalysis.missing_players_analysis, sport) : 1,
                    motivation: matchAnalysis?.motivation_analysis ? calculateMotivationAdjustment(matchAnalysis.motivation_analysis) : 1
                }
            };
        }
        
        function calculateSportAdjustments(sport, matchAnalysis) {
            let probMultiplier = 1.0;
            
            switch(sport) {
                case 'hockey':
                    // Goalie impact
                    if (matchAnalysis?.goaltender_analysis) {
                        const goalieImpact = matchAnalysis.goaltender_analysis.home_goalie?.goalie_impact_scale || 50;
                        probMultiplier *= 0.7 + (goalieImpact / 100) * 0.6; // 0.7-1.3 range
                    }
                    break;
                    
                case 'baseball':
                    // Pitcher impact
                    if (matchAnalysis?.starting_pitchers) {
                        const pitcherImpact = matchAnalysis.starting_pitchers.home_pitcher?.pitcher_impact_scale || 50;
                        probMultiplier *= 0.6 + (pitcherImpact / 100) * 0.8; // 0.6-1.4 range
                    }
                    break;
                    
                case 'tennis':
                    // Surface advantage
                    if (matchAnalysis?.tennis_analysis?.surface_advantage) {
                        const surfaceAdv = matchAnalysis.tennis_analysis.surface_advantage.player_a_advantage || 50;
                        probMultiplier *= 0.8 + (surfaceAdv / 100) * 0.4; // 0.8-1.2 range
                    }
                    break;
            }
            
            return { probMultiplier };
        }
        
        function calculateWeatherAdjustment(weatherAnalysis, sport) {
            if (!isOutdoorSport(sport)) return 1.0;
            
            const weatherImpact = weatherAnalysis.team_a_weather_impact || 50;
            
            // Convert weather impact to probability adjustment
            // 50 = neutral, <50 = negative, >50 = positive
            const adjustment = 0.85 + (weatherImpact / 100) * 0.3; // 0.85-1.15 range
            
            return adjustment;
        }
        
        function calculatePlayerAdjustment(playerAnalysis, sport) {
            let adjustment = 1.0;
            
            // Home team missing players
            if (playerAnalysis.team_a_missing) {
                playerAnalysis.team_a_missing.forEach(player => {
                    const impact = player.impact_scale || 50;
                    const keyPlayerMultiplier = player.is_key_player ? 1.5 : 1.0;
                    
                    // Convert impact to probability adjustment
                    const playerAdj = 0.5 + (impact / 100) * 0.5; // 0.5-1.0 range
                    adjustment *= playerAdj * keyPlayerMultiplier;
                });
            }
            
            return Math.max(0.3, Math.min(adjustment, 1.7)); // Cap between 0.3-1.7
        }
        
        function calculateMotivationAdjustment(motivationAnalysis) {
            const homeMotivation = motivationAnalysis.home_team_motivation?.motivation_scale || 50;
            const awayMotivation = motivationAnalysis.away_team_motivation?.motivation_scale || 50;
            
            // Relative motivation advantage
            const motivationDiff = homeMotivation - awayMotivation;
            
            // Convert to probability adjustment
            const adjustment = 1.0 + (motivationDiff / 100) * 0.1; // ±10% max adjustment
            
            return Math.max(0.9, Math.min(adjustment, 1.1)); // Cap between 0.9-1.1
        }
        
        function isOutdoorSport(sport) {
            return ['football', 'soccer', 'tennis', 'baseball', 'americanfootball'].includes(sport);
        }
        
        // LONG-TERM PROFITABILITY CALCULATOR
        function calculateLongTermProfitability(portfolio) {
            const { singles, parlays } = portfolio;
            const allBets = [...singles, ...parlays];
            
            if (allBets.length === 0) return null;
            
            // Calculate expected outcomes over 1000 simulations
            const simulations = 1000;
            let totalProfit = 0;
            let winCount = 0;
            let maxDrawdown = 0;
            let currentDrawdown = 0;
            let peakCapital = 0;
            
            for (let sim = 0; sim < simulations; sim++) {
                let simProfit = 0;
                
                allBets.forEach(bet => {
                    const { prob, stake, odds } = bet;
                    const random = Math.random();
                    
                    if (random < prob) {
                        // Win
                        simProfit += stake * (odds - 1);
                        winCount++;
                    } else {
                        // Loss
                        simProfit -= stake;
                    }
                });
                
                totalProfit += simProfit;
                
                // Track drawdown
                if (simProfit > peakCapital) {
                    peakCapital = simProfit;
                    currentDrawdown = 0;
                } else {
                    currentDrawdown = peakCapital - simProfit;
                    if (currentDrawdown > maxDrawdown) {
                        maxDrawdown = currentDrawdown;
                    }
                }
            }
            
            const avgProfit = totalProfit / simulations;
            const winRate = winCount / (simulations * allBets.length);
            const totalStaked = allBets.reduce((sum, bet) => sum + bet.stake, 0);
            const roi = (avgProfit / totalStaked) * 100;
            
            return {
                expectedProfit: avgProfit,
                winRate,
                roi,
                maxDrawdown,
                profitability: avgProfit > 0 ? 'PROFITABLE' : 'UNPROFITABLE',
                confidence: Math.min(95, Math.max(5, 50 + roi * 2)) // Confidence based on ROI
            };
        }

        // --- HELPER FUNCTIONS --- //
        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            if (!element) {
                showLocalizedNotification('errorElementNotFound', 'error');
                return;
            }
            
            const text = element.textContent || element.innerText;
            if (!text) {
                showLocalizedNotification('errorNoTextToCopy', 'error');
                return;
            }
            
            // Modern clipboard API
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(text).then(() => {
                    showLocalizedNotification('notificationCopiedToClipboard', 'success');
                }).catch(err => {
                    console.error('Clipboard API failed:', err);
                    fallbackCopyToClipboard(text);
                });
            } else {
                fallbackCopyToClipboard(text);
            }
        }
        
        function fallbackCopyToClipboard(text) {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showLocalizedNotification('notificationCopiedToClipboard', 'success');
                } else {
                    showLocalizedNotification('errorCopyFailed', 'error');
                }
            } catch (err) {
                console.error('Fallback copy failed:', err);
                showLocalizedNotification('errorCopyFailed', 'error');
            } finally {
                document.body.removeChild(textArea);
            }
        }

    </script>
</body>
</html>
